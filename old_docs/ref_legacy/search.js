window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "doctable", "modulename": "doctable", "kind": "module", "doc": "<h1 id=\"what-is-doctable\">What is doctable?</h1>\n\n<p>doctable is a python package for designing and manipulating database tables through an object-oriented interface without the overhead of ORM. Read more on <a href=\"https://doctable.org\">doctable.org</a>.</p>\n\n<h1 id=\"important-objects\">Important Objects</h1>\n\n<ul>\n<li><a href=\"doctable/doctable.html\">DocTable</a></li>\n<li><p><a href=\"doctable/connectengine.html\">ConnectEngine</a></p></li>\n<li><p><a href=\"doctable/parse/pipeline.html\">ParsePipeline</a></p></li>\n<li><a href=\"doctable/parse/parsefuncs.html\">Parsing Functions</a></li>\n<li><p><a href=\"doctable/parse/parsetree.html\">ParseTree</a></p></li>\n<li><p><a href=\"doctable/util/stepper.html\">Stepper</a></p></li>\n<li><a href=\"doctable/util/fsstore.html\">FSStore</a></li>\n<li><a href=\"doctable/util/tempfolder.html\">TempFolder</a></li>\n<li><a href=\"doctable/util/io.html\">I/O Functions</a></li>\n</ul>\n\n<h1 id=\"additional-resources\">Additional Resources</h1>\n\n<p><a href=\"https://pypi.org/project/doctable/\">PyPi page</a></p>\n\n<p><a href=\"https://github.com/devincornell/doctable\">Github page</a></p>\n"}, {"fullname": "doctable.name", "modulename": "doctable", "qualname": "name", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;doctable&#x27;"}, {"fullname": "doctable.f", "modulename": "doctable", "qualname": "f", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.f.max", "modulename": "doctable", "qualname": "f.max", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;sqlalchemy.sql.functions._FunctionGenerator object&gt;"}, {"fullname": "doctable.f.min", "modulename": "doctable", "qualname": "f.min", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;sqlalchemy.sql.functions._FunctionGenerator object&gt;"}, {"fullname": "doctable.f.count", "modulename": "doctable", "qualname": "f.count", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;sqlalchemy.sql.functions._FunctionGenerator object&gt;"}, {"fullname": "doctable.f.sum", "modulename": "doctable", "qualname": "f.sum", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;sqlalchemy.sql.functions._FunctionGenerator object&gt;"}, {"fullname": "doctable.f.distinct", "modulename": "doctable", "qualname": "f.distinct", "kind": "function", "doc": "<p>Produce an column-expression-level unary <code>DISTINCT</code> clause.</p>\n\n<p>This applies the <code>DISTINCT</code> keyword to an individual column\nexpression, and is typically contained within an aggregate function,\nas in::</p>\n\n<pre><code>from sqlalchemy import distinct, func\nstmt = select(func.count(distinct(users_table.c.name)))\n</code></pre>\n\n<p>The above would produce an expression resembling::</p>\n\n<pre><code>SELECT COUNT(DISTINCT name) FROM user\n</code></pre>\n\n<p>The <code>.distinct()</code> function is also available as a column-level\nmethod, e.g. <code>_expression.ColumnElement.distinct()</code>, as in::</p>\n\n<pre><code>stmt = select(func.count(users_table.c.name.distinct()))\n</code></pre>\n\n<p>The <code>.distinct()</code> operator is different from the\n<code>_expression.Select.distinct()</code> method of\n<code>_expression.Select</code>,\nwhich produces a <code>SELECT</code> statement\nwith <code>DISTINCT</code> applied to the result set as a whole,\ne.g. a <code>SELECT DISTINCT</code> expression.  See that method for further\ninformation.</p>\n\n<p><em>seealso:</em>\n<code>_expression.ColumnElement.distinct()</code></p>\n\n<p><code>_expression.Select.distinct()</code></p>\n\n<p><code>.func</code></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"s1\">&#39;_ColumnExpressionArgument[_T]&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">UnaryExpression</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">_T</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.f.between", "modulename": "doctable", "qualname": "f.between", "kind": "function", "doc": "<p>Produce a <code>BETWEEN</code> predicate clause.</p>\n\n<p>E.g.::</p>\n\n<pre><code>from sqlalchemy import between\nstmt = select(users_table).where(between(users_table.c.id, 5, 7))\n</code></pre>\n\n<p>Would produce SQL resembling::</p>\n\n<pre><code>SELECT id, name FROM user WHERE id BETWEEN :id_1 AND :id_2\n</code></pre>\n\n<p>The <code>.between()</code> function is a standalone version of the\n<code>_expression.ColumnElement.between()</code> method available on all\nSQL expressions, as in::</p>\n\n<pre><code>stmt = select(users_table).where(users_table.c.id.between(5, 7))\n</code></pre>\n\n<p>All arguments passed to <code>.between()</code>, including the left side\ncolumn expression, are coerced from Python scalar values if a\nthe value is not a <code>_expression.ColumnElement</code> subclass.\nFor example,\nthree fixed values can be compared as in::</p>\n\n<pre><code>print(between(5, 3, 7))\n</code></pre>\n\n<p>Which would produce::</p>\n\n<pre><code>:param_1 BETWEEN :param_2 AND :param_3\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>expr</strong>:  a column expression, typically a\n<code>_expression.ColumnElement</code>\ninstance or alternatively a Python scalar expression to be coerced\ninto a column expression, serving as the left side of the <code>BETWEEN</code>\nexpression.</p></li>\n<li><p><strong>lower_bound</strong>:  a column or Python scalar expression serving as the\nlower bound of the right side of the <code>BETWEEN</code> expression.</p></li>\n<li><p><strong>upper_bound</strong>:  a column or Python scalar expression serving as the\nupper bound of the right side of the <code>BETWEEN</code> expression.</p></li>\n<li><p><strong>symmetric</strong>:  if True, will render \" BETWEEN SYMMETRIC \". Note\nthat not all databases support this syntax.</p></li>\n</ul>\n\n<p><em>seealso:</em>\n<code>_expression.ColumnElement.between()</code></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"s1\">&#39;_ColumnExpressionOrLiteralArgument[_T]&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">lower_bound</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">upper_bound</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">symmetric</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.f.all_", "modulename": "doctable", "qualname": "f.all_", "kind": "function", "doc": "<p>Produce an ALL expression.</p>\n\n<p>For dialects such as that of PostgreSQL, this operator applies\nto usage of the <code>_types.ARRAY</code> datatype, for that of\nMySQL, it may apply to a subquery.  e.g.::</p>\n\n<pre><code># renders on PostgreSQL:\n# '5 = ALL (somearray)'\nexpr = 5 == all_(mytable.c.somearray)\n\n# renders on MySQL:\n# '5 = ALL (SELECT value FROM table)'\nexpr = 5 == all_(select(table.c.value))\n</code></pre>\n\n<p>Comparison to NULL may work using <code>None</code>::</p>\n\n<pre><code>None == all_(mytable.c.somearray)\n</code></pre>\n\n<p>The any_() / all_() operators also feature a special \"operand flipping\"\nbehavior such that if any_() / all_() are used on the left side of a\ncomparison using a standalone operator such as <code>==</code>, <code>!=</code>, etc.\n(not including operator methods such as\n<code>_sql.ColumnOperators.is_()</code>) the rendered expression is flipped::</p>\n\n<pre><code># would render '5 = ALL (column)`\nall_(mytable.c.column) == 5\n</code></pre>\n\n<p>Or with <code>None</code>, which note will not perform\nthe usual step of rendering \"IS\" as is normally the case for NULL::</p>\n\n<pre><code># would render 'NULL = ALL(somearray)'\nall_(mytable.c.somearray) == None\n</code></pre>\n\n<p><em>Changed in version 1.4.26  repaired the use of any_() / all_():</em>\ncomparing to NULL on the right side to be flipped to the left.</p>\n\n<p>The column-level <code>_sql.ColumnElement.all_()</code> method (not to be\nconfused with <code>_types.ARRAY</code> level\n<code>_types.ARRAY.Comparator.all()</code>) is shorthand for\n<code>all_(col)</code>::</p>\n\n<pre><code>5 == mytable.c.somearray.all_()\n</code></pre>\n\n<p><em>seealso:</em>\n<code>_sql.ColumnOperators.all_()</code></p>\n\n<p><code>_expression.any_()</code></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"s1\">&#39;_ColumnExpressionArgument[_T]&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">CollectionAggregate</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.f.and_", "modulename": "doctable", "qualname": "f.and_", "kind": "function", "doc": "<p>Produce a conjunction of expressions joined by <code>AND</code>.</p>\n\n<p>E.g.::</p>\n\n<pre><code>from sqlalchemy import and_\n\nstmt = select(users_table).where(\n                and_(\n                    users_table.c.name == 'wendy',\n                    users_table.c.enrolled == True\n                )\n            )\n</code></pre>\n\n<p>The <code>.and_()</code> conjunction is also available using the\nPython <code>&amp;</code> operator (though note that compound expressions\nneed to be parenthesized in order to function with Python\noperator precedence behavior)::</p>\n\n<pre><code>stmt = select(users_table).where(\n                (users_table.c.name == 'wendy') &amp;\n                (users_table.c.enrolled == True)\n            )\n</code></pre>\n\n<p>The <code>.and_()</code> operation is also implicit in some cases;\nthe <code>_expression.Select.where()</code>\nmethod for example can be invoked multiple\ntimes against a statement, which will have the effect of each\nclause being combined using <code>.and_()</code>::</p>\n\n<pre><code>stmt = select(users_table).\\\n        where(users_table.c.name == 'wendy').\\\n        where(users_table.c.enrolled == True)\n</code></pre>\n\n<p>The <code>.and_()</code> construct must be given at least one positional\nargument in order to be valid; a <code>.and_()</code> construct with no\narguments is ambiguous.   To produce an \"empty\" or dynamically\ngenerated <code>.and_()</code>  expression, from a given list of expressions,\na \"default\" element of <code>_sql.true()</code> (or just <code>True</code>) should be\nspecified::</p>\n\n<pre><code>from sqlalchemy import true\ncriteria = and_(true(), *expressions)\n</code></pre>\n\n<p>The above expression will compile to SQL as the expression <code>true</code>\nor <code>1 = 1</code>, depending on backend, if no other expressions are\npresent.  If expressions are present, then the <code>_sql.true()</code> value\nis ignored as it does not affect the outcome of an AND expression that\nhas other elements.</p>\n\n<p><em>Deprecated since version 1.4  The <code>.and_()</code> element now requires that at:</em>\nleast one argument is passed; creating the <code>.and_()</code> construct\nwith no arguments is deprecated, and will emit a deprecation warning\nwhile continuing to produce a blank SQL string.</p>\n\n<p><em>seealso:</em>\n<code>.or_()</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">clauses</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.f.or_", "modulename": "doctable", "qualname": "f.or_", "kind": "function", "doc": "<p>Produce a conjunction of expressions joined by <code>OR</code>.</p>\n\n<p>E.g.::</p>\n\n<pre><code>from sqlalchemy import or_\n\nstmt = select(users_table).where(\n                or_(\n                    users_table.c.name == 'wendy',\n                    users_table.c.name == 'jack'\n                )\n            )\n</code></pre>\n\n<p>The <code>.or_()</code> conjunction is also available using the\nPython <code>|</code> operator (though note that compound expressions\nneed to be parenthesized in order to function with Python\noperator precedence behavior)::</p>\n\n<pre><code>stmt = select(users_table).where(\n                (users_table.c.name == 'wendy') |\n                (users_table.c.name == 'jack')\n            )\n</code></pre>\n\n<p>The <code>.or_()</code> construct must be given at least one positional\nargument in order to be valid; a <code>.or_()</code> construct with no\narguments is ambiguous.   To produce an \"empty\" or dynamically\ngenerated <code>.or_()</code>  expression, from a given list of expressions,\na \"default\" element of <code>_sql.false()</code> (or just <code>False</code>) should be\nspecified::</p>\n\n<pre><code>from sqlalchemy import false\nor_criteria = or_(false(), *expressions)\n</code></pre>\n\n<p>The above expression will compile to SQL as the expression <code>false</code>\nor <code>0 = 1</code>, depending on backend, if no other expressions are\npresent.  If expressions are present, then the <code>_sql.false()</code> value\nis ignored as it does not affect the outcome of an OR expression which\nhas other elements.</p>\n\n<p><em>Deprecated since version 1.4  The <code>.or_()</code> element now requires that at:</em>\nleast one argument is passed; creating the <code>.or_()</code> construct\nwith no arguments is deprecated, and will emit a deprecation warning\nwhile continuing to produce a blank SQL string.</p>\n\n<p><em>seealso:</em>\n<code>.and_()</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">clauses</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.f.not_", "modulename": "doctable", "qualname": "f.not_", "kind": "function", "doc": "<p>Return a negation of the given clause, i.e. <code>NOT(clause)</code>.</p>\n\n<p>The <code>~</code> operator is also overloaded on all\n<code>_expression.ColumnElement</code> subclasses to produce the\nsame result.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">clause</span><span class=\"p\">:</span> <span class=\"s1\">&#39;_ColumnExpressionArgument[_T]&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">ColumnElement</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">_T</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.f.desc", "modulename": "doctable", "qualname": "f.desc", "kind": "function", "doc": "<p>Produce a descending <code>ORDER BY</code> clause element.</p>\n\n<p>e.g.::</p>\n\n<pre><code>from sqlalchemy import desc\n\nstmt = select(users_table).order_by(desc(users_table.c.name))\n</code></pre>\n\n<p>will produce SQL as::</p>\n\n<pre><code>SELECT id, name FROM user ORDER BY name DESC\n</code></pre>\n\n<p>The <code>.desc()</code> function is a standalone version of the\n<code>_expression.ColumnElement.desc()</code>\nmethod available on all SQL expressions,\ne.g.::</p>\n\n<pre><code>stmt = select(users_table).order_by(users_table.c.name.desc())\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>column</strong>:  A <code>_expression.ColumnElement</code> (e.g.\nscalar SQL expression)\nwith which to apply the <code>.desc()</code> operation.</li>\n</ul>\n\n<p><em>seealso:</em>\n<code>.asc()</code></p>\n\n<p><code>.nulls_first()</code></p>\n\n<p><code>.nulls_last()</code></p>\n\n<p><code>_expression.Select.order_by()</code></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">column</span><span class=\"p\">:</span> <span class=\"s1\">&#39;_ColumnExpressionOrStrLabelArgument[_T]&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">UnaryExpression</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">_T</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.f.asc", "modulename": "doctable", "qualname": "f.asc", "kind": "function", "doc": "<p>Produce an ascending <code>ORDER BY</code> clause element.</p>\n\n<p>e.g.::</p>\n\n<pre><code>from sqlalchemy import asc\nstmt = select(users_table).order_by(asc(users_table.c.name))\n</code></pre>\n\n<p>will produce SQL as::</p>\n\n<pre><code>SELECT id, name FROM user ORDER BY name ASC\n</code></pre>\n\n<p>The <code>.asc()</code> function is a standalone version of the\n<code>_expression.ColumnElement.asc()</code>\nmethod available on all SQL expressions,\ne.g.::</p>\n\n<pre><code>stmt = select(users_table).order_by(users_table.c.name.asc())\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>column</strong>:  A <code>_expression.ColumnElement</code> (e.g.\nscalar SQL expression)\nwith which to apply the <code>.asc()</code> operation.</li>\n</ul>\n\n<p><em>seealso:</em>\n<code>.desc()</code></p>\n\n<p><code>.nulls_first()</code></p>\n\n<p><code>.nulls_last()</code></p>\n\n<p><code>_expression.Select.order_by()</code></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">column</span><span class=\"p\">:</span> <span class=\"s1\">&#39;_ColumnExpressionOrStrLabelArgument[_T]&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">UnaryExpression</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">_T</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.f.any_", "modulename": "doctable", "qualname": "f.any_", "kind": "function", "doc": "<p>Produce an ANY expression.</p>\n\n<p>For dialects such as that of PostgreSQL, this operator applies\nto usage of the <code>_types.ARRAY</code> datatype, for that of\nMySQL, it may apply to a subquery.  e.g.::</p>\n\n<pre><code># renders on PostgreSQL:\n# '5 = ANY (somearray)'\nexpr = 5 == any_(mytable.c.somearray)\n\n# renders on MySQL:\n# '5 = ANY (SELECT value FROM table)'\nexpr = 5 == any_(select(table.c.value))\n</code></pre>\n\n<p>Comparison to NULL may work using <code>None</code> or <code>_sql.null()</code>::</p>\n\n<pre><code>None == any_(mytable.c.somearray)\n</code></pre>\n\n<p>The any_() / all_() operators also feature a special \"operand flipping\"\nbehavior such that if any_() / all_() are used on the left side of a\ncomparison using a standalone operator such as <code>==</code>, <code>!=</code>, etc.\n(not including operator methods such as\n<code>_sql.ColumnOperators.is_()</code>) the rendered expression is flipped::</p>\n\n<pre><code># would render '5 = ANY (column)`\nany_(mytable.c.column) == 5\n</code></pre>\n\n<p>Or with <code>None</code>, which note will not perform\nthe usual step of rendering \"IS\" as is normally the case for NULL::</p>\n\n<pre><code># would render 'NULL = ANY(somearray)'\nany_(mytable.c.somearray) == None\n</code></pre>\n\n<p><em>Changed in version 1.4.26  repaired the use of any_() / all_():</em>\ncomparing to NULL on the right side to be flipped to the left.</p>\n\n<p>The column-level <code>_sql.ColumnElement.any_()</code> method (not to be\nconfused with <code>_types.ARRAY</code> level\n<code>_types.ARRAY.Comparator.any()</code>) is shorthand for\n<code>any_(col)</code>::</p>\n\n<pre><code>5 = mytable.c.somearray.any_()\n</code></pre>\n\n<p><em>seealso:</em>\n<code>_sql.ColumnOperators.any_()</code></p>\n\n<p><code>_expression.all_()</code></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"s1\">&#39;_ColumnExpressionArgument[_T]&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">CollectionAggregate</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.f.alias", "modulename": "doctable", "qualname": "f.alias", "kind": "function", "doc": "<p>Return a named alias of the given <code>.FromClause</code>.</p>\n\n<p>For <code>.Table</code> and <code>.Join</code> objects, the return type is the\n<code>_expression.Alias</code> object. Other kinds of <code>.NamedFromClause</code>\nobjects may be returned for other kinds of <code>.FromClause</code> objects.</p>\n\n<p>The named alias represents any <code>_expression.FromClause</code> with an\nalternate name assigned within SQL, typically using the <code>AS</code> clause when\ngenerated, e.g. <code>SELECT * FROM table AS aliasname</code>.</p>\n\n<p>Equivalent functionality is available via the\n<code>_expression.FromClause.alias()</code>\nmethod available on all <code>_expression.FromClause</code> objects.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>selectable</strong>:  any <code>_expression.FromClause</code> subclass,\nsuch as a table, select statement, etc.</p></li>\n<li><p><strong>name</strong>:  string name to be assigned as the alias.\nIf <code>None</code>, a name will be deterministically generated at compile\ntime. Deterministic means the name is guaranteed to be unique against\nother constructs used in the same statement, and will also be the same\nname for each successive compilation of the same statement object.</p></li>\n<li><p><strong>flat</strong>:  Will be passed through to if the given selectable\nis an instance of <code>_expression.Join</code> - see\n<code>_expression.Join.alias()</code> for details.</p></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">selectable</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">selectable</span><span class=\"o\">.</span><span class=\"n\">FromClause</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">flat</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">selectable</span><span class=\"o\">.</span><span class=\"n\">NamedFromClause</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.api", "modulename": "doctable.api", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.connectengine", "modulename": "doctable.connectengine", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.connectengine.ConnectEngine", "modulename": "doctable.connectengine", "qualname": "ConnectEngine", "kind": "class", "doc": "<p>Class to maintain sqlalchemy engine and metadata information for doctables.</p>\n"}, {"fullname": "doctable.connectengine.ConnectEngine.__init__", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.__init__", "kind": "function", "doc": "<p>Initializes sqlalchemy engine  and metadata objects.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target:</strong>  choose target database for connection.</li>\n<li><strong>echo:</strong>  sets the echo status used in sqlalchemy.create_engine().\nThis will output every sql query upon execution.</li>\n<li><strong>connect_args:</strong>  passed to sqlalchemy.create_engine() as the connect_args param.\nSee more options in the official docs:\n<a href=\"https://docs.sqlalchemy.org/en/13/core/engines.html#sqlalchemy.create_engine\">https://docs.sqlalchemy.org/en/13/core/engines.html#sqlalchemy.create_engine</a></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dialect</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;sqlite&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">new_db</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">foreign_keys</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">echo</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">engine_kwargs</span></span>)</span>"}, {"fullname": "doctable.connectengine.ConnectEngine.execute", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.execute", "kind": "function", "doc": "<p>Execute query using a temporary connection.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">query</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">args</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">cursor</span><span class=\"o\">.</span><span class=\"n\">CursorResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.schema", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.schema", "kind": "function", "doc": "<p>Read schema information for single table using inspect.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tabname:</strong>  name of table to inspect.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dictionary</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tabname</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.schema_df", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.schema_df", "kind": "function", "doc": "<p>Read schema information for table as pandas dataframe.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>pandas dataframe</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tabname</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.inspect_columns", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.inspect_columns", "kind": "function", "doc": "<p>Wraps Inspector.get_columns(tabname).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tabname</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.inspect_indices", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.inspect_indices", "kind": "function", "doc": "<p>Wraps Inspector.get_indexes(tabname).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tabname</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.inspect_columns_all", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.inspect_columns_all", "kind": "function", "doc": "<p>Get column info for all tables.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.inspect_indices_all", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.inspect_indices_all", "kind": "function", "doc": "<p>Get index info for all tables.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.inspector", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.inspector", "kind": "variable", "doc": "<p>Get engine for this inspector.\n<a href=\"https://docs.sqlalchemy.org/en/14/core/reflection.html#sqlalchemy.engine.reflection.Inspector\">https://docs.sqlalchemy.org/en/14/core/reflection.html#sqlalchemy.engine.reflection.Inspector</a></p>\n", "annotation": ": sqlalchemy.engine.reflection.Inspector"}, {"fullname": "doctable.connectengine.ConnectEngine.dialect", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.dialect", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.connectengine.ConnectEngine.target", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.target", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.connectengine.ConnectEngine.metadata", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.metadata", "kind": "variable", "doc": "<p></p>\n", "annotation": ": sqlalchemy.sql.schema.MetaData"}, {"fullname": "doctable.connectengine.ConnectEngine.tables", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.tables", "kind": "variable", "doc": "<p>Access metadata.tables</p>\n", "annotation": ": Dict[str, sqlalchemy.sql.schema.Table]"}, {"fullname": "doctable.connectengine.ConnectEngine.list_tables", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.list_tables", "kind": "function", "doc": "<p>List table names in database connection.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.connect", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.connect", "kind": "function", "doc": "<p>Open new connection in the engine connection pool.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Connection</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.reopen", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.reopen", "kind": "function", "doc": "<p>Deletes all connections and clears metadata.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">cursor</span><span class=\"o\">.</span><span class=\"n\">CursorResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.dispose", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.dispose", "kind": "function", "doc": "<p>Closes all existing connections attached to engine.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">cursor</span><span class=\"o\">.</span><span class=\"n\">CursorResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.clear_metadata", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.clear_metadata", "kind": "function", "doc": "<p>Remove all tables from sqlalchemy metadata.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.create_all", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.create_all", "kind": "function", "doc": "<p>Create table metadata from all existing tables.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.remove_table", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.remove_table", "kind": "function", "doc": "<p>Remove the given Table object from sqlalchemy metadata (not for dropping tables).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">table</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.add_table", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.add_table", "kind": "function", "doc": "<p>Adds a table to the metadata by name. If columns not provided, creates by autoload.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tabname (str):</strong>  name of new table.</li>\n<li><strong>columns (list/tuple):</strong>  column objects passed to sqlalchemy.Table</li>\n<li><strong>table_kwargs:</strong>  passed to sqlalchemy.Table constructor.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">tabname</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">columns</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">Index</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">constraints</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Constraint</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">new_table</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">allow_inconsistent_schema</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">create_indices</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">table_kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.new_table", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.new_table", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">tabname</span>,</span><span class=\"param\">\t<span class=\"n\">columns</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">table_kwargs</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Table</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.reflect_table", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.reflect_table", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">tabname</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">table_kwargs</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Table</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.create_indices", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.create_indices", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">Index</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">table</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Table</span>,</span><span class=\"param\">\t<span class=\"n\">allow_inconsistent_schema</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.bind_column_methods", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.bind_column_methods", "kind": "function", "doc": "<p>Binds sqlalchemy methods to column objects.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">table</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Table</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.check_column_consistency", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.check_column_consistency", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">existing_colnames</span><span class=\"p\">:</span> <span class=\"n\">Set</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">provided_cols</span><span class=\"p\">:</span> <span class=\"n\">Set</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.get_new_indices", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.get_new_indices", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">tabname</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">Index</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">allow_inconsistent_schema</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">Index</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.reflect", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.reflect", "kind": "function", "doc": "<p>Will register all existing tables using metadata.reflect().</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.drop_table", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.drop_table", "kind": "function", "doc": "<p>Drops table, either sqlalchemy object or by executing DROP TABLE.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>table (sqlalchemy.Table/str):</strong>  table object or name to drop.</li>\n<li><strong>if_exists (bool):</strong>  if true, won't throw exception if table doesn't exist.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">table</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Table</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">if_exists</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.dbutils", "modulename": "doctable.dbutils", "kind": "module", "doc": "<p>This file contains functions for migrating database tables.\nThis means adding or removing columns, etc.</p>\n"}, {"fullname": "doctable.dbutils.list_tables", "modulename": "doctable.dbutils", "qualname": "list_tables", "kind": "function", "doc": "<p>List tables in an sqlite database.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target (str):</strong>  sql file or endpoint to connect to</li>\n<li><strong>dialect (str):</strong>  sql dialect to use for conenction</li>\n<li><strong>engine_args (kwargs):</strong>  passed to sqlalchemy ConnectEngine</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"s1\">&#39;:memory:&#39;</span>, </span><span class=\"param\"><span class=\"n\">dialect</span><span class=\"o\">=</span><span class=\"s1\">&#39;sqlite&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">engine_args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.dbutils.migrate_db", "modulename": "doctable.dbutils", "qualname": "migrate_db", "kind": "function", "doc": "<p>Moves old database to db with new schema.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>oldfname (str):</strong>  filename of old database.</li>\n<li><strong>newfname (str):</strong>  filename of new database.</li>\n<li><strong>newschema (list<list>):</strong>  shema that would be \nused in the constructor to a doctable\ninstance.</li>\n<li><strong>newcolmap (dict<colname->func>):</strong>  Allows for \npopulation of new columns if they are a function \nof the associated row.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">oldfname</span>, </span><span class=\"param\"><span class=\"n\">newfname</span>, </span><span class=\"param\"><span class=\"n\">newschema</span>, </span><span class=\"param\"><span class=\"n\">newcolmap</span><span class=\"o\">=</span><span class=\"p\">{}</span>, </span><span class=\"param\"><span class=\"n\">delcols</span><span class=\"o\">=</span><span class=\"p\">[]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable", "modulename": "doctable.doctable", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.doctable.DEFAULT_TABNAME", "modulename": "doctable.doctable", "qualname": "DEFAULT_TABNAME", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;_documents_&#x27;"}, {"fullname": "doctable.doctable.DocTable", "modulename": "doctable.doctable", "qualname": "DocTable", "kind": "class", "doc": "<p>Class for managing a single database table.\nDescription: This class manages schema and connection information to provide\n    an object-based interface to perform queries on a single table \n    in a database (although multi-table designs are possible with \n    multiple DocTables). It is designed to maintain informabout about the \n    underlying database structure of the table, making it possible to \n    execute queries without using the SQL language.</p>\n\n<p>Settable static attributes (overridden if related constructor argument passed):\n    _target_ (str): target database to connect to - used when a doctable\n        will always connect to the same target (i.e., a server etc).\n    _tabname_ (str): name of table to connect to (and create).\n    _schema_ (DocTableSchema): schema definition for this doctable, to be used\n        when creating a new table and to manage table information.\n    _indices_ (dict): indices to apply to the table\n    _constraints_ (list): constraints to apply to the table\n    _doctable_args_ (dict): any other constructor arguments that should always\n        be used when instantiating. Overridden by providing arguments\n        to the constructor.</p>\n"}, {"fullname": "doctable.doctable.DocTable.__init__", "modulename": "doctable.doctable", "qualname": "DocTable.__init__", "kind": "function", "doc": "<p>Create new database.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target (str):</strong>  filename for database to connect to. \":memory:\" is a \nspecial value indicating to the python sqlite engine that the db\nshould be created in memory. Will create new empty database file\nif it does not exist and new_db==True, and add a new table using\nspecified schema if new_table==True.</li>\n<li><strong>tabname (str):</strong>  table name for this specific doctable.</li>\n<li><strong>schema (type or list<list>):</strong>  schema from which to create db. Includes a\nlist of column names and types (including contraints and indexes) as tuples\ndefined according to information needed to construct the sqlalchemy\nobjects. Alternatively, can be a schema class (see docs).</li>\n<li><strong>dialect (str):</strong>  database engine through which to construct db.\nFor more info, see sqlalchemy dialect info:\n<a href=\"https://docs.sqlalchemy.org/en/13/dialects/\">https://docs.sqlalchemy.org/en/13/dialects/</a></li>\n<li><strong>engine (ConnectEngine):</strong>  engine from another doctable if working with different\ntables in the same db.</li>\n<li><strong>readonly (bool):</strong>  Prevents user from calling insert(), delete(), or \nupdate(). Will not block other sql possible commands.</li>\n<li><strong>new_db (bool):</strong>  Indicate if new db file should be created given \nthat a schema is provided and the db file doesn't exist.</li>\n<li><strong>new_table (bool):</strong>  Allow doctable to create a new table if one \ndoesn't exist already.</li>\n<li><strong>persistent_conn (bool):</strong>  whether or not to create a persistent conn \nto database. Otherwise will create temporary connection for each\nquery.</li>\n<li><strong>verbose (bool):</strong>  Print every sql command before executing.</li>\n<li><strong>engine_kwargs (</strong>kwargs):**  Pass directly to the sqlalchemy\n.create_engine() as connect_args. Args typically vary by dialect.\nExample: connect_args={'timeout': 15} for sqlite\nor connect_args={'connect_timeout': 15} for PostgreSQL.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">schema</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tabname</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">Index</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">constraints</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Constraint</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dialect</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;sqlite&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">engine</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">connectengine</span><span class=\"o\">.</span><span class=\"n\">ConnectEngine</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">readonly</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">new_db</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">new_table</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">persistent_conn</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">allow_inconsistent_schema</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">create_indices</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">engine_kwargs</span></span>)</span>"}, {"fullname": "doctable.doctable.DocTable.dialect", "modulename": "doctable.doctable", "qualname": "DocTable.dialect", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.doctable.DocTable.verbose", "modulename": "doctable.doctable", "qualname": "DocTable.verbose", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.doctable.DocTable.persistent_conn", "modulename": "doctable.doctable", "qualname": "DocTable.persistent_conn", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.doctable.DocTable.readonly", "modulename": "doctable.doctable", "qualname": "DocTable.readonly", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.doctable.DocTable.close_conn", "modulename": "doctable.doctable", "qualname": "DocTable.close_conn", "kind": "function", "doc": "<p>Closes connection to db (if one exists).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.open_conn", "modulename": "doctable.doctable", "qualname": "DocTable.open_conn", "kind": "function", "doc": "<p>Opens connection to db (if one does not exist).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.connect", "modulename": "doctable.doctable", "qualname": "DocTable.connect", "kind": "function", "doc": "<p>Returns a connection from the sqlalchemy engine.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Connection</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.reopen_engine", "modulename": "doctable.doctable", "qualname": "DocTable.reopen_engine", "kind": "function", "doc": "<p>Opens connection engine. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>open_conn (bool):</strong>  create a new db connection.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">open_conn</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.col", "modulename": "doctable.doctable", "qualname": "DocTable.col", "kind": "function", "doc": "<p>Accesses a column object.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li>Name of column to access. Applied as subscript to \nsqlalchemy columns object.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.table", "modulename": "doctable.doctable", "qualname": "DocTable.table", "kind": "variable", "doc": "<p>Returns underlying sqlalchemy table object for manual manipulation.</p>\n", "annotation": ": sqlalchemy.sql.schema.Table"}, {"fullname": "doctable.doctable.DocTable.tabname", "modulename": "doctable.doctable", "qualname": "DocTable.tabname", "kind": "variable", "doc": "<p>Gets name of table for this connection.</p>\n", "annotation": ": str"}, {"fullname": "doctable.doctable.DocTable.columns", "modulename": "doctable.doctable", "qualname": "DocTable.columns", "kind": "variable", "doc": "<p>Exposes SQLAlchemy core table columns object.</p>\n", "annotation": ": &#x27;sqlalchemy.sql.base.ImmutableColumnCollection&#x27;"}, {"fullname": "doctable.doctable.DocTable.c", "modulename": "doctable.doctable", "qualname": "DocTable.c", "kind": "variable", "doc": "<p>Alias for self.columns.</p>\n", "annotation": ": &#x27;sqlalchemy.sql.base.ImmutableColumnCollection&#x27;"}, {"fullname": "doctable.doctable.DocTable.engine", "modulename": "doctable.doctable", "qualname": "DocTable.engine", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.connectengine.ConnectEngine"}, {"fullname": "doctable.doctable.DocTable.schema", "modulename": "doctable.doctable", "qualname": "DocTable.schema", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.schema.dataclassschema.dataclassschema.DataclassSchema"}, {"fullname": "doctable.doctable.DocTable.list_tables", "modulename": "doctable.doctable", "qualname": "DocTable.list_tables", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.colnames", "modulename": "doctable.doctable", "qualname": "DocTable.colnames", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.primary_keys", "modulename": "doctable.doctable", "qualname": "DocTable.primary_keys", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.schema_info", "modulename": "doctable.doctable", "qualname": "DocTable.schema_info", "kind": "function", "doc": "<p>Get info about each column as a dictionary.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict<dict>: info about each column.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.schema_table", "modulename": "doctable.doctable", "qualname": "DocTable.schema_table", "kind": "function", "doc": "<p>Get info about each column as a dictionary.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DataFrame: info about each column.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.indices", "modulename": "doctable.doctable", "qualname": "DocTable.indices", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.q", "modulename": "doctable.doctable", "qualname": "DocTable.q", "kind": "variable", "doc": "<p>Gets a query object for this doctable.</p>\n", "annotation": ": doctable.query.query.Query"}, {"fullname": "doctable.doctable.DocTable.execute", "modulename": "doctable.doctable", "qualname": "DocTable.execute", "kind": "function", "doc": "<p>Execute an sql command. Called by most higher-level functions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>query (sqlalchemy condition or str):</strong>  query to execute;\ncan be provided as sqlalchemy condition object or\nplain sql text.</li>\n<li><strong>verbose (bool or None):</strong>  Print SQL command issued before\nexecution.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">query</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">params</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">cursor</span><span class=\"o\">.</span><span class=\"n\">CursorResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.insert", "modulename": "doctable.doctable", "qualname": "DocTable.insert", "kind": "function", "doc": "<p>Depricated. See docs for .q.insert_single() or .q.insert_multi().</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rowdata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span><span class=\"p\">,</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">],</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span><span class=\"p\">],</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">args</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.insert_many", "modulename": "doctable.doctable", "qualname": "DocTable.insert_many", "kind": "function", "doc": "<p>Depricated. See docs for .q.insert_multi(), .q.insert_multi_raw()</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rowdata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span><span class=\"p\">],</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">args</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.insert_single", "modulename": "doctable.doctable", "qualname": "DocTable.insert_single", "kind": "function", "doc": "<p>Depricated. See docs for .q.insert_single(), .q.insert_single_raw().</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rowdata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span><span class=\"p\">,</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">args</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.count", "modulename": "doctable.doctable", "qualname": "DocTable.count", "kind": "function", "doc": "<p>Depricated. See docs for .q.count(), Query.count().</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.head", "modulename": "doctable.doctable", "qualname": "DocTable.head", "kind": "function", "doc": "<p>Depricated. See docs for .q.select_head(), Query.select_head().</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.select_series", "modulename": "doctable.doctable", "qualname": "DocTable.select_series", "kind": "function", "doc": "<p>Depricated. See docs for .q.select_series(), Query.select_series().</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">col</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.select_df", "modulename": "doctable.doctable", "qualname": "DocTable.select_df", "kind": "function", "doc": "<p>Depricated. See docs for .q.select_df(), Query.select_df().</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.select_first", "modulename": "doctable.doctable", "qualname": "DocTable.select_first", "kind": "function", "doc": "<p>Depricated. See docs for .q.select_first(), Query.select_first().</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">as_dataclass</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.select", "modulename": "doctable.doctable", "qualname": "DocTable.select", "kind": "function", "doc": "<p>Depricated. See docs for .q.select(), Query.select().</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">as_dataclass</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.join", "modulename": "doctable.doctable", "qualname": "DocTable.join", "kind": "function", "doc": "<p>Wrapper over table.join(), can pass to from_obj parameter for .select()</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>other (DocTable):</strong>  other doctable to join</li>\n<li><strong><em>args, *</em>kwargs:</strong>  passed to table.join() method</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">DocTable</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.select_chunks", "modulename": "doctable.doctable", "qualname": "DocTable.select_chunks", "kind": "function", "doc": "<p>Depricated: see docs for .q.select_chunks()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.select_iter", "modulename": "doctable.doctable", "qualname": "DocTable.select_iter", "kind": "function", "doc": "<p>Depricated. See docs for .q.select_iter.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.get_queueinserter", "modulename": "doctable.doctable", "qualname": "DocTable.get_queueinserter", "kind": "function", "doc": "<p>Get an object that will queue rows for insertion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.update", "modulename": "doctable.doctable", "qualname": "DocTable.update", "kind": "function", "doc": "<p>Depricated. See docs for .q.update(), Query.update().</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.delete", "modulename": "doctable.doctable", "qualname": "DocTable.delete", "kind": "function", "doc": "<p>Depricated. See docs for .q.delete(), Query.delete().</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">delete_all</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.bootstrap", "modulename": "doctable.doctable", "qualname": "DocTable.bootstrap", "kind": "function", "doc": "<p>Generates a DocBootstrapper object to sample from.</p>\n\n<h6 id=\"notes\">Notes:</h6>\n\n<blockquote>\n  <p>The DocBootstrap object keeps all selected docs in\n      memory, and yields samples with .sample().</p>\n</blockquote>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>*args:</strong>  passed to .select()</li>\n<li><strong>n (int):</strong>  number of samples to bs. If left unset, can\nspecify when drawing sample from DocBootstrap obj.</li>\n<li><strong>**kwargs:</strong>  passed to .select()</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>DocBootstrap object for bootstrapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.clean_col_files", "modulename": "doctable.doctable", "qualname": "DocTable.clean_col_files", "kind": "function", "doc": "<p>Make sure there is a 1-1 mapping between files listed in db and files in folder.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>col (str or Column object):</strong>  column to clean picklefiles for.</li>\n<li><strong>ignore_missing (bool):</strong>  if False, throw an error when a db file doesn't exist.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">col</span>, </span><span class=\"param\"><span class=\"n\">check_missing</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">delete_extraneous</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.doctablemongo", "modulename": "doctable.doctablemongo", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.doctablemongo.DocTableMongo", "modulename": "doctable.doctablemongo", "qualname": "DocTableMongo", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.doctablemongo.DocTableMongo.__init__", "modulename": "doctable.doctablemongo", "qualname": "DocTableMongo.__init__", "kind": "function", "doc": "<p>Interface for single MongoDB collection.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">db</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">collection</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">port</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">27017</span></span>)</span>"}, {"fullname": "doctable.doctablemongo.DocTableMongo.client", "modulename": "doctable.doctablemongo", "qualname": "DocTableMongo.client", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.doctablemongo.DocTableMongo.insert", "modulename": "doctable.doctablemongo", "qualname": "DocTableMongo.insert", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.errors", "modulename": "doctable.errors", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.errors.ColumnNotFoundError", "modulename": "doctable.errors", "qualname": "ColumnNotFoundError", "kind": "class", "doc": "<p>Common base class for all exceptions</p>\n", "bases": "builtins.BaseException"}, {"fullname": "doctable.exceptions", "modulename": "doctable.exceptions", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.exceptions.base", "modulename": "doctable.exceptions.base", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.exceptions.base.BaseException", "modulename": "doctable.exceptions.base", "qualname": "BaseException", "kind": "class", "doc": "<p>Exception template for doctable.</p>\n", "bases": "builtins.Exception"}, {"fullname": "doctable.exceptions.base.BaseException.__init__", "modulename": "doctable.exceptions.base", "qualname": "BaseException.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "doctable.exceptions.base.BaseException.message", "modulename": "doctable.exceptions.base", "qualname": "BaseException.message", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "doctable.exceptions.distributeexceptions", "modulename": "doctable.exceptions.distributeexceptions", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy", "modulename": "doctable.legacy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.docparser", "modulename": "doctable.legacy.docparser", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.docparser.DocParser", "modulename": "doctable.legacy.docparser", "qualname": "DocParser", "kind": "class", "doc": "<p>Class that maintains convenient functions for parsing Spacy doc objects.</p>\n"}, {"fullname": "doctable.legacy.docparser.DocParser.re_url", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.re_url", "kind": "variable", "doc": "<p></p>\n", "default_value": "re.compile(&#x27;http\\\\S+&#x27;, re.MULTILINE)"}, {"fullname": "doctable.legacy.docparser.DocParser.re_xml_tag", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.re_xml_tag", "kind": "variable", "doc": "<p></p>\n", "default_value": "re.compile(&#x27;&lt;[^&lt;]+&gt;&#x27;, re.MULTILINE)"}, {"fullname": "doctable.legacy.docparser.DocParser.re_digits", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.re_digits", "kind": "variable", "doc": "<p></p>\n", "default_value": "re.compile(&#x27;\\\\d*[-\\\\./,]*\\\\d+&#x27;)"}, {"fullname": "doctable.legacy.docparser.DocParser.preprocess", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.preprocess", "kind": "function", "doc": "<p>Apply preprocessing step, modifies and returns text.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  document as a text string</li>\n<li><strong>replace_url (str or None):</strong>  if not None, replace url with string</li>\n<li><strong>replace_xml (str or None):</strong>  if not None, replace xml tags with string</li>\n<li><strong>replace_digits (str or None):</strong>  if not None, replace digits with string</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">text</span>, </span><span class=\"param\"><span class=\"n\">replace_url</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">replace_xml</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">replace_digits</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.get_parsetrees", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.get_parsetrees", "kind": "function", "doc": "<p>Extracts parsetree from spacy doc objects.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>doc (spacy.Doc object):</strong>  doc to generate parsetree from.</li>\n<li><strong>parse_tok_func (func):</strong>  function used to convert token to \na string representation. Usually a lambda function \nwrapping some variant of self.parse_tok().</li>\n<li><strong>userdata_map (dict<str->func>):</strong>  attribute to function \nmapping. Functions take a token and output a property\nthat will be stored in each parsetree node.</li>\n<li><strong>merge_ents (bool):</strong>  merge multi-word entities.</li>\n<li><strong>spacy_ngram_matcher (Spacy Matcher):</strong>  used to create ngrams\nwith Spacy. Powerful wildcards etc.</li>\n<li><strong>merge_noun_chunks (bool):</strong>  merge noun chunks or not.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">doc</span>,</span><span class=\"param\">\t<span class=\"n\">parse_tok_func</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">userdata_map</span><span class=\"o\">=</span><span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">merge_ents</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">spacy_ngram_matcher</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">merge_noun_chunks</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.tokenize_doc", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.tokenize_doc", "kind": "function", "doc": "<p>Parse spacy doc object.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>split_sents (bool):</strong>  parse into list of sentence tokens using doc.sents.</li>\n<li><strong>merge_ents (bool):</strong>  merge multi_word entities into same token.</li>\n<li><strong>ngrams (iter<iter<str>&gt;):</strong>  iterable of token tuples to merge after parsing.</li>\n<li><strong>spacy_ngram_matcher (spacy Matcher):</strong>  matcher object to use on the spacy doc.\nNormally will create using spacy.Matcher(nlp.vocab), see more details\nat <a href=\"https://spacy.io/usage/rule-based-matching\">https://spacy.io/usage/rule-based-matching</a> And also note that the \nnlp object must be the one used for parsing.</li>\n<li><strong>use_tok_func (func):</strong>  func used to decide to keep func or not. Default is\ncls.use_tok().</li>\n<li><strong>parse_tok_func (func):</strong>  func used to parse tokens. By default uses \ncls.parse_tok().</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">doc</span>,</span><span class=\"param\">\t<span class=\"n\">split_sents</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">merge_ents</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">merge_noun_chunks</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ngrams</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">spacy_ngram_matcher</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ngram_sep</span><span class=\"o\">=</span><span class=\"s1\">&#39; &#39;</span>,</span><span class=\"param\">\t<span class=\"n\">use_tok_func</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">parse_tok_func</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.parse_tok", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.parse_tok", "kind": "function", "doc": "<p>Convert spacy token object to string.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tok (spacy token or span):</strong>  token object to convert to string.</li>\n<li><strong>replace_num (str/None):</strong>  Replace number following tok.like_num (includes \"five\", \nor 5) with a special token (i.e. __NUM__). None means no replacement.</li>\n<li><strong>replace_digit (str/None):</strong>  Replace digit meeting tok.is_digit with special token. \nOnly used when replace_num is None.</li>\n<li><strong>lemmatize (bool):</strong>  return lemma instead of full word.</li>\n<li><strong>normal_convert (func):</strong>  custom conversion function to happen as last step\nfor non-entities. This way can keep all other functionality.</li>\n<li><strong>format_ents (bool):</strong>  Replace whitespace with space and capitalize first \nletter of ents.</li>\n<li><strong>ent_convert (func):</strong>  custom conversion function to happen as last step\nfor entities. This way can keep all other functionality.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tok</span>,</span><span class=\"param\">\t<span class=\"n\">num_replacement</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">digit_replacement</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lemmatize</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">normal_convert</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">format_ents</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ent_convert</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.use_tok", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.use_tok", "kind": "function", "doc": "<p>Decide to use token or not (can be overridden).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>no_whitespace (bool):</strong>  exclude whitespace.</li>\n<li><strong>no_punct (bool):</strong>  exclude punctuation.</li>\n<li><strong>no_num (bool):</strong>  exclude numbers using tok.is_num.</li>\n<li><strong>no_digit (bool):</strong>  exclude digits using tok.is_digit.</li>\n<li><strong>no_stop (bool):</strong>  exclude stopwords.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tok</span>,</span><span class=\"param\">\t<span class=\"n\">filter_whitespace</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">filter_punct</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">filter_stop</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">filter_digit</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">filter_num</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">filter_all_ents</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">filter_ent_types</span><span class=\"o\">=</span><span class=\"p\">()</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.apply_doc_transform", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.apply_doc_transform", "kind": "function", "doc": "<p>Apply merges to doc object including entities, normal ngrams, and noun chunks.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">doc</span>,</span><span class=\"param\">\t<span class=\"n\">merge_ents</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">spacy_ngram_matcher</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">merge_noun_chunks</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.merge_ngrams", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.merge_ngrams", "kind": "function", "doc": "<p>Merges manually specified consecutive tokens into single tokens.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">toks</span>, </span><span class=\"param\"><span class=\"n\">ngrams</span>, </span><span class=\"param\"><span class=\"n\">ngram_sep</span><span class=\"o\">=</span><span class=\"s1\">&#39; &#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.parse_text_chunks", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.parse_text_chunks", "kind": "function", "doc": "<p>Parse text in paragraph by sentences.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  (preprocessed) text document to parse</li>\n<li><strong>nlp (spaCy parser):</strong>  with .pipe() method to parse documents</li>\n<li><strong>parse_funcs (list<func>):</strong>  convert doc to </li>\n<li><strong>chunk_sents (int):</strong>  number of sentences used in each chunk to \nbe parsed. Max size for single spacy doc is 1 million \nchars. If av num chars per sent is 75-100, a size of\n3000 means each chunk will have approx 300k characters.\nHopefully, on average small enough. Larger value means\nmore memory but faster processing.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">text</span>,</span><span class=\"param\">\t<span class=\"n\">nlp</span>,</span><span class=\"param\">\t<span class=\"n\">parse_funcs</span><span class=\"o\">=</span><span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">doc_transform</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">chunk_sents</span><span class=\"o\">=</span><span class=\"mi\">1000</span>,</span><span class=\"param\">\t<span class=\"n\">split_re</span><span class=\"o\">=</span><span class=\"s1\">&#39;([</span><span class=\"se\">\\\\</span><span class=\"s1\">?</span><span class=\"se\">\\\\</span><span class=\"s1\">!</span><span class=\"se\">\\\\</span><span class=\"s1\">.]+)(?=[</span><span class=\"se\">\\\\</span><span class=\"s1\">WA-Z])&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.distribute_parse", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.distribute_parse", "kind": "function", "doc": "<p>Distributes text parsing across multiple processes in chunks.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>texts (list):</strong>  list of raw texts to process</li>\n<li><strong>spacynlp (spacy nlp object):</strong>  for applying .pipe() to doc chunks</li>\n<li><strong>parsefunc (func):</strong>  convert spacy doc object to storage represenation\nBy defaut uses DocParser.tokenize_doc().</li>\n<li><strong>preprocessfunc (func):</strong>  process text before parsing. Uses \nDocParser.preprocess() by default.</li>\n<li><strong>dt_inst (doctable instance):</strong>  if included, will pass to parsefunc as\nsecond argument. Usually to do this, you'll create a function\nwhich calls some overloaded version of .tokenize_doc() and then\ncalls dt_inst.insert() to place in database.</li>\n<li><strong>paragraph_sep (str or None):</strong>  if defined, will distribute parsing across\nparagraphs and leave paragraph structure of docs in nested lists.</li>\n<li><strong>workers (int):</strong>  number of processes to create.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>output of parsing</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">texts</span>,</span><span class=\"param\">\t<span class=\"n\">spacynlp</span>,</span><span class=\"param\">\t<span class=\"n\">parsefunc</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">preprocessfunc</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dt_inst</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">paragraph_sep</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">workers</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.spacy_parse_chunks", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.spacy_parse_chunks", "kind": "function", "doc": "<p>Parses document in sentence chunks to reduce memory use.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span>, </span><span class=\"param\"><span class=\"n\">nlp</span>, </span><span class=\"param\"><span class=\"n\">parsefuncs</span><span class=\"o\">=</span><span class=\"p\">[]</span>, </span><span class=\"param\"><span class=\"n\">chunk_size</span><span class=\"o\">=</span><span class=\"mi\">10</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy", "modulename": "doctable.legacy.doctablelegacy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy", "kind": "class", "doc": "<p>This is a base class for working with text documents. \nIt is to be inhereted by a class actually defining the table schema for documents.</p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.__init__", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.__init__", "kind": "function", "doc": "<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fname (str):</strong>  filename of database</li>\n<li><strong>tabname (str):</strong>  name of sqlite table to manipulate.</li>\n<li><strong>colschema (tuple of 2-tuples):</strong>  list of colname, coltype columns</li>\n<li><strong>constraints (tuple of str):</strong>  constraints to put on columns</li>\n<li><strong>verbose (bool):</strong>  print querys before executing</li>\n<li><strong>persistent_conn (bool):</strong>  keep a persistent sqlite3 connection to \nthe db.</li>\n<li><strong>new_db (bool):</strong>  create a new database file if one does not already \nexist. Prevents creation of new db if filename is mis-specified.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">colschema</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fname</span><span class=\"o\">=</span><span class=\"s1\">&#39;doctable.db&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">tabname</span><span class=\"o\">=</span><span class=\"s1\">&#39;documents&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">constraints</span><span class=\"o\">=</span><span class=\"p\">()</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">persistent_conn</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">make_new_db</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">check_schema</span><span class=\"o\">=</span><span class=\"kc\">True</span></span>)</span>"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.fname", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.fname", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.tabname", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.tabname", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.colschema", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.colschema", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.constraints", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.constraints", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.verbose", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.verbose", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.conn", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.conn", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.schema", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.schema", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.columns", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.columns", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.isblob", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.isblob", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.commit", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.commit", "kind": "function", "doc": "<p>Commits database changes to file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.query", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.query", "kind": "function", "doc": "<p>Executes raw query using database connection.</p>\n\n<p>Output: sqlite query conn.execute() output.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">qstr</span>, </span><span class=\"param\"><span class=\"n\">payload</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">many</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.add", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.add", "kind": "function", "doc": "<p>Adds a single entry where each column is identified by a key-value pair. \n    Will automatically convert python types to sqlite storage blobs using pickle.</p>\n\n<h6 id=\"inputs\">Inputs:</h6>\n\n<blockquote>\n  <p>datadict: dictionary of column name -> value mappings\n  ifnotunique: choose what happens when an existing entry matches\n      any UNIQUE criteria specified in the schema.\n      Choose from ('REPLACE', 'IGNORE').</p>\n</blockquote>\n\n<h6 id=\"output\">Output:</h6>\n\n<blockquote>\n  <p>query response</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">datadict</span>, </span><span class=\"param\"><span class=\"n\">ifnotunique</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">queryargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.addmany", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.addmany", "kind": "function", "doc": "<p>Adds multiple entries to the database, where column names are specified by \"keys\".\n    If \"keys\" is not specified, will use all columns (including autoincrement columns).\n    Will automatically convert python types to sqlite storage blobs using pickle.</p>\n\n<h6 id=\"inputs\">Inputs:</h6>\n\n<blockquote>\n  <p>data: lists of tuples representing data for each row\n  keys: column names corresponding to each tuple entry\n  ifnotunique: choose what happens when an existing entry matches\n      any UNIQUE criteria specified in the schema.\n      Choose from ('REPLACE', 'IGNORE').</p>\n</blockquote>\n\n<h6 id=\"output\">Output:</h6>\n\n<blockquote>\n  <p>sqlite executemany query response</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">keys</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ifnotunique</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">queryargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.delete", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.delete", "kind": "function", "doc": "<p>Deletes all rows matching the where criteria.</p>\n\n<h6 id=\"inputs\">Inputs:</h6>\n\n<blockquote>\n  <p>where: if \"*\" is specified, will drop all rows. Otherwise\n      is fed directly into the query statement.</p>\n</blockquote>\n\n<h6 id=\"output\">Output:</h6>\n\n<blockquote>\n  <p>query response</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">where</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">queryargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.update", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.update", "kind": "function", "doc": "<p>Updates rows matching the \"where\" string with specified values.</p>\n\n<h6 id=\"inputs\">Inputs:</h6>\n\n<blockquote>\n  <p>values: dictionary of field->values. all rows which meet the where criteria \n      will have these values assigned\n  where: literal SQLite \"where\" string corresponding to column criteria for \n      value replacement.\n      The value \"*\" will match all rows by omitting WHERE statement.</p>\n</blockquote>\n\n<h6 id=\"output\">Output:</h6>\n\n<blockquote>\n  <p>query response</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">values</span>, </span><span class=\"param\"><span class=\"n\">where</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">queryargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.get", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.get", "kind": "function", "doc": "<p>Query rows from database as generator.</p>\n\n<h6 id=\"inputs\">Inputs:</h6>\n\n<blockquote>\n  <p>sel: list of fields to retrieve with the query\n  where: literal SQLite \"where\" string corresponding to criteria for \n      value replacement.\n  orderby: literal sqlite order by command value. Can be \"column_1 ASC\",\n      or order by multiple columns using, for instance, \"column_1 ASC, column_2 DESC\"\n  limit: number of rows to retrieve before stopping query. Can be used for quick testing.\n  table: table name to retrieve for. Default is object table name, but can query from \n      others here.\n  verbose: True/False flag indicating whether or not output should appear.\n  asdict: True/False flag indicating whether rows should be returned as \n      lists (False) or as dicts with field names (True &amp; default).\n  kwargs: to be sent to self.query().</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">sel</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">orderby</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">limit</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">table</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">asdict</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">queryargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.getdf", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.getdf", "kind": "function", "doc": "<p>Query rows from database, return as Pandas DataFrame.</p>\n\n<h6 id=\"inputs\">Inputs:</h6>\n\n<blockquote>\n  <p>See inputs for self.get().</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.models", "modulename": "doctable.models", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.models.bootstrap", "modulename": "doctable.models.bootstrap", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.models.bootstrap.DocBootstrap", "modulename": "doctable.models.bootstrap", "qualname": "DocBootstrap", "kind": "class", "doc": "<p>Class to handle bootstrapping of documents.</p>\n"}, {"fullname": "doctable.models.bootstrap.DocBootstrap.__init__", "modulename": "doctable.models.bootstrap", "qualname": "DocBootstrap.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">docs</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "doctable.models.bootstrap.DocBootstrap.docs", "modulename": "doctable.models.bootstrap", "qualname": "DocBootstrap.docs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.models.bootstrap.DocBootstrap.n", "modulename": "doctable.models.bootstrap", "qualname": "DocBootstrap.n", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.models.bootstrap.DocBootstrap.ids", "modulename": "doctable.models.bootstrap", "qualname": "DocBootstrap.ids", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.models.bootstrap.DocBootstrap.set_new_sample", "modulename": "doctable.models.bootstrap", "qualname": "DocBootstrap.set_new_sample", "kind": "function", "doc": "<p>Set internal sample state.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n (int):</strong>  new number of samples to draw</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.models.bootstrap.DocBootstrap.new_sample", "modulename": "doctable.models.bootstrap", "qualname": "DocBootstrap.new_sample", "kind": "function", "doc": "<p>Save and return new sample.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n (int):</strong>  number of new samples to draw. If None, will draw \npreviously set number.</li>\n<li><strong>with_ids (bool):</strong>  return (id,doc) tuples or just docs.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">with_ids</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.models.gmm", "modulename": "doctable.models.gmm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.models.gmm.GMM", "modulename": "doctable.models.gmm", "qualname": "GMM", "kind": "class", "doc": "<p>Gaussian mixture model.</p>\n", "bases": "builtins.list"}, {"fullname": "doctable.models.gmm.GMM.set_new_sample", "modulename": "doctable.models.gmm", "qualname": "GMM.set_new_sample", "kind": "function", "doc": "<p>Set a random sample of every centroid in the mixture.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.models.gmm.GMM.get_sample", "modulename": "doctable.models.gmm", "qualname": "GMM.get_sample", "kind": "function", "doc": "<p>Create random samples from centroids.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.models.gmm.Centroid", "modulename": "doctable.models.gmm", "qualname": "Centroid", "kind": "class", "doc": "<p>Represents a gaussian distribution and stores random samples.</p>\n"}, {"fullname": "doctable.models.gmm.Centroid.__init__", "modulename": "doctable.models.gmm", "qualname": "Centroid.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">300</span>,</span><span class=\"param\">\t<span class=\"n\">norm</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">nsamp</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">normed</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">meanvec</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">samp</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "doctable.models.gmm.Centroid.size", "modulename": "doctable.models.gmm", "qualname": "Centroid.size", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "300"}, {"fullname": "doctable.models.gmm.Centroid.norm", "modulename": "doctable.models.gmm", "qualname": "Centroid.norm", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "doctable.models.gmm.Centroid.var", "modulename": "doctable.models.gmm", "qualname": "Centroid.var", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.01"}, {"fullname": "doctable.models.gmm.Centroid.nsamp", "modulename": "doctable.models.gmm", "qualname": "Centroid.nsamp", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "100"}, {"fullname": "doctable.models.gmm.Centroid.normed", "modulename": "doctable.models.gmm", "qualname": "Centroid.normed", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "doctable.models.gmm.Centroid.meanvec", "modulename": "doctable.models.gmm", "qualname": "Centroid.meanvec", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray", "default_value": "None"}, {"fullname": "doctable.models.gmm.Centroid.samp", "modulename": "doctable.models.gmm", "qualname": "Centroid.samp", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray", "default_value": "None"}, {"fullname": "doctable.models.gmm.Centroid.make_random_mean", "modulename": "doctable.models.gmm", "qualname": "Centroid.make_random_mean", "kind": "function", "doc": "<p>Return random mean vector for this centroid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.models.gmm.Centroid.draw_sample", "modulename": "doctable.models.gmm", "qualname": "Centroid.draw_sample", "kind": "function", "doc": "<p>Return random samples from this centroid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.models.gmm.Centroid.set_new_sample", "modulename": "doctable.models.gmm", "qualname": "Centroid.set_new_sample", "kind": "function", "doc": "<p>Draw sample and assign it to this centroid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.models.gmm.Centroid.av_sim", "modulename": "doctable.models.gmm", "qualname": "Centroid.av_sim", "kind": "function", "doc": "<p>Average similarity between points.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse", "modulename": "doctable.parse", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.parse.parsefuncs", "modulename": "doctable.parse.parsefuncs", "kind": "module", "doc": "<p>These functions are used as wrappers around SpaCy parsers, and can be used\neither standalone or as part of a doctable.ParsePipeline.</p>\n\n<p>The two primary parse functions here are <code>tokenize</code> and <code>get_parsetrees</code>.\nUse <code>tokenize</code> when you want to extract lists of tokens (split by sentence\nor not) and <code>get_parsetrees</code> when you'd like to extract condensed versions\nof SpaCy parsetrees.</p>\n\n<p>The <code>tokenize</code> function accepts two parameters, <code>keep_tok_func</code> and \n<code>parse_tok_func</code>, which can be custom or optionally filled by \n<code>keep_tok</code> and <code>parse_tok</code>. These methods are also registered as \ncomponents in <code>doctable.ParsePipeline</code>, so can be accessed using \n<code>doctable.Comp()</code> as shown below.</p>\n\n<pre><code># add pipeline components\nparser = doctable.ParsePipeline([\n    spacy.load('en'), # first run spacy parser\n    doctable.Comp('tokenize', **{\n        'split_sents': False,\n        'keep_tok_func': doctable.Comp('keep_tok'),\n        'parse_tok_func': doctable.Comp('parse_tok'),\n    })\n])\n</code></pre>\n\n<p>A more complete <code>ParsePipeline</code> example might look like the code below.\nThis example uses the <code>merge_tok_spans</code> function to merge named entities as\nsingle tokens in SpaCy then uses the <code>tokenize</code> function in conjunction \nwith <code>keep_tok</code> (which drops whitespace tokens but keeps punctuation and \nstopwords) and <code>parse_tok</code> (which capitalizes named entities, replaces \nnumbers with \"NUM\", and does not lemmatize tokens).</p>\n\n<pre><code>parser = doctable.ParsePipeline([\n    spacy.load('en'), # spacy nlp parser object\n\n    # merge spacy multi-word named entities (doctable.parse.merge_tok_spans)\n    Comp('merge_tok_spans', merge_ents=True, merge_noun_chunks=False),\n\n    # tokenize document\n    Comp('tokenize', **{\n        'split_sents': False,\n\n        # choose tokens to keep (doctable.parse.keep_tok)\n        'keep_tok_func': Comp('keep_tok', **{\n            'keep_whitespace': False, # don't keep whitespace\n            'keep_punct': True, # keep punctuation and stopwords\n            'keep_stop': True,\n        }),\n\n        # choose how to convert Spacy token t text (doctable.parse.parse_tok)\n        'parse_tok_func': Comp('parse_tok', **{\n            'format_ents': True,\n            'lemmatize': False,\n            'num_replacement': 'NUM',\n            'ent_convert': lambda e: e.text.upper(), # function to capitalize named entities\n        })\n    })\n])\n</code></pre>\n"}, {"fullname": "doctable.parse.parsefuncs.re_url", "modulename": "doctable.parse.parsefuncs", "qualname": "re_url", "kind": "variable", "doc": "<p></p>\n", "default_value": "re.compile(&#x27;http\\\\S+&#x27;, re.MULTILINE)"}, {"fullname": "doctable.parse.parsefuncs.re_xml_tag", "modulename": "doctable.parse.parsefuncs", "qualname": "re_xml_tag", "kind": "variable", "doc": "<p></p>\n", "default_value": "re.compile(&#x27;&lt;[^&lt;]+&gt;&#x27;, re.MULTILINE)"}, {"fullname": "doctable.parse.parsefuncs.re_digits", "modulename": "doctable.parse.parsefuncs", "qualname": "re_digits", "kind": "variable", "doc": "<p></p>\n", "default_value": "re.compile(&#x27;\\\\d*[-\\\\./,]*\\\\d+&#x27;)"}, {"fullname": "doctable.parse.parsefuncs.preprocess", "modulename": "doctable.parse.parsefuncs", "qualname": "preprocess", "kind": "function", "doc": "<p>A few useful preprocessing functions for raw text.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  document as a text string</li>\n<li><strong>replace_url (str or None):</strong>  if not None, replace url with string</li>\n<li><strong>replace_xml (str or None):</strong>  if not None, replace xml tags with string</li>\n<li><strong>replace_digits (str or None):</strong>  if not None, replace digits with string</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span>, </span><span class=\"param\"><span class=\"n\">replace_url</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">replace_xml</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">replace_digits</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.identity", "modulename": "doctable.parse.parsefuncs", "qualname": "identity", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.tokenize", "modulename": "doctable.parse.parsefuncs", "qualname": "tokenize", "kind": "function", "doc": "<p>Convert spacy doc into a series of tokens (as sentences or not).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>split_sents (bool):</strong>  parse into list of sentence tokens using doc.sents.</li>\n<li><strong>merge_ents (bool):</strong>  merge multi_word entities into same token.</li>\n<li><strong>ngrams (iter<iter<str>&gt;):</strong>  iterable of token tuples to merge after parsing.</li>\n<li><strong>spacy_ngram_matcher (spacy Matcher):</strong>  matcher object to use on the spacy doc.\nNormally will create using spacy.Matcher(nlp.vocab), see more details\nat <a href=\"https://spacy.io/usage/rule-based-matching\">https://spacy.io/usage/rule-based-matching</a> And also note that the \nnlp object must be the one used for parsing.</li>\n<li><strong>keep_tok_func (func):</strong>  func used to decide to keep func or not. Default is\nidentity function</li>\n<li><strong>parse_tok_func (func):</strong>  func used to parse tokens. By default uses \nidentify function.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">doc</span>, </span><span class=\"param\"><span class=\"n\">split_sents</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">keep_tok_func</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">parse_tok_func</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.parse_tok", "modulename": "doctable.parse.parsefuncs", "qualname": "parse_tok", "kind": "function", "doc": "<p>Convert spacy token object to string.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tok (spacy token or span):</strong>  token object to convert to string.</li>\n<li><strong>replace_num (str/None):</strong>  Replace number following tok.like_num (includes \"five\", \nor 5) with a special token (i.e. __NUM__). None means no replacement.</li>\n<li><strong>replace_digit (str/None):</strong>  Replace digit meeting tok.is_digit with special token. \nOnly used when replace_num is None.</li>\n<li><strong>lemmatize (bool):</strong>  return lemma instead of full word.</li>\n<li><strong>normal_convert (func):</strong>  custom conversion function to happen as last step\nfor non-entities. This way can keep all other functionality.</li>\n<li><strong>format_ents (bool):</strong>  Replace whitespace with space and capitalize first \nletter of ents.</li>\n<li><strong>ent_convert (func):</strong>  custom conversion function to happen as last step\nfor entities. This way can keep all other functionality.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tok</span>,</span><span class=\"param\">\t<span class=\"n\">num_replacement</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">digit_replacement</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lemmatize</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">normal_tok_parse</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">format_ents</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ent_convert</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.keep_tok", "modulename": "doctable.parse.parsefuncs", "qualname": "keep_tok", "kind": "function", "doc": "<p>Decide to use token or not (can be overridden).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>keep_whitespace (bool):</strong>  keep all-whitespace tokens.</li>\n<li><strong>keep_punct (bool):</strong>  keep punctuation.</li>\n<li><strong>keep_stop (bool):</strong>  keep stopwords.</li>\n<li><strong>keep_num (bool):</strong>  keep numbers using tok.is_num.</li>\n<li><strong>keep_digit (bool):</strong>  keep digits using tok.is_digit.</li>\n<li><strong>keep_ents (bool):</strong>  keep named entities</li>\n<li><strong>keep_ent_types (list<str>):</strong>  keep only these entity types</li>\n<li><strong>rm_ent_types (list<str>):</strong>  remove these entity types</li>\n<li><strong>keep_pos (list<str>):</strong>  keep only toks with these POS</li>\n<li><strong>rm_pos (list<str>):</strong>  remove toks with these POS</li>\n<li><strong>addtnl_func (func):</strong>  additional custom criteria to meet</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>True if token should be kept.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tok</span>,</span><span class=\"param\">\t<span class=\"n\">keep_whitespace</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">keep_punct</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">keep_stop</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">keep_digit</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">keep_num</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">keep_ents</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">keep_ent_types</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">rm_ent_types</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">keep_pos</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">rm_pos</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">addtnl_func</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.merge_tok_spans", "modulename": "doctable.parse.parsefuncs", "qualname": "merge_tok_spans", "kind": "function", "doc": "<p>Apply merges to doc object including entities, normal ngrams, and noun chunks.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>doc (Spacy Doc object):</strong>  doc to merge spans in</li>\n<li><strong>merge_ents (bool):</strong>  combine multi-word entities using spacy doc.retokenize()</li>\n<li><strong>spacy_ngram_matcher (spacy Matcher object):</strong>  rule-based matching object for \nngrams in Spacy. See <a href=\"https://spacy.io/usage/rule-based-matching\">https://spacy.io/usage/rule-based-matching</a></li>\n<li><strong>merge_noun_chunks (bool):</strong>  automatically merge noun chunks</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">doc</span>,</span><span class=\"param\">\t<span class=\"n\">merge_ents</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">spacy_ngram_matcher</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">merge_noun_chunks</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.merge_tok_ngrams", "modulename": "doctable.parse.parsefuncs", "qualname": "merge_tok_ngrams", "kind": "function", "doc": "<p>Merges manually specified consecutive tokens into single tokens.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>toks (list<str>):</strong>  token list through which to search for ngrams.</li>\n<li><strong>ngrams (list<list<str>&gt;):</strong>  list of ngrams (as sequence of str) to \ncombine into single tokens.</li>\n<li><strong>ngram_sep (str):</strong>  string to join ngram parts with.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">toks</span>, </span><span class=\"param\"><span class=\"n\">ngrams</span><span class=\"o\">=</span><span class=\"p\">()</span>, </span><span class=\"param\"><span class=\"n\">ngram_sep</span><span class=\"o\">=</span><span class=\"s1\">&#39;_&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.get_parsetrees", "modulename": "doctable.parse.parsefuncs", "qualname": "get_parsetrees", "kind": "function", "doc": "<p>Extracts parsetree from spacy doc objects.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>doc (spacy.Doc object):</strong>  doc to generate parsetree from.</li>\n<li><strong>parse_tok_func (func<spacy.Token, str>):</strong>  function used to convert token to \na string representation. Usually a lambda function \nwrapping some variant of self.parse_tok().</li>\n<li><strong>userdata_map (dict<str->func>):</strong>  attribute to function \nmapping. Functions take a token and output a property\nthat will be stored in each parsetree node.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">doc</span>, </span><span class=\"param\"><span class=\"n\">text_parse_func</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"o\">&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>, </span><span class=\"param\"><span class=\"n\">userdata_map</span><span class=\"o\">=</span><span class=\"p\">{}</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.parseprocess", "modulename": "doctable.parse.parseprocess", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.parse.parseprocess.ParseProcess", "modulename": "doctable.parse.parseprocess", "qualname": "ParseProcess", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.parse.parseprocess.ParseProcess.__init__", "modulename": "doctable.parse.parseprocess", "qualname": "ParseProcess.__init__", "kind": "function", "doc": "<p>Store info to construct the table.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parse_func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>, </span><span class=\"param\"><span class=\"n\">table_cls</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">table_args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">table_kwargs</span></span>)</span>"}, {"fullname": "doctable.parse.parseprocess.ParseProcess.table", "modulename": "doctable.parse.parseprocess", "qualname": "ParseProcess.table", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.doctable.DocTable", "default_value": "None"}, {"fullname": "doctable.parse.parseprocess.ParseProcess.parse_func", "modulename": "doctable.parse.parseprocess", "qualname": "ParseProcess.parse_func", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parse.parseprocess.ParseProcess.table_cls", "modulename": "doctable.parse.parseprocess", "qualname": "ParseProcess.table_cls", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parse.parseprocess.ParseProcess.table_args", "modulename": "doctable.parse.parseprocess", "qualname": "ParseProcess.table_args", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parse.parseprocess.ParseProcess.table_kwargs", "modulename": "doctable.parse.parseprocess", "qualname": "ParseProcess.table_kwargs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parse.parseprocess.ParseProcess.connect_db", "modulename": "doctable.parse.parseprocess", "qualname": "ParseProcess.connect_db", "kind": "function", "doc": "<p>Make a new connection to the database and return the associated table.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.pipeline", "modulename": "doctable.parse.pipeline", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.parse.pipeline.components", "modulename": "doctable.parse.pipeline", "qualname": "components", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;preprocess&#x27;: &lt;function preprocess&gt;, &#x27;tokenize&#x27;: &lt;function tokenize&gt;, &#x27;parse_tok&#x27;: &lt;function parse_tok&gt;, &#x27;keep_tok&#x27;: &lt;function keep_tok&gt;, &#x27;merge_tok_spans&#x27;: &lt;function merge_tok_spans&gt;, &#x27;merge_tok_ngrams&#x27;: &lt;function merge_tok_ngrams&gt;, &#x27;get_parsetrees&#x27;: &lt;function get_parsetrees&gt;}"}, {"fullname": "doctable.parse.pipeline.Comp", "modulename": "doctable.parse.pipeline", "qualname": "Comp", "kind": "function", "doc": "<p>Returns a pipeline component as a function with one positional arg.\n    See components in this file to see available mappings.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>*args:</strong>  passed directly to component function</li>\n<li><strong>**kwargs:</strong>  passed directly to component function</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.pipeline.MultiComp", "modulename": "doctable.parse.pipeline", "qualname": "MultiComp", "kind": "function", "doc": "<p>Add a component that returns a dictionary, each with separate parsers.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>funcs (dict<str:</strong> func>): mapping from string to dictionary</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">funcs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.pipeline.funcwrap", "modulename": "doctable.parse.pipeline", "qualname": "funcwrap", "kind": "function", "doc": "<p>Used in MultiComp.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">funcs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.pipeline.ParsePipeline", "modulename": "doctable.parse.pipeline", "qualname": "ParsePipeline", "kind": "class", "doc": "<p>Class for creating pipelines for parsing text documents (or other elements).\nPrimarily</p>\n"}, {"fullname": "doctable.parse.pipeline.ParsePipeline.__init__", "modulename": "doctable.parse.pipeline", "qualname": "ParsePipeline.__init__", "kind": "function", "doc": "<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>components (list<func>):</strong>  list of components/functions to apply to the \ninput sequentially. See the component function in this script to \ngenerate components.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">components</span></span>)</span>"}, {"fullname": "doctable.parse.pipeline.ParsePipeline.components", "modulename": "doctable.parse.pipeline", "qualname": "ParsePipeline.components", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parse.pipeline.ParsePipeline.parse", "modulename": "doctable.parse.pipeline", "qualname": "ParsePipeline.parse", "kind": "function", "doc": "<p>Parses document by applying each component function to doctext in turn.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>doctext (str):</strong>  text to be parsed. This can actually be anything to put into\na pipeline.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>single parsed document object, output of last pipeline function</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">doctext</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.pipeline.ParsePipeline.parsemany", "modulename": "doctable.parse.pipeline", "qualname": "ParsePipeline.parsemany", "kind": "function", "doc": "<p>Parse multiple documents distributed across workers.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>doctexts (list<str>):</strong>  elements to be parsed</li>\n<li><strong>workers (int):</strong>  number of processes to use</li>\n<li><strong>override_maxcores (bool):</strong>  in cases where processes may have\nlow CPU utilization, you may want to create more processes\nthan your computer has cores.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list of parsed elements</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">doctexts</span>, </span><span class=\"param\"><span class=\"n\">workers</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">override_maxcores</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.parse.pipeline.ParsePipeline.parsemany_thread", "modulename": "doctable.parse.pipeline", "qualname": "ParsePipeline.parsemany_thread", "kind": "function", "doc": "<p>Helper for .parsemany().</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">doctexts</span>, </span><span class=\"param\"><span class=\"n\">parser</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.query", "modulename": "doctable.query", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.query.deletequery", "modulename": "doctable.query.deletequery", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.query.deletequery.DeleteQuery", "modulename": "doctable.query.deletequery", "qualname": "DeleteQuery", "kind": "class", "doc": "<p></p>\n", "bases": "doctable.query.querybase.QueryBase"}, {"fullname": "doctable.query.deletequery.DeleteQuery.dtab", "modulename": "doctable.query.deletequery", "qualname": "DeleteQuery.dtab", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.doctable.DocTable"}, {"fullname": "doctable.query.deletequery.DeleteQuery.delete", "modulename": "doctable.query.deletequery", "qualname": "DeleteQuery.delete", "kind": "function", "doc": "<p>Delete rows from the table that meet the where criteria.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>where (sqlalchemy condition):</strong>  criteria for deletion.</li>\n<li><strong>wherestr (sql string):</strong>  addtnl criteria for deletion.</li>\n<li><strong>vacuum (bool):</strong>  will execute vacuum sql command to reduce\nstorage space needed by SQL table. Use when deleting\nsignificant ammounts of data.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>SQLAlchemy result proxy object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">delete_all</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">vacuum</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">cursor</span><span class=\"o\">.</span><span class=\"n\">CursorResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.deletequery.DeleteQuery.delete_query", "modulename": "doctable.query.deletequery", "qualname": "DeleteQuery.delete_query", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dml</span><span class=\"o\">.</span><span class=\"n\">Delete</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.errors", "modulename": "doctable.query.errors", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.query.errors.NoDataToInsert", "modulename": "doctable.query.errors", "qualname": "NoDataToInsert", "kind": "class", "doc": "<p>Common base class for all exceptions</p>\n", "bases": "builtins.BaseException"}, {"fullname": "doctable.query.errors.SetToReadOnlyMode", "modulename": "doctable.query.errors", "qualname": "SetToReadOnlyMode", "kind": "class", "doc": "<p>Common base class for all exceptions</p>\n", "bases": "builtins.BaseException"}, {"fullname": "doctable.query.errors.ObjectIsNotSchemaClass", "modulename": "doctable.query.errors", "qualname": "ObjectIsNotSchemaClass", "kind": "class", "doc": "<p>Inappropriate argument type.</p>\n", "bases": "builtins.TypeError"}, {"fullname": "doctable.query.insertquery", "modulename": "doctable.query.insertquery", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.query.insertquery.InsertQuery", "modulename": "doctable.query.insertquery", "qualname": "InsertQuery", "kind": "class", "doc": "<p></p>\n", "bases": "doctable.query.querybase.QueryBase"}, {"fullname": "doctable.query.insertquery.InsertQuery.dtab", "modulename": "doctable.query.insertquery", "qualname": "InsertQuery.dtab", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.doctable.DocTable"}, {"fullname": "doctable.query.insertquery.InsertQuery.insert_multi", "modulename": "doctable.query.insertquery", "qualname": "InsertQuery.insert_multi", "kind": "function", "doc": "<p>Insert multiple rows as objects into the db.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">schema_objs</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">ifnotunique</span><span class=\"p\">:</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;FAIL&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;IGNORE&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;REPLACE&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;fail&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">cursor</span><span class=\"o\">.</span><span class=\"n\">CursorResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.insertquery.InsertQuery.insert_multi_raw", "modulename": "doctable.query.insertquery", "qualname": "InsertQuery.insert_multi_raw", "kind": "function", "doc": "<p>Insert multiple rows as dictionaries into the db.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">datum</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">ifnotunique</span><span class=\"p\">:</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;FAIL&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;IGNORE&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;REPLACE&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;fail&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">cursor</span><span class=\"o\">.</span><span class=\"n\">CursorResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.insertquery.InsertQuery.insert_single", "modulename": "doctable.query.insertquery", "qualname": "InsertQuery.insert_single", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span>,</span><span class=\"param\">\t<span class=\"n\">ifnotunique</span><span class=\"p\">:</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;FAIL&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;IGNORE&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;REPLACE&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;fail&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">cursor</span><span class=\"o\">.</span><span class=\"n\">CursorResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.insertquery.InsertQuery.insert_single_raw", "modulename": "doctable.query.insertquery", "qualname": "InsertQuery.insert_single_raw", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">ifnotunique</span><span class=\"p\">:</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;FAIL&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;IGNORE&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;REPLACE&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;fail&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">cursor</span><span class=\"o\">.</span><span class=\"n\">CursorResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.insertquery.InsertQuery.insert_query", "modulename": "doctable.query.insertquery", "qualname": "InsertQuery.insert_query", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ifnotunique</span><span class=\"p\">:</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;FAIL&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;IGNORE&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;REPLACE&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;fail&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dml</span><span class=\"o\">.</span><span class=\"n\">Insert</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.query", "modulename": "doctable.query.query", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.query.query.Query", "modulename": "doctable.query.query", "qualname": "Query", "kind": "class", "doc": "<p>Merges methods from all four query classes into a single interface.</p>\n", "bases": "doctable.query.selectquery.SelectQuery, doctable.query.insertquery.InsertQuery, doctable.query.updatequery.UpdateQuery, doctable.query.deletequery.DeleteQuery"}, {"fullname": "doctable.query.query.Query.__init__", "modulename": "doctable.query.query", "qualname": "Query.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dtab</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">DocTable</span></span>)</span>"}, {"fullname": "doctable.query.query.Query.dtab", "modulename": "doctable.query.query", "qualname": "Query.dtab", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.doctable.DocTable"}, {"fullname": "doctable.query.querybase", "modulename": "doctable.query.querybase", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.query.querybase.QueryBase", "modulename": "doctable.query.querybase", "qualname": "QueryBase", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.query.querybase.QueryBase.dtab", "modulename": "doctable.query.querybase", "qualname": "QueryBase.dtab", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.doctable.DocTable"}, {"fullname": "doctable.query.selectquery", "modulename": "doctable.query.selectquery", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.query.selectquery.SelectQuery", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery", "kind": "class", "doc": "<p></p>\n", "bases": "doctable.query.querybase.QueryBase"}, {"fullname": "doctable.query.selectquery.SelectQuery.dtab", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.dtab", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.doctable.DocTable"}, {"fullname": "doctable.query.selectquery.SelectQuery.select_iter", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.select_iter", "kind": "function", "doc": "<p>Same as .select except results retrieved from db in chunks.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cols (col name(s) or sqlalchemy object(s)):</strong>  columns to query</li>\n<li><strong>chunksize (int):</strong>  size of individual queries to be made. Will\nload this number of rows into memory before yielding.</li>\n<li><strong>limit (int):</strong>  maximum number of rows to retrieve. Because \nthe limit argument is being used internally to limit data\nto smaller chunks, use this argument instead. Internally,\nthis function will load a maximum of limit + chunksize \n<ul>\n<li>1 rows into memory, but yields only limit.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"yields\">Yields:</h6>\n\n<blockquote>\n  <p>sqlalchemy result: row data - same as .select() method.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">chunksize</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.select_chunks", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.select_chunks", "kind": "function", "doc": "<p>Performs select while querying only a subset of the results at a time.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cols (col name(s) or sqlalchemy object(s)):</strong>  columns to query</li>\n<li><strong>chunksize (int):</strong>  size of individual queries to be made. Will\nload this number of rows into memory before yielding.</li>\n<li><strong>limit (int):</strong>  maximum number of rows to retrieve. Because \nthe limit argument is being used internally to limit data\nto smaller chunks, use this argument instead. Internally,\nthis function will load a maximum of limit + chunksize \n<ul>\n<li>1 rows into memory, but yields only limit.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"yields\">Yields:</h6>\n\n<blockquote>\n  <p>result: chunked rows.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">chunksize</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">limit</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">raw_result</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.count", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.count", "kind": "function", "doc": "<p>Count the number of rows in a table.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.select_head", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.select_head", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.select_series", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.select_series", "kind": "function", "doc": "<p>Select returning pandas Series.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>col:</strong>  column to query. Passed directly to .select() \nmethod.</li>\n<li><strong>*args:</strong>  args to regular .select() method.</li>\n<li><strong>**kwargs:</strong>  args to regular .select() method.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>pandas series: enters rows as values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">col</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">orderby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">groupby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">limit</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.select_df", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.select_df", "kind": "function", "doc": "<p>Select returning dataframe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cols:</strong>  sequence of columns to query. Must be sequence,\npassed directly to .select() method.</li>\n<li><strong>*args:</strong>  args to regular .select() method.</li>\n<li><strong>**kwargs:</strong>  args to regular .select() method.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>pandas dataframe: Each row is a database row,\n      and output is not indexed according to primary \n      key or otherwise. Call .set_index('id') on the\n      dataframe to envoke this behavior.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">orderby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">groupby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">limit</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.select_scalar", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.select_scalar", "kind": "function", "doc": "<p>Select values of a single column.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">col</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">orderby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">groupby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.select_col", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.select_col", "kind": "function", "doc": "<p>Select values of a single column.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">col</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">orderby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">groupby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">limit</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.select_first", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.select_first", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">orderby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">groupby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">raw_result</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.select", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.select", "kind": "function", "doc": "<p>Select some basic shit.\nDescription: Because output must be iterable, returns special column results \n    by performing one query per row. Can be inefficient for many smaller \n    special data information.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cols:</strong>  list of sqlalchemy datatypes created from calling .col() method.</li>\n<li><strong>where (sqlachemy BinaryExpression):</strong>  sqlalchemy \"where\" object to parse</li>\n<li><strong>orderby:</strong>  sqlalchemy orderby directive</li>\n<li><strong>groupby:</strong>  sqlalchemy gropuby directive</li>\n<li><strong>limit (int):</strong>  number of entries to return before stopping</li>\n<li><strong>wherestr (str):</strong>  raw sql \"where\" conditionals to add to where input</li>\n<li><strong>**kwargs:</strong>  passed to self.execute()</li>\n</ul>\n\n<h6 id=\"yields\">Yields:</h6>\n\n<blockquote>\n  <p>sqlalchemy result object: row data</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">orderby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">groupby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">limit</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.select_raw", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.select_raw", "kind": "function", "doc": "<p>Select some basic shit.\nDescription: Because output must be iterable, returns special column results \n    by performing one query per row. Can be inefficient for many smaller \n    special data information.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cols:</strong>  list of sqlalchemy datatypes created from calling .col() method.</li>\n<li><strong>where (sqlachemy BinaryExpression):</strong>  sqlalchemy \"where\" object to parse</li>\n<li><strong>orderby:</strong>  sqlalchemy orderby directive</li>\n<li><strong>groupby:</strong>  sqlalchemy gropuby directive</li>\n<li><strong>limit (int):</strong>  number of entries to return before stopping</li>\n<li><strong>wherestr (str):</strong>  raw sql \"where\" conditionals to add to where input</li>\n<li><strong>**kwargs:</strong>  passed to self.execute()</li>\n</ul>\n\n<h6 id=\"yields\">Yields:</h6>\n\n<blockquote>\n  <p>sqlalchemy result object: row data</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">orderby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">groupby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">limit</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.select_query", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.select_query", "kind": "function", "doc": "<p>Build and exectute select query given all the conditionals provided as parameters.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">orderby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">groupby</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">limit</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">selectable</span><span class=\"o\">.</span><span class=\"n\">Select</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.parse_input_cols", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.parse_input_cols", "kind": "function", "doc": "<p>Pass variable passed to cols.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.selectquery.SelectQuery.parse_input_col", "modulename": "doctable.query.selectquery", "qualname": "SelectQuery.parse_input_col", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">col</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.updatequery", "modulename": "doctable.query.updatequery", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.query.updatequery.UpdateQuery", "modulename": "doctable.query.updatequery", "qualname": "UpdateQuery", "kind": "class", "doc": "<p></p>\n", "bases": "doctable.query.querybase.QueryBase"}, {"fullname": "doctable.query.updatequery.UpdateQuery.dtab", "modulename": "doctable.query.updatequery", "qualname": "UpdateQuery.dtab", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.doctable.DocTable"}, {"fullname": "doctable.query.updatequery.UpdateQuery.update", "modulename": "doctable.query.updatequery", "qualname": "UpdateQuery.update", "kind": "function", "doc": "<p>Update row(s) assigning the provided values.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>values (dict<colname->value> or list<dict> or list&lt;(col,value)&gt;)):</strong>   values to populate rows with. If dict, will insert those values\ninto all rows that match conditions. If list of dicts, assigns\nexpression in value (i.e. id['year']+1) to column. If list of \n(col,value) 2-tuples, will assign value to col in the order \nprovided. For example given row values x=1 and y=2, the input\n[(x,y+10),(y,20)], new values will be x=12, y=20. If opposite\norder [(y,20),(x,y+10)] is provided new values would be y=20,\nx=30. In cases where list<dict> is provided, this behavior is \nundefined.</li>\n<li><strong>where (sqlalchemy condition):</strong>  used to match rows where\nupdate will be applied.</li>\n<li><strong>wherestr (sql string condition):</strong>  matches same as where arg.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>SQLAlchemy result proxy object</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">],</span> <span class=\"n\">Any</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">cursor</span><span class=\"o\">.</span><span class=\"n\">CursorResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.query.updatequery.UpdateQuery.update_query", "modulename": "doctable.query.updatequery", "qualname": "UpdateQuery.update_query", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">where</span><span class=\"p\">:</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">BinaryExpression</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wherestr</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">dml</span><span class=\"o\">.</span><span class=\"n\">Update</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema", "modulename": "doctable.schema", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.coltype_map", "modulename": "doctable.schema.coltype_map", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.coltype_map.python_to_slqlchemy_type", "modulename": "doctable.schema.coltype_map", "qualname": "python_to_slqlchemy_type", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&lt;class &#x27;int&#x27;&gt;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Integer&#x27;&gt;, &lt;class &#x27;float&#x27;&gt;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Float&#x27;&gt;, &lt;class &#x27;str&#x27;&gt;: &lt;class &#x27;sqlalchemy.sql.sqltypes.String&#x27;&gt;, &lt;class &#x27;bool&#x27;&gt;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Boolean&#x27;&gt;, &lt;class &#x27;datetime.datetime&#x27;&gt;: &lt;class &#x27;sqlalchemy.sql.sqltypes.DateTime&#x27;&gt;, &lt;class &#x27;datetime.time&#x27;&gt;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Time&#x27;&gt;, &lt;class &#x27;datetime.date&#x27;&gt;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Date&#x27;&gt;, &lt;class &#x27;doctable.textmodels.parsetreedoc.ParseTreeDoc&#x27;&gt;: &lt;class &#x27;doctable.schema.custom_coltypes.ParseTreeDocFileType&#x27;&gt;, &lt;class &#x27;bytes&#x27;&gt;: &lt;class &#x27;sqlalchemy.sql.sqltypes.LargeBinary&#x27;&gt;, &lt;class &#x27;doctable.schema.custom_coltypes.JSONType&#x27;&gt;: &lt;class &#x27;doctable.schema.custom_coltypes.JSONType&#x27;&gt;, typing.Any: &lt;class &#x27;sqlalchemy.sql.sqltypes.PickleType&#x27;&gt;, &#x27;int&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Integer&#x27;&gt;, &#x27;float&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Float&#x27;&gt;, &#x27;str&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.String&#x27;&gt;, &#x27;bool&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Boolean&#x27;&gt;, &#x27;datetime&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.DateTime&#x27;&gt;, &#x27;time&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Time&#x27;&gt;, &#x27;date&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Date&#x27;&gt;, &#x27;ParseTreeDoc&#x27;: &lt;class &#x27;doctable.schema.custom_coltypes.ParseTreeDocFileType&#x27;&gt;, &#x27;bytes&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.LargeBinary&#x27;&gt;, &#x27;JSONType&#x27;: &lt;class &#x27;doctable.schema.custom_coltypes.JSONType&#x27;&gt;, &#x27;Any&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.PickleType&#x27;&gt;}"}, {"fullname": "doctable.schema.coltype_map.constraint_lookup", "modulename": "doctable.schema.coltype_map", "qualname": "constraint_lookup", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;check&#x27;: &lt;class &#x27;sqlalchemy.sql.schema.CheckConstraint&#x27;&gt;, &#x27;unique&#x27;: &lt;class &#x27;sqlalchemy.sql.schema.UniqueConstraint&#x27;&gt;, &#x27;primarykey&#x27;: &lt;class &#x27;sqlalchemy.sql.schema.PrimaryKeyConstraint&#x27;&gt;, &#x27;foreignkey&#x27;: &lt;class &#x27;sqlalchemy.sql.schema.ForeignKeyConstraint&#x27;&gt;}"}, {"fullname": "doctable.schema.coltype_map.string_to_sqlalchemy_type", "modulename": "doctable.schema.coltype_map", "qualname": "string_to_sqlalchemy_type", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;biginteger&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.BigInteger&#x27;&gt;, &#x27;boolean&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Boolean&#x27;&gt;, &#x27;date&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Date&#x27;&gt;, &#x27;datetime&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.DateTime&#x27;&gt;, &#x27;enum&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Enum&#x27;&gt;, &#x27;float&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Float&#x27;&gt;, &#x27;integer&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Integer&#x27;&gt;, &#x27;interval&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Interval&#x27;&gt;, &#x27;largebinary&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.LargeBinary&#x27;&gt;, &#x27;numeric&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Numeric&#x27;&gt;, &#x27;smallinteger&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.SmallInteger&#x27;&gt;, &#x27;string&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.String&#x27;&gt;, &#x27;text&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Text&#x27;&gt;, &#x27;time&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Time&#x27;&gt;, &#x27;unicode&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.Unicode&#x27;&gt;, &#x27;unicodetext&#x27;: &lt;class &#x27;sqlalchemy.sql.sqltypes.UnicodeText&#x27;&gt;, &#x27;json&#x27;: &lt;class &#x27;doctable.schema.custom_coltypes.JSONType&#x27;&gt;, &#x27;pickle&#x27;: &lt;class &#x27;doctable.schema.custom_coltypes.CpickleType&#x27;&gt;, &#x27;parsetree&#x27;: &lt;class &#x27;doctable.schema.custom_coltypes.ParseTreeDocFileType&#x27;&gt;, &#x27;picklefile&#x27;: &lt;class &#x27;doctable.schema.custom_coltypes.PickleFileType&#x27;&gt;, &#x27;textfile&#x27;: &lt;class &#x27;doctable.schema.custom_coltypes.TextFileType&#x27;&gt;}"}, {"fullname": "doctable.schema.columnmetadata", "modulename": "doctable.schema.columnmetadata", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.columnmetadata.ColumnMetadata", "modulename": "doctable.schema.columnmetadata", "qualname": "ColumnMetadata", "kind": "class", "doc": "<p>Stores metadata from the user for conversion to an sqlalchemy column.</p>\n"}, {"fullname": "doctable.schema.columnmetadata.ColumnMetadata.__init__", "modulename": "doctable.schema.columnmetadata", "qualname": "ColumnMetadata.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">column_type</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">type_api</span><span class=\"o\">.</span><span class=\"n\">TypeEngine</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">type_kwargs</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">column_kwargs</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "doctable.schema.columnmetadata.ColumnMetadata.column_type", "modulename": "doctable.schema.columnmetadata", "qualname": "ColumnMetadata.column_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Union[str, type, sqlalchemy.sql.type_api.TypeEngine]"}, {"fullname": "doctable.schema.columnmetadata.ColumnMetadata.type_kwargs", "modulename": "doctable.schema.columnmetadata", "qualname": "ColumnMetadata.type_kwargs", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict", "default_value": "None"}, {"fullname": "doctable.schema.columnmetadata.ColumnMetadata.column_kwargs", "modulename": "doctable.schema.columnmetadata", "qualname": "ColumnMetadata.column_kwargs", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict", "default_value": "None"}, {"fullname": "doctable.schema.columnmetadata.ColumnMetadata.get_sqlalchemy_col", "modulename": "doctable.schema.columnmetadata", "qualname": "ColumnMetadata.get_sqlalchemy_col", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">type_hint</span><span class=\"p\">:</span> <span class=\"nb\">type</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.columnmetadata.ColumnMetadata.get_sqlalchemy_type", "modulename": "doctable.schema.columnmetadata", "qualname": "ColumnMetadata.get_sqlalchemy_type", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">type_hint</span><span class=\"p\">:</span> <span class=\"nb\">type</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes", "modulename": "doctable.schema.custom_coltypes", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeControl", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeControl", "kind": "class", "doc": "<p>All instances of FileTypeBase will have a reference to this object.</p>\n"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeControl.__init__", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeControl.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span></span>)</span>"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeControl.select_raw_fname", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeControl.select_raw_fname", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeControl.path", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeControl.path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeControl.full_path", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeControl.full_path", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeBase", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeBase", "kind": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  cache_ok = True\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n<code>.TypeEngine</code> class.  Alternatively, the <code>load_dialect_impl()</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>The <code>.TypeDecorator.cache_ok</code> class-level flag indicates if this\ncustom <code>.TypeDecorator</code> is safe to be used as part of a cache key.\nThis flag defaults to <code>None</code> which will initially generate a warning\nwhen the SQL compiler attempts to generate a cache key for a statement\nthat uses this type.  If the <code>.TypeDecorator</code> is not guaranteed\nto produce the same bind/result behavior and SQL generation\nevery time, this flag should be set to <code>False</code>; otherwise if the\nclass produces the same behavior each time, it may be set to <code>True</code>.\nSee <code>.TypeDecorator.cache_ok</code> for further notes on how this works.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the <code>TypeDecorator.coerce_compared_value()</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n<code>~TypeDecorator.coerce_compared_value()</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<div class=\"pdoc-alert pdoc-alert-warning\">\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\nby default from that of the base type</strong>.\nIf the <code>.TypeDecorator</code> is augmenting a\ntype that requires special logic for certain types of operators,\nthis method <strong>must</strong> be overridden.  A key example is when decorating\nthe <code>_postgresql.JSON</code> and <code>_postgresql.JSONB</code> types;\nthe default rules of <code>.TypeEngine.coerce_compared_value()</code> should\nbe used in order to deal with operators like index operations::</p>\n\n<pre><code> from sqlalchemy import JSON\n from sqlalchemy import TypeDecorator\n\n class MyJsonType(TypeDecorator):\n     impl = JSON\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\nwill cause the index value <code>'foo'</code> to be JSON encoded.</p>\n\n<p>Similarly, when working with the <code>.ARRAY</code> datatype, the\ntype coercion for index operations (e.g. <code>mycol[5]</code>) is also\nhandled by <code>.TypeDecorator.coerce_compared_value()</code>, where\nagain a simple override is sufficient unless special rules are needed\nfor particular operators::</p>\n\n<pre><code> from sqlalchemy import ARRAY\n from sqlalchemy import TypeDecorator\n\n class MyArrayType(TypeDecorator):\n     impl = ARRAY\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n</div>\n", "bases": "sqlalchemy.sql.visitors.Visitable, typing.Generic[~_T]"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeBase.__init__", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeBase.__init__", "kind": "function", "doc": "<p>Construct a <code>.TypeDecorator</code>.</p>\n\n<p>Arguments sent here are passed to the constructor\nof the class assigned to the <code>impl</code> class level attribute,\nassuming the <code>impl</code> is a callable, and the resulting\nobject is assigned to the <code>self.impl</code> instance attribute\n(thus overriding the class attribute of the same name).</p>\n\n<p>If the class level <code>impl</code> is not a callable (the unusual case),\nit will be assigned to the same instance attribute 'as-is',\nignoring those arguments passed to the constructor.</p>\n\n<p>Subclasses can override this to customize the generation\nof <code>self.impl</code> entirely.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">arg</span>, </span><span class=\"param\"><span class=\"n\">folder</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeBase.impl", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeBase.impl", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;class &#x27;sqlalchemy.sql.sqltypes.String&#x27;&gt;"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeBase.file_ext", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeBase.file_ext", "kind": "variable", "doc": "<p></p>\n", "default_value": "None"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeBase.fname_num_size", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeBase.fname_num_size", "kind": "variable", "doc": "<p></p>\n", "default_value": "1000000000000"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeBase.control", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeBase.control", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeBase.path", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeBase.path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeBase.dump_data", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeBase.dump_data", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeBase.load_data", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeBase.load_data", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeBase.process_bind_param", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeBase.process_bind_param", "kind": "function", "doc": "<p>Receive a bound parameter value to be converted.</p>\n\n<p>Custom subclasses of <code>_types.TypeDecorator</code> should override\nthis method to provide custom behaviors for incoming data values.\nThis method is called at <strong>statement execution time</strong> and is passed\nthe literal Python data value which is to be associated with a bound\nparameter in the statement.</p>\n\n<p>The operation could be anything desired to perform custom\nbehavior, such as transforming or serializing data.\nThis could also be used as a hook for validating logic.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>value</strong>:  Data to operate upon, of any type expected by\nthis method in the subclass.  Can be <code>None</code>.</li>\n<li><strong>dialect</strong>:  the <code>.Dialect</code> in use.</li>\n</ul>\n\n<p><em>seealso:</em>\n:ref:<code>types_typedecorator</code></p>\n\n<p><code>_types.TypeDecorator.process_result_value()</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.FileTypeBase.process_result_value", "modulename": "doctable.schema.custom_coltypes", "qualname": "FileTypeBase.process_result_value", "kind": "function", "doc": "<p>Receive a result-row column value to be converted.</p>\n\n<p>Custom subclasses of <code>_types.TypeDecorator</code> should override\nthis method to provide custom behaviors for data values\nbeing received in result rows coming from the database.\nThis method is called at <strong>result fetching time</strong> and is passed\nthe literal Python data value that's extracted from a database result\nrow.</p>\n\n<p>The operation could be anything desired to perform custom\nbehavior, such as transforming or deserializing data.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>value</strong>:  Data to operate upon, of any type expected by\nthis method in the subclass.  Can be <code>None</code>.</li>\n<li><strong>dialect</strong>:  the <code>.Dialect</code> in use.</li>\n</ul>\n\n<p><em>seealso:</em>\n:ref:<code>types_typedecorator</code></p>\n\n<p><code>_types.TypeDecorator.process_bind_param()</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.PickleFileType", "modulename": "doctable.schema.custom_coltypes", "qualname": "PickleFileType", "kind": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  cache_ok = True\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n<code>.TypeEngine</code> class.  Alternatively, the <code>load_dialect_impl()</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>The <code>.TypeDecorator.cache_ok</code> class-level flag indicates if this\ncustom <code>.TypeDecorator</code> is safe to be used as part of a cache key.\nThis flag defaults to <code>None</code> which will initially generate a warning\nwhen the SQL compiler attempts to generate a cache key for a statement\nthat uses this type.  If the <code>.TypeDecorator</code> is not guaranteed\nto produce the same bind/result behavior and SQL generation\nevery time, this flag should be set to <code>False</code>; otherwise if the\nclass produces the same behavior each time, it may be set to <code>True</code>.\nSee <code>.TypeDecorator.cache_ok</code> for further notes on how this works.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the <code>TypeDecorator.coerce_compared_value()</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n<code>~TypeDecorator.coerce_compared_value()</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<div class=\"pdoc-alert pdoc-alert-warning\">\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\nby default from that of the base type</strong>.\nIf the <code>.TypeDecorator</code> is augmenting a\ntype that requires special logic for certain types of operators,\nthis method <strong>must</strong> be overridden.  A key example is when decorating\nthe <code>_postgresql.JSON</code> and <code>_postgresql.JSONB</code> types;\nthe default rules of <code>.TypeEngine.coerce_compared_value()</code> should\nbe used in order to deal with operators like index operations::</p>\n\n<pre><code> from sqlalchemy import JSON\n from sqlalchemy import TypeDecorator\n\n class MyJsonType(TypeDecorator):\n     impl = JSON\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\nwill cause the index value <code>'foo'</code> to be JSON encoded.</p>\n\n<p>Similarly, when working with the <code>.ARRAY</code> datatype, the\ntype coercion for index operations (e.g. <code>mycol[5]</code>) is also\nhandled by <code>.TypeDecorator.coerce_compared_value()</code>, where\nagain a simple override is sufficient unless special rules are needed\nfor particular operators::</p>\n\n<pre><code> from sqlalchemy import ARRAY\n from sqlalchemy import TypeDecorator\n\n class MyArrayType(TypeDecorator):\n     impl = ARRAY\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n</div>\n", "bases": "sqlalchemy.sql.visitors.Visitable, typing.Generic[~_T]"}, {"fullname": "doctable.schema.custom_coltypes.PickleFileType.file_ext", "modulename": "doctable.schema.custom_coltypes", "qualname": "PickleFileType.file_ext", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;.pic&#x27;"}, {"fullname": "doctable.schema.custom_coltypes.PickleFileType.dump_data", "modulename": "doctable.schema.custom_coltypes", "qualname": "PickleFileType.dump_data", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.PickleFileType.load_data", "modulename": "doctable.schema.custom_coltypes", "qualname": "PickleFileType.load_data", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.ParseTreeDocFileType", "modulename": "doctable.schema.custom_coltypes", "qualname": "ParseTreeDocFileType", "kind": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  cache_ok = True\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n<code>.TypeEngine</code> class.  Alternatively, the <code>load_dialect_impl()</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>The <code>.TypeDecorator.cache_ok</code> class-level flag indicates if this\ncustom <code>.TypeDecorator</code> is safe to be used as part of a cache key.\nThis flag defaults to <code>None</code> which will initially generate a warning\nwhen the SQL compiler attempts to generate a cache key for a statement\nthat uses this type.  If the <code>.TypeDecorator</code> is not guaranteed\nto produce the same bind/result behavior and SQL generation\nevery time, this flag should be set to <code>False</code>; otherwise if the\nclass produces the same behavior each time, it may be set to <code>True</code>.\nSee <code>.TypeDecorator.cache_ok</code> for further notes on how this works.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the <code>TypeDecorator.coerce_compared_value()</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n<code>~TypeDecorator.coerce_compared_value()</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<div class=\"pdoc-alert pdoc-alert-warning\">\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\nby default from that of the base type</strong>.\nIf the <code>.TypeDecorator</code> is augmenting a\ntype that requires special logic for certain types of operators,\nthis method <strong>must</strong> be overridden.  A key example is when decorating\nthe <code>_postgresql.JSON</code> and <code>_postgresql.JSONB</code> types;\nthe default rules of <code>.TypeEngine.coerce_compared_value()</code> should\nbe used in order to deal with operators like index operations::</p>\n\n<pre><code> from sqlalchemy import JSON\n from sqlalchemy import TypeDecorator\n\n class MyJsonType(TypeDecorator):\n     impl = JSON\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\nwill cause the index value <code>'foo'</code> to be JSON encoded.</p>\n\n<p>Similarly, when working with the <code>.ARRAY</code> datatype, the\ntype coercion for index operations (e.g. <code>mycol[5]</code>) is also\nhandled by <code>.TypeDecorator.coerce_compared_value()</code>, where\nagain a simple override is sufficient unless special rules are needed\nfor particular operators::</p>\n\n<pre><code> from sqlalchemy import ARRAY\n from sqlalchemy import TypeDecorator\n\n class MyArrayType(TypeDecorator):\n     impl = ARRAY\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n</div>\n", "bases": "sqlalchemy.sql.visitors.Visitable, typing.Generic[~_T]"}, {"fullname": "doctable.schema.custom_coltypes.ParseTreeDocFileType.file_ext", "modulename": "doctable.schema.custom_coltypes", "qualname": "ParseTreeDocFileType.file_ext", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;_parsetreedoc.pic&#x27;"}, {"fullname": "doctable.schema.custom_coltypes.ParseTreeDocFileType.dump_data", "modulename": "doctable.schema.custom_coltypes", "qualname": "ParseTreeDocFileType.dump_data", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.ParseTreeDocFileType.load_data", "modulename": "doctable.schema.custom_coltypes", "qualname": "ParseTreeDocFileType.load_data", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.TextFileType", "modulename": "doctable.schema.custom_coltypes", "qualname": "TextFileType", "kind": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  cache_ok = True\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n<code>.TypeEngine</code> class.  Alternatively, the <code>load_dialect_impl()</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>The <code>.TypeDecorator.cache_ok</code> class-level flag indicates if this\ncustom <code>.TypeDecorator</code> is safe to be used as part of a cache key.\nThis flag defaults to <code>None</code> which will initially generate a warning\nwhen the SQL compiler attempts to generate a cache key for a statement\nthat uses this type.  If the <code>.TypeDecorator</code> is not guaranteed\nto produce the same bind/result behavior and SQL generation\nevery time, this flag should be set to <code>False</code>; otherwise if the\nclass produces the same behavior each time, it may be set to <code>True</code>.\nSee <code>.TypeDecorator.cache_ok</code> for further notes on how this works.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the <code>TypeDecorator.coerce_compared_value()</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n<code>~TypeDecorator.coerce_compared_value()</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<div class=\"pdoc-alert pdoc-alert-warning\">\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\nby default from that of the base type</strong>.\nIf the <code>.TypeDecorator</code> is augmenting a\ntype that requires special logic for certain types of operators,\nthis method <strong>must</strong> be overridden.  A key example is when decorating\nthe <code>_postgresql.JSON</code> and <code>_postgresql.JSONB</code> types;\nthe default rules of <code>.TypeEngine.coerce_compared_value()</code> should\nbe used in order to deal with operators like index operations::</p>\n\n<pre><code> from sqlalchemy import JSON\n from sqlalchemy import TypeDecorator\n\n class MyJsonType(TypeDecorator):\n     impl = JSON\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\nwill cause the index value <code>'foo'</code> to be JSON encoded.</p>\n\n<p>Similarly, when working with the <code>.ARRAY</code> datatype, the\ntype coercion for index operations (e.g. <code>mycol[5]</code>) is also\nhandled by <code>.TypeDecorator.coerce_compared_value()</code>, where\nagain a simple override is sufficient unless special rules are needed\nfor particular operators::</p>\n\n<pre><code> from sqlalchemy import ARRAY\n from sqlalchemy import TypeDecorator\n\n class MyArrayType(TypeDecorator):\n     impl = ARRAY\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n</div>\n", "bases": "sqlalchemy.sql.visitors.Visitable, typing.Generic[~_T]"}, {"fullname": "doctable.schema.custom_coltypes.TextFileType.file_ext", "modulename": "doctable.schema.custom_coltypes", "qualname": "TextFileType.file_ext", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;.txt&#x27;"}, {"fullname": "doctable.schema.custom_coltypes.TextFileType.dump_data", "modulename": "doctable.schema.custom_coltypes", "qualname": "TextFileType.dump_data", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">text</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.TextFileType.load_data", "modulename": "doctable.schema.custom_coltypes", "qualname": "TextFileType.load_data", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.JSONFileType", "modulename": "doctable.schema.custom_coltypes", "qualname": "JSONFileType", "kind": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  cache_ok = True\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n<code>.TypeEngine</code> class.  Alternatively, the <code>load_dialect_impl()</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>The <code>.TypeDecorator.cache_ok</code> class-level flag indicates if this\ncustom <code>.TypeDecorator</code> is safe to be used as part of a cache key.\nThis flag defaults to <code>None</code> which will initially generate a warning\nwhen the SQL compiler attempts to generate a cache key for a statement\nthat uses this type.  If the <code>.TypeDecorator</code> is not guaranteed\nto produce the same bind/result behavior and SQL generation\nevery time, this flag should be set to <code>False</code>; otherwise if the\nclass produces the same behavior each time, it may be set to <code>True</code>.\nSee <code>.TypeDecorator.cache_ok</code> for further notes on how this works.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the <code>TypeDecorator.coerce_compared_value()</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n<code>~TypeDecorator.coerce_compared_value()</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<div class=\"pdoc-alert pdoc-alert-warning\">\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\nby default from that of the base type</strong>.\nIf the <code>.TypeDecorator</code> is augmenting a\ntype that requires special logic for certain types of operators,\nthis method <strong>must</strong> be overridden.  A key example is when decorating\nthe <code>_postgresql.JSON</code> and <code>_postgresql.JSONB</code> types;\nthe default rules of <code>.TypeEngine.coerce_compared_value()</code> should\nbe used in order to deal with operators like index operations::</p>\n\n<pre><code> from sqlalchemy import JSON\n from sqlalchemy import TypeDecorator\n\n class MyJsonType(TypeDecorator):\n     impl = JSON\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\nwill cause the index value <code>'foo'</code> to be JSON encoded.</p>\n\n<p>Similarly, when working with the <code>.ARRAY</code> datatype, the\ntype coercion for index operations (e.g. <code>mycol[5]</code>) is also\nhandled by <code>.TypeDecorator.coerce_compared_value()</code>, where\nagain a simple override is sufficient unless special rules are needed\nfor particular operators::</p>\n\n<pre><code> from sqlalchemy import ARRAY\n from sqlalchemy import TypeDecorator\n\n class MyArrayType(TypeDecorator):\n     impl = ARRAY\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n</div>\n", "bases": "sqlalchemy.sql.visitors.Visitable, typing.Generic[~_T]"}, {"fullname": "doctable.schema.custom_coltypes.JSONFileType.file_ext", "modulename": "doctable.schema.custom_coltypes", "qualname": "JSONFileType.file_ext", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;.json&#x27;"}, {"fullname": "doctable.schema.custom_coltypes.JSONFileType.dump_data", "modulename": "doctable.schema.custom_coltypes", "qualname": "JSONFileType.dump_data", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.JSONFileType.load_data", "modulename": "doctable.schema.custom_coltypes", "qualname": "JSONFileType.load_data", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.CpickleType", "modulename": "doctable.schema.custom_coltypes", "qualname": "CpickleType", "kind": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  cache_ok = True\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n<code>.TypeEngine</code> class.  Alternatively, the <code>load_dialect_impl()</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>The <code>.TypeDecorator.cache_ok</code> class-level flag indicates if this\ncustom <code>.TypeDecorator</code> is safe to be used as part of a cache key.\nThis flag defaults to <code>None</code> which will initially generate a warning\nwhen the SQL compiler attempts to generate a cache key for a statement\nthat uses this type.  If the <code>.TypeDecorator</code> is not guaranteed\nto produce the same bind/result behavior and SQL generation\nevery time, this flag should be set to <code>False</code>; otherwise if the\nclass produces the same behavior each time, it may be set to <code>True</code>.\nSee <code>.TypeDecorator.cache_ok</code> for further notes on how this works.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the <code>TypeDecorator.coerce_compared_value()</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n<code>~TypeDecorator.coerce_compared_value()</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<div class=\"pdoc-alert pdoc-alert-warning\">\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\nby default from that of the base type</strong>.\nIf the <code>.TypeDecorator</code> is augmenting a\ntype that requires special logic for certain types of operators,\nthis method <strong>must</strong> be overridden.  A key example is when decorating\nthe <code>_postgresql.JSON</code> and <code>_postgresql.JSONB</code> types;\nthe default rules of <code>.TypeEngine.coerce_compared_value()</code> should\nbe used in order to deal with operators like index operations::</p>\n\n<pre><code> from sqlalchemy import JSON\n from sqlalchemy import TypeDecorator\n\n class MyJsonType(TypeDecorator):\n     impl = JSON\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\nwill cause the index value <code>'foo'</code> to be JSON encoded.</p>\n\n<p>Similarly, when working with the <code>.ARRAY</code> datatype, the\ntype coercion for index operations (e.g. <code>mycol[5]</code>) is also\nhandled by <code>.TypeDecorator.coerce_compared_value()</code>, where\nagain a simple override is sufficient unless special rules are needed\nfor particular operators::</p>\n\n<pre><code> from sqlalchemy import ARRAY\n from sqlalchemy import TypeDecorator\n\n class MyArrayType(TypeDecorator):\n     impl = ARRAY\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n</div>\n", "bases": "sqlalchemy.sql.visitors.Visitable, typing.Generic[~_T]"}, {"fullname": "doctable.schema.custom_coltypes.CpickleType.impl", "modulename": "doctable.schema.custom_coltypes", "qualname": "CpickleType.impl", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;class &#x27;sqlalchemy.sql.sqltypes.LargeBinary&#x27;&gt;"}, {"fullname": "doctable.schema.custom_coltypes.CpickleType.process_bind_param", "modulename": "doctable.schema.custom_coltypes", "qualname": "CpickleType.process_bind_param", "kind": "function", "doc": "<p>Receive a bound parameter value to be converted.</p>\n\n<p>Custom subclasses of <code>_types.TypeDecorator</code> should override\nthis method to provide custom behaviors for incoming data values.\nThis method is called at <strong>statement execution time</strong> and is passed\nthe literal Python data value which is to be associated with a bound\nparameter in the statement.</p>\n\n<p>The operation could be anything desired to perform custom\nbehavior, such as transforming or serializing data.\nThis could also be used as a hook for validating logic.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>value</strong>:  Data to operate upon, of any type expected by\nthis method in the subclass.  Can be <code>None</code>.</li>\n<li><strong>dialect</strong>:  the <code>.Dialect</code> in use.</li>\n</ul>\n\n<p><em>seealso:</em>\n:ref:<code>types_typedecorator</code></p>\n\n<p><code>_types.TypeDecorator.process_result_value()</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.CpickleType.process_result_value", "modulename": "doctable.schema.custom_coltypes", "qualname": "CpickleType.process_result_value", "kind": "function", "doc": "<p>Receive a result-row column value to be converted.</p>\n\n<p>Custom subclasses of <code>_types.TypeDecorator</code> should override\nthis method to provide custom behaviors for data values\nbeing received in result rows coming from the database.\nThis method is called at <strong>result fetching time</strong> and is passed\nthe literal Python data value that's extracted from a database result\nrow.</p>\n\n<p>The operation could be anything desired to perform custom\nbehavior, such as transforming or deserializing data.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>value</strong>:  Data to operate upon, of any type expected by\nthis method in the subclass.  Can be <code>None</code>.</li>\n<li><strong>dialect</strong>:  the <code>.Dialect</code> in use.</li>\n</ul>\n\n<p><em>seealso:</em>\n:ref:<code>types_typedecorator</code></p>\n\n<p><code>_types.TypeDecorator.process_bind_param()</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.JSONType", "modulename": "doctable.schema.custom_coltypes", "qualname": "JSONType", "kind": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  cache_ok = True\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n<code>.TypeEngine</code> class.  Alternatively, the <code>load_dialect_impl()</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>The <code>.TypeDecorator.cache_ok</code> class-level flag indicates if this\ncustom <code>.TypeDecorator</code> is safe to be used as part of a cache key.\nThis flag defaults to <code>None</code> which will initially generate a warning\nwhen the SQL compiler attempts to generate a cache key for a statement\nthat uses this type.  If the <code>.TypeDecorator</code> is not guaranteed\nto produce the same bind/result behavior and SQL generation\nevery time, this flag should be set to <code>False</code>; otherwise if the\nclass produces the same behavior each time, it may be set to <code>True</code>.\nSee <code>.TypeDecorator.cache_ok</code> for further notes on how this works.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the <code>TypeDecorator.coerce_compared_value()</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n<code>~TypeDecorator.coerce_compared_value()</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<div class=\"pdoc-alert pdoc-alert-warning\">\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\nby default from that of the base type</strong>.\nIf the <code>.TypeDecorator</code> is augmenting a\ntype that requires special logic for certain types of operators,\nthis method <strong>must</strong> be overridden.  A key example is when decorating\nthe <code>_postgresql.JSON</code> and <code>_postgresql.JSONB</code> types;\nthe default rules of <code>.TypeEngine.coerce_compared_value()</code> should\nbe used in order to deal with operators like index operations::</p>\n\n<pre><code> from sqlalchemy import JSON\n from sqlalchemy import TypeDecorator\n\n class MyJsonType(TypeDecorator):\n     impl = JSON\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\nwill cause the index value <code>'foo'</code> to be JSON encoded.</p>\n\n<p>Similarly, when working with the <code>.ARRAY</code> datatype, the\ntype coercion for index operations (e.g. <code>mycol[5]</code>) is also\nhandled by <code>.TypeDecorator.coerce_compared_value()</code>, where\nagain a simple override is sufficient unless special rules are needed\nfor particular operators::</p>\n\n<pre><code> from sqlalchemy import ARRAY\n from sqlalchemy import TypeDecorator\n\n class MyArrayType(TypeDecorator):\n     impl = ARRAY\n\n     cache_ok = True\n\n     def coerce_compared_value(self, op, value):\n         return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n</div>\n", "bases": "sqlalchemy.sql.visitors.Visitable, typing.Generic[~_T]"}, {"fullname": "doctable.schema.custom_coltypes.JSONType.impl", "modulename": "doctable.schema.custom_coltypes", "qualname": "JSONType.impl", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;class &#x27;sqlalchemy.sql.sqltypes.String&#x27;&gt;"}, {"fullname": "doctable.schema.custom_coltypes.JSONType.process_bind_param", "modulename": "doctable.schema.custom_coltypes", "qualname": "JSONType.process_bind_param", "kind": "function", "doc": "<p>Receive a bound parameter value to be converted.</p>\n\n<p>Custom subclasses of <code>_types.TypeDecorator</code> should override\nthis method to provide custom behaviors for incoming data values.\nThis method is called at <strong>statement execution time</strong> and is passed\nthe literal Python data value which is to be associated with a bound\nparameter in the statement.</p>\n\n<p>The operation could be anything desired to perform custom\nbehavior, such as transforming or serializing data.\nThis could also be used as a hook for validating logic.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>value</strong>:  Data to operate upon, of any type expected by\nthis method in the subclass.  Can be <code>None</code>.</li>\n<li><strong>dialect</strong>:  the <code>.Dialect</code> in use.</li>\n</ul>\n\n<p><em>seealso:</em>\n:ref:<code>types_typedecorator</code></p>\n\n<p><code>_types.TypeDecorator.process_result_value()</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.JSONType.process_result_value", "modulename": "doctable.schema.custom_coltypes", "qualname": "JSONType.process_result_value", "kind": "function", "doc": "<p>Receive a result-row column value to be converted.</p>\n\n<p>Custom subclasses of <code>_types.TypeDecorator</code> should override\nthis method to provide custom behaviors for data values\nbeing received in result rows coming from the database.\nThis method is called at <strong>result fetching time</strong> and is passed\nthe literal Python data value that's extracted from a database result\nrow.</p>\n\n<p>The operation could be anything desired to perform custom\nbehavior, such as transforming or deserializing data.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>value</strong>:  Data to operate upon, of any type expected by\nthis method in the subclass.  Can be <code>None</code>.</li>\n<li><strong>dialect</strong>:  the <code>.Dialect</code> in use.</li>\n</ul>\n\n<p><em>seealso:</em>\n:ref:<code>types_typedecorator</code></p>\n\n<p><code>_types.TypeDecorator.process_bind_param()</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">dialect</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.custom_coltypes.is_iter", "modulename": "doctable.schema.custom_coltypes", "qualname": "is_iter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">o</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema", "modulename": "doctable.schema.dataclassschema", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.dataclassschema.constraints", "modulename": "doctable.schema.dataclassschema.constraints", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.dataclassschema.constraints.ConstraintNotFoundError", "modulename": "doctable.schema.dataclassschema.constraints", "qualname": "ConstraintNotFoundError", "kind": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "builtins.Exception"}, {"fullname": "doctable.schema.dataclassschema.constraints.Constraint", "modulename": "doctable.schema.dataclassschema.constraints", "qualname": "Constraint", "kind": "function", "doc": "<p>Return an sqlalchemy constraint.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>constraint_type:</strong>  from doctable.constraint_lookup.keys()</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">constraint_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">args</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Constraint</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema", "modulename": "doctable.schema.dataclassschema.dataclassschema", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema.DataclassSchema", "modulename": "doctable.schema.dataclassschema.dataclassschema", "qualname": "DataclassSchema", "kind": "class", "doc": "<p>Contains info about the db schema and methods to convert to/from schema objects.</p>\n", "bases": "doctable.schema.schemabase.SchemaBase"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema.DataclassSchema.__init__", "modulename": "doctable.schema.dataclassschema.dataclassschema", "qualname": "DataclassSchema.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">columns</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">schema_class</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">Index</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">constraints</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Constraint</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema.DataclassSchema.columns", "modulename": "doctable.schema.dataclassschema.dataclassschema", "qualname": "DataclassSchema.columns", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[sqlalchemy.sql.schema.Column]"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema.DataclassSchema.schema_class", "modulename": "doctable.schema.dataclassschema.dataclassschema", "qualname": "DataclassSchema.schema_class", "kind": "variable", "doc": "<p></p>\n", "annotation": ": type[doctable.schema.dataclassschema.doctableschema.DocTableSchema]"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema.DataclassSchema.indices", "modulename": "doctable.schema.dataclassschema.dataclassschema", "qualname": "DataclassSchema.indices", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Tuple[doctable.schema.dataclassschema.index.Index]"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema.DataclassSchema.constraints", "modulename": "doctable.schema.dataclassschema.dataclassschema", "qualname": "DataclassSchema.constraints", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Tuple[Constraint]"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema.DataclassSchema.from_schema_definition", "modulename": "doctable.schema.dataclassschema.dataclassschema", "qualname": "DataclassSchema.from_schema_definition", "kind": "function", "doc": "<p>Convert a dataclass definition to a list of sqlalchemy columns.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">schema_class</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">Index</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">constraints</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Constraint</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema.DataclassSchema.object_to_dict", "modulename": "doctable.schema.dataclassschema.dataclassschema", "qualname": "DataclassSchema.object_to_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema.DataclassSchema.row_to_object", "modulename": "doctable.schema.dataclassschema.dataclassschema", "qualname": "DataclassSchema.row_to_object", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">row</span><span class=\"p\">:</span> <span class=\"s1\">&#39;sqlalchemy.engine.row.LegacyRow&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema.DataclassSchema.parse_columns", "modulename": "doctable.schema.dataclassschema.dataclassschema", "qualname": "DataclassSchema.parse_columns", "kind": "function", "doc": "<p>Convert the dataclass member variables to sqlalchemy columns.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Cls</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema.DataclassSchema.parse_indices", "modulename": "doctable.schema.dataclassschema.dataclassschema", "qualname": "DataclassSchema.parse_indices", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">indices</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.dataclassschema.DataclassSchema.parse_constraints", "modulename": "doctable.schema.dataclassschema.dataclassschema", "qualname": "DataclassSchema.parse_constraints", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">constraints</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.doctableschema", "modulename": "doctable.schema.dataclassschema.doctableschema", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.dataclassschema.doctableschema.miss_col_message", "modulename": "doctable.schema.dataclassschema.doctableschema", "qualname": "miss_col_message", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;The column &quot;{name}&quot; was not retreived in the select statement.&#x27;"}, {"fullname": "doctable.schema.dataclassschema.doctableschema.PropertyAccessor", "modulename": "doctable.schema.dataclassschema.doctableschema", "qualname": "PropertyAccessor", "kind": "class", "doc": "<p>Access properties of the schema object without raising error for missing data.</p>\n"}, {"fullname": "doctable.schema.dataclassschema.doctableschema.PropertyAccessor.__init__", "modulename": "doctable.schema.dataclassschema.doctableschema", "qualname": "PropertyAccessor.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">schema_obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span></span>)</span>"}, {"fullname": "doctable.schema.dataclassschema.doctableschema.PropertyAccessor.schema_obj", "modulename": "doctable.schema.dataclassschema.doctableschema", "qualname": "PropertyAccessor.schema_obj", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.schema.dataclassschema.doctableschema.DocTableSchema"}, {"fullname": "doctable.schema.dataclassschema.doctableschema.PropertyAccessor.is_missing", "modulename": "doctable.schema.dataclassschema.doctableschema", "qualname": "PropertyAccessor.is_missing", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pname</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.doctableschema.DocTableSchema", "modulename": "doctable.schema.dataclassschema.doctableschema", "qualname": "DocTableSchema", "kind": "class", "doc": "<p>Base class for column objects.</p>\n"}, {"fullname": "doctable.schema.dataclassschema.doctableschema.DocTableSchema.v", "modulename": "doctable.schema.dataclassschema.doctableschema", "qualname": "DocTableSchema.v", "kind": "variable", "doc": "<p>Access properties of the schema object without raising exception \nfor missing data.</p>\n", "annotation": ": doctable.schema.dataclassschema.doctableschema.PropertyAccessor"}, {"fullname": "doctable.schema.dataclassschema.doctableschema.DocTableSchema.get_value", "modulename": "doctable.schema.dataclassschema.doctableschema", "qualname": "DocTableSchema.get_value", "kind": "function", "doc": "<p>Access data at a given value.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">property_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.doctableschema.DocTableSchema.asdict", "modulename": "doctable.schema.dataclassschema.doctableschema", "qualname": "DocTableSchema.asdict", "kind": "function", "doc": "<p>Convert object to dictionary, including missing value.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.doctableschema.DocTableSchema.asdict_ignore_missing", "modulename": "doctable.schema.dataclassschema.doctableschema", "qualname": "DocTableSchema.asdict_ignore_missing", "kind": "function", "doc": "<p>Convert object to dictionary, omitting missing value.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.errors", "modulename": "doctable.schema.dataclassschema.errors", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.dataclassschema.errors.DataNotAvailableError", "modulename": "doctable.schema.dataclassschema.errors", "qualname": "DataNotAvailableError", "kind": "class", "doc": "<p>Common base class for all exceptions</p>\n", "bases": "builtins.BaseException"}, {"fullname": "doctable.schema.dataclassschema.errors.RowDataNotAvailableError", "modulename": "doctable.schema.dataclassschema.errors", "qualname": "RowDataNotAvailableError", "kind": "class", "doc": "<p>Common base class for all exceptions</p>\n", "bases": "DataNotAvailableError"}, {"fullname": "doctable.schema.dataclassschema.errors.SlotsRequiredError", "modulename": "doctable.schema.dataclassschema.errors", "qualname": "SlotsRequiredError", "kind": "class", "doc": "<p>Common base class for all exceptions</p>\n", "bases": "builtins.BaseException"}, {"fullname": "doctable.schema.dataclassschema.field_columns", "modulename": "doctable.schema.dataclassschema.field_columns", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.dataclassschema.field_columns.Col", "modulename": "doctable.schema.dataclassschema.field_columns", "qualname": "Col", "kind": "function", "doc": "<p>Returns dataclasses.field() after setting convienient params.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>field_kwargs:</strong>  passed directly to dataclasses.field.</li>\n<li><strong>**column_kwargs:</strong>  passed to the sqlalchemy column object.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">column_type</span><span class=\"p\">:</span> <span class=\"nb\">type</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">field_kwargs</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">type_kwargs</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">column_kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Field</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.field_columns.IDCol", "modulename": "doctable.schema.dataclassschema.field_columns", "qualname": "IDCol", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Field</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.field_columns.UpdatedCol", "modulename": "doctable.schema.dataclassschema.field_columns", "qualname": "UpdatedCol", "kind": "function", "doc": "<p>Column that will automatically update the date/time when the row is modified.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Field</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.field_columns.AddedCol", "modulename": "doctable.schema.dataclassschema.field_columns", "qualname": "AddedCol", "kind": "function", "doc": "<p>Column that will automatically update the date/time when the row is inserted.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Field</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.field_columns.PickleFileCol", "modulename": "doctable.schema.dataclassschema.field_columns", "qualname": "PickleFileCol", "kind": "function", "doc": "<p>Column that will store arbitrary python data in the filesystem and keep only a reference.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Field</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.field_columns.TextFileCol", "modulename": "doctable.schema.dataclassschema.field_columns", "qualname": "TextFileCol", "kind": "function", "doc": "<p>Column that will store text data in the filesystem and keep only a reference.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Field</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.field_columns.ParseTreeFileCol", "modulename": "doctable.schema.dataclassschema.field_columns", "qualname": "ParseTreeFileCol", "kind": "function", "doc": "<p>Column that will store text data in the filesystem and keep only a reference.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dataclasses</span><span class=\"o\">.</span><span class=\"n\">Field</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.index", "modulename": "doctable.schema.dataclassschema.index", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.dataclassschema.index.Index", "modulename": "doctable.schema.dataclassschema.index", "qualname": "Index", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.dataclassschema.index.Index.__init__", "modulename": "doctable.schema.dataclassschema.index", "qualname": "Index.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">columns</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">index_kwargs</span></span>)</span>"}, {"fullname": "doctable.schema.dataclassschema.index.Index.name", "modulename": "doctable.schema.dataclassschema.index", "qualname": "Index.name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.schema.dataclassschema.index.Index.columns", "modulename": "doctable.schema.dataclassschema.index", "qualname": "Index.columns", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[sqlalchemy.sql.schema.Column]"}, {"fullname": "doctable.schema.dataclassschema.index.Index.index_kwargs", "modulename": "doctable.schema.dataclassschema.index", "qualname": "Index.index_kwargs", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Dict[str, Any]"}, {"fullname": "doctable.schema.dataclassschema.index.Index.get_sqlalchemy_index", "modulename": "doctable.schema.dataclassschema.index", "qualname": "Index.get_sqlalchemy_index", "kind": "function", "doc": "<p>Convert this index to an sqlalchemy index with references to the table object.\nNOTE: will convert string column names to column objs.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">col_lookup</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Index</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.operators", "modulename": "doctable.schema.dataclassschema.operators", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.dataclassschema.operators.PROPERTY_NAMES_ATTR", "modulename": "doctable.schema.dataclassschema.operators", "qualname": "PROPERTY_NAMES_ATTR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;__doctable_property_names__&#x27;"}, {"fullname": "doctable.schema.dataclassschema.operators.asdict", "modulename": "doctable.schema.dataclassschema.operators", "qualname": "asdict", "kind": "function", "doc": "<p>Convert the schema object to a dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">schema_obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.operators.asdict_ignore_missing", "modulename": "doctable.schema.dataclassschema.operators", "qualname": "asdict_ignore_missing", "kind": "function", "doc": "<p>Convert the schema object to a dictionary, ignoring missing values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">schema_obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.operators.astuple", "modulename": "doctable.schema.dataclassschema.operators", "qualname": "astuple", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">schema_obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.operators.attr_value_tuples", "modulename": "doctable.schema.dataclassschema.operators", "qualname": "attr_value_tuples", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">schema_obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.operators.as_value_tuple", "modulename": "doctable.schema.dataclassschema.operators", "qualname": "as_value_tuple", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">schema_obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.operators.has_attr_map", "modulename": "doctable.schema.dataclassschema.operators", "qualname": "has_attr_map", "kind": "function", "doc": "<p>Used to access property map to convert column name to underlying property name.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.operators.get_attr_map", "modulename": "doctable.schema.dataclassschema.operators", "qualname": "get_attr_map", "kind": "function", "doc": "<p>Used to access property map to convert column name to underlying property name.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.operators.set_attr_map", "modulename": "doctable.schema.dataclassschema.operators", "qualname": "set_attr_map", "kind": "function", "doc": "<p>Used to attach property names to a schema object.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span>,</span><span class=\"param\">\t<span class=\"n\">attr_map</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.operators.attr_value", "modulename": "doctable.schema.dataclassschema.operators", "qualname": "attr_value", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span>,</span><span class=\"param\">\t<span class=\"n\">property_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.operators.property_to_attr", "modulename": "doctable.schema.dataclassschema.operators", "qualname": "property_to_attr", "kind": "function", "doc": "<p>Convert column name to the property name.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pname</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.operators.attr_to_property", "modulename": "doctable.schema.dataclassschema.operators", "qualname": "attr_to_property", "kind": "function", "doc": "<p>Convert property name to column name.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">aname</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.schema_decorator", "modulename": "doctable.schema.dataclassschema.schema_decorator", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.dataclassschema.schema_decorator.schema", "modulename": "doctable.schema.dataclassschema.schema_decorator", "qualname": "schema", "kind": "function", "doc": "<p>A decorator to change a regular class into a schema object class.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">_Cls</span><span class=\"p\">:</span> <span class=\"nb\">type</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">require_slots</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">enable_properties</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">dataclass_kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">type</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.schema_decorator.schema_decorator_properties_factory", "modulename": "doctable.schema.dataclassschema.schema_decorator", "qualname": "schema_decorator_properties_factory", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">require_slots</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">dataclass_kwargs</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">type</span><span class=\"p\">],</span> <span class=\"nb\">type</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.schema_decorator.schema_decorator_basic_factory", "modulename": "doctable.schema.dataclassschema.schema_decorator", "qualname": "schema_decorator_basic_factory", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">require_slots</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">dataclass_kwargs</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">type</span><span class=\"p\">],</span> <span class=\"nb\">type</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.dataclassschema.schema_decorator.get_getter_setter", "modulename": "doctable.schema.dataclassschema.schema_decorator", "qualname": "get_getter_setter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">property_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.errors", "modulename": "doctable.schema.errors", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.errors.TypeNotRecognizedError", "modulename": "doctable.schema.errors", "qualname": "TypeNotRecognizedError", "kind": "class", "doc": "<p>Common base class for all exceptions</p>\n", "bases": "builtins.BaseException"}, {"fullname": "doctable.schema.errors.RowToObjectConversionFailedError", "modulename": "doctable.schema.errors", "qualname": "RowToObjectConversionFailedError", "kind": "class", "doc": "<p>Common base class for all exceptions</p>\n", "bases": "builtins.BaseException"}, {"fullname": "doctable.schema.errors.ObjectToDictCovnersionFailedError", "modulename": "doctable.schema.errors", "qualname": "ObjectToDictCovnersionFailedError", "kind": "class", "doc": "<p>Common base class for all exceptions</p>\n", "bases": "builtins.BaseException"}, {"fullname": "doctable.schema.inferredschema", "modulename": "doctable.schema.inferredschema", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.inferredschema.InferredSchema", "modulename": "doctable.schema.inferredschema", "qualname": "InferredSchema", "kind": "class", "doc": "<p></p>\n", "bases": "doctable.schema.schemabase.SchemaBase"}, {"fullname": "doctable.schema.inferredschema.InferredSchema.__init__", "modulename": "doctable.schema.inferredschema", "qualname": "InferredSchema.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">columns</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">constraints</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "doctable.schema.inferredschema.InferredSchema.columns", "modulename": "doctable.schema.inferredschema", "qualname": "InferredSchema.columns", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[sqlalchemy.sql.schema.Column]"}, {"fullname": "doctable.schema.inferredschema.InferredSchema.indices", "modulename": "doctable.schema.inferredschema", "qualname": "InferredSchema.indices", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[sqlalchemy.sql.schema.Column]"}, {"fullname": "doctable.schema.inferredschema.InferredSchema.constraints", "modulename": "doctable.schema.inferredschema", "qualname": "InferredSchema.constraints", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[sqlalchemy.sql.schema.Column]"}, {"fullname": "doctable.schema.inferredschema.InferredSchema.from_schema_definition", "modulename": "doctable.schema.inferredschema", "qualname": "InferredSchema.from_schema_definition", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">empty_schema</span><span class=\"p\">:</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.inferredschema.InferredSchema.object_to_dict", "modulename": "doctable.schema.inferredschema", "qualname": "InferredSchema.object_to_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.inferredschema.InferredSchema.row_to_object", "modulename": "doctable.schema.inferredschema", "qualname": "InferredSchema.row_to_object", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema", "modulename": "doctable.schema.rowdictschema", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.rowdictschema.columns", "modulename": "doctable.schema.rowdictschema.columns", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.rowdictschema.columns.Col", "modulename": "doctable.schema.rowdictschema.columns", "qualname": "Col", "kind": "function", "doc": "<p>Returns dataclasses.field() after setting convienient params.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>field_kwargs:</strong>  passed directly to dataclasses.field.</li>\n<li><strong>**column_kwargs:</strong>  passed to the sqlalchemy column object.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">column_type</span><span class=\"p\">:</span> <span class=\"nb\">type</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">field_kwargs</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">type_kwargs</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">column_kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">_make</span><span class=\"o\">.</span><span class=\"n\">Attribute</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.columns.IDCol", "modulename": "doctable.schema.rowdictschema.columns", "qualname": "IDCol", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">_make</span><span class=\"o\">.</span><span class=\"n\">Attribute</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.columns.UpdatedCol", "modulename": "doctable.schema.rowdictschema.columns", "qualname": "UpdatedCol", "kind": "function", "doc": "<p>Column that will automatically update the date/time when the row is modified.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">_make</span><span class=\"o\">.</span><span class=\"n\">Attribute</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.columns.AddedCol", "modulename": "doctable.schema.rowdictschema.columns", "qualname": "AddedCol", "kind": "function", "doc": "<p>Column that will automatically update the date/time when the row is inserted.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">_make</span><span class=\"o\">.</span><span class=\"n\">Attribute</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.columns.PickleFileCol", "modulename": "doctable.schema.rowdictschema.columns", "qualname": "PickleFileCol", "kind": "function", "doc": "<p>Column that will store arbitrary python data in the filesystem and keep only a reference.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">_make</span><span class=\"o\">.</span><span class=\"n\">Attribute</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.columns.TextFileCol", "modulename": "doctable.schema.rowdictschema.columns", "qualname": "TextFileCol", "kind": "function", "doc": "<p>Column that will store text data in the filesystem and keep only a reference.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">_make</span><span class=\"o\">.</span><span class=\"n\">Attribute</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.columns.ParseTreeFileCol", "modulename": "doctable.schema.rowdictschema.columns", "qualname": "ParseTreeFileCol", "kind": "function", "doc": "<p>Column that will store text data in the filesystem and keep only a reference.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">_make</span><span class=\"o\">.</span><span class=\"n\">Attribute</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.operators", "modulename": "doctable.schema.rowdictschema.operators", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.rowdictschema.operators.rowdict_attr_name", "modulename": "doctable.schema.rowdictschema.operators", "qualname": "rowdict_attr_name", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;_doctable_rowdict&#x27;"}, {"fullname": "doctable.schema.rowdictschema.operators.rowdict_has_attr", "modulename": "doctable.schema.rowdictschema.operators", "qualname": "rowdict_has_attr", "kind": "function", "doc": "<p>Check if the rowdict has the provided key.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">rowdictschema</span><span class=\"o\">.</span><span class=\"n\">schemaobject</span><span class=\"o\">.</span><span class=\"n\">SchemaObject</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.operators.set_rowdict_attr", "modulename": "doctable.schema.rowdictschema.operators", "qualname": "set_rowdict_attr", "kind": "function", "doc": "<p>Set a particular rowdict attribute</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">rowdictschema</span><span class=\"o\">.</span><span class=\"n\">schemaobject</span><span class=\"o\">.</span><span class=\"n\">SchemaObject</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">val</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.operators.get_rowdict_attr", "modulename": "doctable.schema.rowdictschema.operators", "qualname": "get_rowdict_attr", "kind": "function", "doc": "<p>Get a rowdict attribute.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">rowdictschema</span><span class=\"o\">.</span><span class=\"n\">schemaobject</span><span class=\"o\">.</span><span class=\"n\">SchemaObject</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.operators.get_rowdict_attr_default", "modulename": "doctable.schema.rowdictschema.operators", "qualname": "get_rowdict_attr_default", "kind": "function", "doc": "<p>Get a rowdict attribute using .get() with the provided default.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">rowdictschema</span><span class=\"o\">.</span><span class=\"n\">schemaobject</span><span class=\"o\">.</span><span class=\"n\">SchemaObject</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">default</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.operators.has_rowdict", "modulename": "doctable.schema.rowdictschema.operators", "qualname": "has_rowdict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">rowdictschema</span><span class=\"o\">.</span><span class=\"n\">schemaobject</span><span class=\"o\">.</span><span class=\"n\">SchemaObject</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.operators.set_rowdict", "modulename": "doctable.schema.rowdictschema.operators", "qualname": "set_rowdict", "kind": "function", "doc": "<p>Set the rowdict associated with this object.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">rowdictschema</span><span class=\"o\">.</span><span class=\"n\">schemaobject</span><span class=\"o\">.</span><span class=\"n\">SchemaObject</span>,</span><span class=\"param\">\t<span class=\"n\">rowdict</span><span class=\"p\">:</span> <span class=\"n\">Dict</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.operators.get_rowdict", "modulename": "doctable.schema.rowdictschema.operators", "qualname": "get_rowdict", "kind": "function", "doc": "<p>Get the rowdict associated with this object.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">rowdictschema</span><span class=\"o\">.</span><span class=\"n\">schemaobject</span><span class=\"o\">.</span><span class=\"n\">SchemaObject</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.operators.rowdict_obj_from_dict", "modulename": "doctable.schema.rowdictschema.operators", "qualname": "rowdict_obj_from_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ObjType</span><span class=\"p\">:</span> <span class=\"nb\">type</span>,</span><span class=\"param\">\t<span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"n\">Dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">rowdictschema</span><span class=\"o\">.</span><span class=\"n\">schemaobject</span><span class=\"o\">.</span><span class=\"n\">SchemaObject</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.rowdict_decorator", "modulename": "doctable.schema.rowdictschema.rowdict_decorator", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.rowdictschema.rowdict_decorator.schema_experimental", "modulename": "doctable.schema.rowdictschema.rowdict_decorator", "qualname": "schema_experimental", "kind": "function", "doc": "<p>A decorator to change a regular class into a schema object class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">_Cls</span><span class=\"p\">:</span> <span class=\"nb\">type</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">attrs_kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">type</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.rowdict_decorator.rowdict_decorator_factory", "modulename": "doctable.schema.rowdictschema.rowdict_decorator", "qualname": "rowdict_decorator_factory", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">attrs_kwargs</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">type</span><span class=\"p\">],</span> <span class=\"nb\">type</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.rowdict_decorator.get_getter_setter_rowdict", "modulename": "doctable.schema.rowdictschema.rowdict_decorator", "qualname": "get_getter_setter_rowdict", "kind": "function", "doc": "<p>Returns a new getter/setter method that simply edits an underlying dict.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">property_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema.RowDictSchema", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "qualname": "RowDictSchema", "kind": "class", "doc": "<p>Contains info about the db schema and methods to convert to/from schema objects.</p>\n", "bases": "doctable.schema.schemabase.SchemaBase"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema.RowDictSchema.__init__", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "qualname": "RowDictSchema.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">schema_class</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">rowdictschema</span><span class=\"o\">.</span><span class=\"n\">schemaobject</span><span class=\"o\">.</span><span class=\"n\">SchemaObject</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">columns</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">Index</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">constraints</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Constraint</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema.RowDictSchema.schema_class", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "qualname": "RowDictSchema.schema_class", "kind": "variable", "doc": "<p></p>\n", "annotation": ": type[doctable.schema.rowdictschema.schemaobject.SchemaObject]"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema.RowDictSchema.columns", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "qualname": "RowDictSchema.columns", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[sqlalchemy.sql.schema.Column]"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema.RowDictSchema.indices", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "qualname": "RowDictSchema.indices", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Tuple[doctable.schema.dataclassschema.index.Index]"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema.RowDictSchema.constraints", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "qualname": "RowDictSchema.constraints", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Tuple[Constraint]"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema.RowDictSchema.from_schema_definition", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "qualname": "RowDictSchema.from_schema_definition", "kind": "function", "doc": "<p>Convert a dataclass definition to a list of sqlalchemy columns.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">schema_class</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">rowdictschema</span><span class=\"o\">.</span><span class=\"n\">schemaobject</span><span class=\"o\">.</span><span class=\"n\">SchemaObject</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">Index</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">constraints</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Constraint</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema.RowDictSchema.object_to_dict", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "qualname": "RowDictSchema.object_to_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">rowdictschema</span><span class=\"o\">.</span><span class=\"n\">schemaobject</span><span class=\"o\">.</span><span class=\"n\">SchemaObject</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema.RowDictSchema.row_to_object", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "qualname": "RowDictSchema.row_to_object", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">row</span><span class=\"p\">:</span> <span class=\"s1\">&#39;sqlalchemy.engine.row.LegacyRow&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema.RowDictSchema.parse_columns", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "qualname": "RowDictSchema.parse_columns", "kind": "function", "doc": "<p>Convert the dataclass member variables to sqlalchemy columns.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Cls</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema.RowDictSchema.parse_indices", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "qualname": "RowDictSchema.parse_indices", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">indices</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.rowdict_schema.RowDictSchema.parse_constraints", "modulename": "doctable.schema.rowdictschema.rowdict_schema", "qualname": "RowDictSchema.parse_constraints", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">constraints</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.schemaobject", "modulename": "doctable.schema.rowdictschema.schemaobject", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.rowdictschema.schemaobject.SchemaObject", "modulename": "doctable.schema.rowdictschema.schemaobject", "qualname": "SchemaObject", "kind": "class", "doc": "<p>Base class of a schema object, inherited in the decorator.\nAs well as defining an object type for type hints later,\n    this method also provides some convenience methods.</p>\n"}, {"fullname": "doctable.schema.rowdictschema.schemaobject.SchemaObject.from_dict", "modulename": "doctable.schema.rowdictschema.schemaobject", "qualname": "SchemaObject.from_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">Dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.schemaobject.SchemaObject.v", "modulename": "doctable.schema.rowdictschema.schemaobject", "qualname": "SchemaObject.v", "kind": "function", "doc": "<p>Get property, bypassing error if property doesn't exist.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.schemaobject.SchemaObject.get_val", "modulename": "doctable.schema.rowdictschema.schemaobject", "qualname": "SchemaObject.get_val", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.schemaobject.SchemaObject.get_val_default", "modulename": "doctable.schema.rowdictschema.schemaobject", "qualname": "SchemaObject.get_val_default", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">default</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.schemaobject.SchemaObject.asdict", "modulename": "doctable.schema.rowdictschema.schemaobject", "qualname": "SchemaObject.asdict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.schemaobject.SchemaObject.astuple", "modulename": "doctable.schema.rowdictschema.schemaobject", "qualname": "SchemaObject.astuple", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.rowdictschema.schemaobject.SchemaObject.attr_is_available", "modulename": "doctable.schema.rowdictschema.schemaobject", "qualname": "SchemaObject.attr_is_available", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.schemabase", "modulename": "doctable.schema.schemabase", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.schemabase.SchemaBase", "modulename": "doctable.schema.schemabase", "qualname": "SchemaBase", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.schemabase.SchemaBase.schema_class", "modulename": "doctable.schema.schemabase", "qualname": "SchemaBase.schema_class", "kind": "variable", "doc": "<p></p>\n", "annotation": ": type[doctable.schema.dataclassschema.doctableschema.DocTableSchema]"}, {"fullname": "doctable.schema.schemabase.SchemaBase.object_to_dict_interface", "modulename": "doctable.schema.schemabase", "qualname": "SchemaBase.object_to_dict_interface", "kind": "function", "doc": "<p>Wraps implementation of object_to_dict to raise exception if there is a conversion problem.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.schemabase.SchemaBase.row_to_object_interface", "modulename": "doctable.schema.schemabase", "qualname": "SchemaBase.row_to_object_interface", "kind": "function", "doc": "<p>Wraps implementation of row_to_object to raise exception if there is a conversion problem.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"s1\">&#39;sqlalchemy.engine.row.LegacyRow&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">dataclassschema</span><span class=\"o\">.</span><span class=\"n\">doctableschema</span><span class=\"o\">.</span><span class=\"n\">DocTableSchema</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.schemabase.SchemaBase.from_schema_definition", "modulename": "doctable.schema.schemabase", "qualname": "SchemaBase.from_schema_definition", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">schemabase</span><span class=\"o\">.</span><span class=\"n\">SchemaBase</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.schemabase.SchemaBase.object_to_dict", "modulename": "doctable.schema.schemabase", "qualname": "SchemaBase.object_to_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.schemabase.SchemaBase.row_to_object", "modulename": "doctable.schema.schemabase", "qualname": "SchemaBase.row_to_object", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"s1\">&#39;sqlalchemy.engine.row.LegacyRow&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.sentinels", "modulename": "doctable.schema.sentinels", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.sentinels.MissingValueSentinel", "modulename": "doctable.schema.sentinels", "qualname": "MissingValueSentinel", "kind": "class", "doc": "<p>Create a collection of name/value pairs.</p>\n\n<p>Example enumeration:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">class</span> <span class=\"nc\">Color</span><span class=\"p\">(</span><span class=\"n\">Enum</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"n\">RED</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"gp\">... </span>    <span class=\"n\">BLUE</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"gp\">... </span>    <span class=\"n\">GREEN</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n</code></pre>\n</div>\n\n<p>Access them by:</p>\n\n<ul>\n<li>attribute access::</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Color</span><span class=\"o\">.</span><span class=\"n\">RED</span>\n<span class=\"go\">&lt;Color.RED: 1&gt;</span>\n</code></pre>\n</div>\n\n<ul>\n<li>value lookup:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Color</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">&lt;Color.RED: 1&gt;</span>\n</code></pre>\n</div>\n\n<ul>\n<li>name lookup:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Color</span><span class=\"p\">[</span><span class=\"s1\">&#39;RED&#39;</span><span class=\"p\">]</span>\n<span class=\"go\">&lt;Color.RED: 1&gt;</span>\n</code></pre>\n</div>\n\n<p>Enumerations can be iterated over, and know how many members they have:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">Color</span><span class=\"p\">)</span>\n<span class=\"go\">3</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">Color</span><span class=\"p\">)</span>\n<span class=\"go\">[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]</span>\n</code></pre>\n</div>\n\n<p>Methods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details.</p>\n", "bases": "enum.Enum"}, {"fullname": "doctable.schema.sentinels.MissingValueSentinel.MISSING_VALUE", "modulename": "doctable.schema.sentinels", "qualname": "MissingValueSentinel.MISSING_VALUE", "kind": "variable", "doc": "<p></p>\n", "default_value": "MISSING"}, {"fullname": "doctable.schema.sentinels.MISSING_VALUE", "modulename": "doctable.schema.sentinels", "qualname": "MISSING_VALUE", "kind": "variable", "doc": "<p>Used to represent missing data when None is ambiguous.</p>\n", "default_value": "MISSING"}, {"fullname": "doctable.schema.sentinels.NothingSentinel", "modulename": "doctable.schema.sentinels", "qualname": "NothingSentinel", "kind": "class", "doc": "<p>Create a collection of name/value pairs.</p>\n\n<p>Example enumeration:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">class</span> <span class=\"nc\">Color</span><span class=\"p\">(</span><span class=\"n\">Enum</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"n\">RED</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"gp\">... </span>    <span class=\"n\">BLUE</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"gp\">... </span>    <span class=\"n\">GREEN</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n</code></pre>\n</div>\n\n<p>Access them by:</p>\n\n<ul>\n<li>attribute access::</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Color</span><span class=\"o\">.</span><span class=\"n\">RED</span>\n<span class=\"go\">&lt;Color.RED: 1&gt;</span>\n</code></pre>\n</div>\n\n<ul>\n<li>value lookup:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Color</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">&lt;Color.RED: 1&gt;</span>\n</code></pre>\n</div>\n\n<ul>\n<li>name lookup:</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">Color</span><span class=\"p\">[</span><span class=\"s1\">&#39;RED&#39;</span><span class=\"p\">]</span>\n<span class=\"go\">&lt;Color.RED: 1&gt;</span>\n</code></pre>\n</div>\n\n<p>Enumerations can be iterated over, and know how many members they have:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">Color</span><span class=\"p\">)</span>\n<span class=\"go\">3</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">Color</span><span class=\"p\">)</span>\n<span class=\"go\">[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]</span>\n</code></pre>\n</div>\n\n<p>Methods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details.</p>\n", "bases": "enum.Enum"}, {"fullname": "doctable.schema.sentinels.NothingSentinel.NOTHING", "modulename": "doctable.schema.sentinels", "qualname": "NothingSentinel.NOTHING", "kind": "variable", "doc": "<p></p>\n", "default_value": "NOTHING"}, {"fullname": "doctable.schema.sentinels.NOTHING", "modulename": "doctable.schema.sentinels", "qualname": "NOTHING", "kind": "variable", "doc": "<p>Used as default when None is ambiguous.</p>\n", "default_value": "NOTHING"}, {"fullname": "doctable.schema.stringschema", "modulename": "doctable.schema.stringschema", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schema.stringschema.StringSchema", "modulename": "doctable.schema.stringschema", "qualname": "StringSchema", "kind": "class", "doc": "<p></p>\n", "bases": "doctable.schema.schemabase.SchemaBase"}, {"fullname": "doctable.schema.stringschema.StringSchema.__init__", "modulename": "doctable.schema.stringschema", "qualname": "StringSchema.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">columns</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">indices</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Index</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">constraints</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">sql</span><span class=\"o\">.</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Constraint</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">schema_list</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "doctable.schema.stringschema.StringSchema.columns", "modulename": "doctable.schema.stringschema", "qualname": "StringSchema.columns", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[sqlalchemy.sql.schema.Column]"}, {"fullname": "doctable.schema.stringschema.StringSchema.indices", "modulename": "doctable.schema.stringschema", "qualname": "StringSchema.indices", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Tuple[sqlalchemy.sql.schema.Index]"}, {"fullname": "doctable.schema.stringschema.StringSchema.constraints", "modulename": "doctable.schema.stringschema", "qualname": "StringSchema.constraints", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Tuple[sqlalchemy.sql.schema.Constraint]"}, {"fullname": "doctable.schema.stringschema.StringSchema.schema_list", "modulename": "doctable.schema.stringschema", "qualname": "StringSchema.schema_list", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[Tuple]"}, {"fullname": "doctable.schema.stringschema.StringSchema.from_schema_definition", "modulename": "doctable.schema.stringschema", "qualname": "StringSchema.from_schema_definition", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">schema_list</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">default_fpath</span><span class=\"o\">=</span><span class=\"s1\">&#39;./&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.stringschema.StringSchema.object_to_dict", "modulename": "doctable.schema.stringschema", "qualname": "StringSchema.object_to_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.stringschema.StringSchema.row_to_object", "modulename": "doctable.schema.stringschema", "qualname": "StringSchema.row_to_object", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.schema.stringschema.StringSchema.parse_schema_strings", "modulename": "doctable.schema.stringschema", "qualname": "StringSchema.parse_schema_strings", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">schema</span>, </span><span class=\"param\"><span class=\"n\">default_fpath</span><span class=\"o\">=</span><span class=\"s1\">&#39;./&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper", "modulename": "doctable.stepper", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.errors", "modulename": "doctable.stepper.errors", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.errors.NoStepsAvailable", "modulename": "doctable.stepper.errors", "qualname": "NoStepsAvailable", "kind": "class", "doc": "<p>Common base class for all exceptions</p>\n", "bases": "builtins.BaseException"}, {"fullname": "doctable.stepper.step", "modulename": "doctable.stepper.step", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.step.Step", "modulename": "doctable.stepper.step", "qualname": "Step", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.step.Step.__init__", "modulename": "doctable.stepper.step", "qualname": "Step.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">msg</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">ts</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span>,</span><span class=\"param\">\t<span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">mem</span><span class=\"p\">:</span> <span class=\"s1\">&#39;psutil.pmem&#39;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "doctable.stepper.step.Step.i", "modulename": "doctable.stepper.step", "qualname": "Step.i", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "doctable.stepper.step.Step.msg", "modulename": "doctable.stepper.step", "qualname": "Step.msg", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.stepper.step.Step.ts", "modulename": "doctable.stepper.step", "qualname": "Step.ts", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.datetime"}, {"fullname": "doctable.stepper.step.Step.pid", "modulename": "doctable.stepper.step", "qualname": "Step.pid", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "doctable.stepper.step.Step.mem", "modulename": "doctable.stepper.step", "qualname": "Step.mem", "kind": "variable", "doc": "<p></p>\n", "annotation": ": &#x27;psutil.pmem&#x27;", "default_value": "None"}, {"fullname": "doctable.stepper.step.Step.now", "modulename": "doctable.stepper.step", "qualname": "Step.now", "kind": "function", "doc": "<p>Create a new step based on current timestamp/memory usage.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">msg</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"o\">.</span><span class=\"n\">Step</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.step.Step.current_mem", "modulename": "doctable.stepper.step", "qualname": "Step.current_mem", "kind": "function", "doc": "<p>Get current memory usage.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"s1\">&#39;psutil.pmem&#39;</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.step.Step.current_mem_bytes", "modulename": "doctable.stepper.step", "qualname": "Step.current_mem_bytes", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.step.Step.ts_diff", "modulename": "doctable.stepper.step", "qualname": "Step.ts_diff", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"o\">.</span><span class=\"n\">Step</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.step.Step.mem_bytes", "modulename": "doctable.stepper.step", "qualname": "Step.mem_bytes", "kind": "variable", "doc": "<p>Get memory usage in bytes.</p>\n", "annotation": ": int"}, {"fullname": "doctable.stepper.step_new", "modulename": "doctable.stepper.step_new", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.step_new.Step", "modulename": "doctable.stepper.step_new", "qualname": "Step", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.step_new.Step.__init__", "modulename": "doctable.stepper.step_new", "qualname": "Step.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">msg</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">ts</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;datetime&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/home/devin/anaconda3/lib/python3.11/datetime.py&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">mem</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "doctable.stepper.step_new.Step.i", "modulename": "doctable.stepper.step_new", "qualname": "Step.i", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "doctable.stepper.step_new.Step.msg", "modulename": "doctable.stepper.step_new", "qualname": "Step.msg", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.stepper.step_new.Step.ts", "modulename": "doctable.stepper.step_new", "qualname": "Step.ts", "kind": "variable", "doc": "<p></p>\n", "annotation": ": &lt;module &#x27;datetime&#x27; from &#x27;/home/devin/anaconda3/lib/python3.11/datetime.py&#x27;&gt;"}, {"fullname": "doctable.stepper.step_new.Step.mem", "modulename": "doctable.stepper.step_new", "qualname": "Step.mem", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "doctable.stepper.step_new.Step.now", "modulename": "doctable.stepper.step_new", "qualname": "Step.now", "kind": "function", "doc": "<p>Create a new step based on current timestamp/memory usage.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">msg</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">step_new</span><span class=\"o\">.</span><span class=\"n\">Step</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.step_new.Step.mem_used", "modulename": "doctable.stepper.step_new", "qualname": "Step.mem_used", "kind": "variable", "doc": "<p>Memory usage at the start of this step.</p>\n", "annotation": ": int"}, {"fullname": "doctable.stepper.step_new.Step.ts_diff", "modulename": "doctable.stepper.step_new", "qualname": "Step.ts_diff", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">step_new</span><span class=\"o\">.</span><span class=\"n\">Step</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.step_new.Step.format", "modulename": "doctable.stepper.step_new", "qualname": "Step.format", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">prev_step</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">step_new</span><span class=\"o\">.</span><span class=\"n\">Step</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">show_ts</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_delta</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_mem</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepcontext", "modulename": "doctable.stepper.stepcontext", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepcontext.StepContext", "modulename": "doctable.stepper.stepcontext", "qualname": "StepContext", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepcontext.StepContext.__init__", "modulename": "doctable.stepper.stepcontext", "qualname": "StepContext.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">stepper</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">Stepper</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"o\">.</span><span class=\"n\">Step</span>,</span><span class=\"param\">\t<span class=\"n\">format_kwargs</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "doctable.stepper.stepcontext.StepContext.stepper", "modulename": "doctable.stepper.stepcontext", "qualname": "StepContext.stepper", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.stepper.stepper.Stepper"}, {"fullname": "doctable.stepper.stepcontext.StepContext.step", "modulename": "doctable.stepper.stepcontext", "qualname": "StepContext.step", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.stepper.step.Step"}, {"fullname": "doctable.stepper.stepcontext.StepContext.format_kwargs", "modulename": "doctable.stepper.stepcontext", "qualname": "StepContext.format_kwargs", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Dict[str, bool]"}, {"fullname": "doctable.stepper.stepcontext.StepContext.start", "modulename": "doctable.stepper.stepcontext", "qualname": "StepContext.start", "kind": "variable", "doc": "<p>Starting datetime.</p>\n", "annotation": ": datetime.datetime"}, {"fullname": "doctable.stepper.stepcontext.StepContext.start_memory", "modulename": "doctable.stepper.stepcontext", "qualname": "StepContext.start_memory", "kind": "variable", "doc": "<p>Memory usage at the start of this step.</p>\n", "annotation": ": int"}, {"fullname": "doctable.stepper.stepcontext.StepContext.elapsed", "modulename": "doctable.stepper.stepcontext", "qualname": "StepContext.elapsed", "kind": "function", "doc": "<p>Get difference between now and the starting time.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepcontext.StepContext.memory_change", "modulename": "doctable.stepper.stepcontext", "qualname": "StepContext.memory_change", "kind": "function", "doc": "<p>Change in memory usage, in Bytes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepcontext.StepContext.start_memory_str", "modulename": "doctable.stepper.stepcontext", "qualname": "StepContext.start_memory_str", "kind": "function", "doc": "<p>Memory usage at the start of this step.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepcontext.StepContext.elapsed_str", "modulename": "doctable.stepper.stepcontext", "qualname": "StepContext.elapsed_str", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepcontext.StepContext.memory_change_str", "modulename": "doctable.stepper.stepcontext", "qualname": "StepContext.memory_change_str", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper", "modulename": "doctable.stepper.stepper", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper.Stepper", "modulename": "doctable.stepper.stepper", "qualname": "Stepper", "kind": "class", "doc": "<p>Record information and output info as script progresses.</p>\n"}, {"fullname": "doctable.stepper.stepper.Stepper.__init__", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">log_fname</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">new_log</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_ts</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_delta</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_mem</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">using_tqdm</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">init_step</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"o\">.</span><span class=\"n\">Step</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">steps</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"o\">.</span><span class=\"n\">Step</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">ctx_stack</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">stepcontext</span><span class=\"o\">.</span><span class=\"n\">StepContext</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "doctable.stepper.stepper.Stepper.log_fname", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.log_fname", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "None"}, {"fullname": "doctable.stepper.stepper.Stepper.name", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "None"}, {"fullname": "doctable.stepper.stepper.Stepper.new_log", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.new_log", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "doctable.stepper.stepper.Stepper.verbose", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.verbose", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "True"}, {"fullname": "doctable.stepper.stepper.Stepper.show_ts", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.show_ts", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "True"}, {"fullname": "doctable.stepper.stepper.Stepper.show_delta", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.show_delta", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "True"}, {"fullname": "doctable.stepper.stepper.Stepper.show_mem", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.show_mem", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "True"}, {"fullname": "doctable.stepper.stepper.Stepper.using_tqdm", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.using_tqdm", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "doctable.stepper.stepper.Stepper.init_step", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.init_step", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.stepper.step.Step"}, {"fullname": "doctable.stepper.stepper.Stepper.steps", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.steps", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[doctable.stepper.step.Step]"}, {"fullname": "doctable.stepper.stepper.Stepper.ctx_stack", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.ctx_stack", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[doctable.stepper.stepcontext.StepContext]"}, {"fullname": "doctable.stepper.stepper.Stepper.last", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.last", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.stepper.step.Step"}, {"fullname": "doctable.stepper.stepper.Stepper.first", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.first", "kind": "variable", "doc": "<p></p>\n", "annotation": ": doctable.stepper.step.Step"}, {"fullname": "doctable.stepper.stepper.Stepper.step", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.step", "kind": "function", "doc": "<p>Add a new step, print and log it if needed.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">format_kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">stepcontext</span><span class=\"o\">.</span><span class=\"n\">StepContext</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper.Stepper.print_step", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.print_step", "kind": "function", "doc": "<p>Write to log and print to screen if needed.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"o\">.</span><span class=\"n\">Step</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">format_kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper.Stepper.write_log", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.write_log", "kind": "function", "doc": "<p>Write text to log file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper.Stepper.rm_log", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.rm_log", "kind": "function", "doc": "<p>Delete log file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper.Stepper.format_step_str", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.format_step_str", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"o\">.</span><span class=\"n\">Step</span>,</span><span class=\"param\">\t<span class=\"n\">prev_step</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"o\">.</span><span class=\"n\">Step</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">show_ts</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_delta</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_mem</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper.Stepper.tqdm", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.tqdm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper.Stepper.get_diff_stat", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.get_diff_stat", "kind": "function", "doc": "<p>Get stats on differences between time points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>stat:</strong>  name of function in \"statistics\" module to call</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">stat</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;mean&#39;</span>, </span><span class=\"param\"><span class=\"n\">as_str</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper.Stepper.time_call", "modulename": "doctable.stepper.stepper", "qualname": "Stepper.time_call", "kind": "function", "doc": "<p>Time function call with 0.05 ms latency per call.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">args</span>,</span><span class=\"param\">\t<span class=\"n\">num_calls</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">as_str</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper_new", "modulename": "doctable.stepper.stepper_new", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper", "kind": "class", "doc": "<p>Replaces Timer: logs info about script progresion.</p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper.__init__", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.__init__", "kind": "function", "doc": "<p>Add single step for current datetime.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">logfile</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">new_log</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_ts</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_delta</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_mem</span><span class=\"o\">=</span><span class=\"kc\">True</span></span>)</span>"}, {"fullname": "doctable.stepper.stepper_new.Stepper.name", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper.logfile", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.logfile", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper.show_ts", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.show_ts", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper.show_delta", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.show_delta", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper.show_mem", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.show_mem", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper.verbose", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.verbose", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper.steps", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.steps", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper.init_step", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.init_step", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper.context_stack", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.context_stack", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper.last", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.last", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper.first", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.first", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.stepper_new.Stepper.step", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.step", "kind": "function", "doc": "<p>Add a new step, print and log it if needed.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">format_args</span></span><span class=\"return-annotation\">) -> <span class=\"s1\">&#39;StepContext&#39;</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper_new.Stepper.log_step", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.log_step", "kind": "function", "doc": "<p>Add this step to the log and print to screen if requested.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">step</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"o\">.</span><span class=\"n\">Step</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">format_args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper_new.Stepper.write_log", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.write_log", "kind": "function", "doc": "<p>Write text to log file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper_new.Stepper.rm_log", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.rm_log", "kind": "function", "doc": "<p>Delete log file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper_new.Stepper.get_diff_stat", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.get_diff_stat", "kind": "function", "doc": "<p>Get stats on differences between time points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>stat:</strong>  name of function in \"statistics\" module to call</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">stat</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;mean&#39;</span>, </span><span class=\"param\"><span class=\"n\">as_str</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.stepper_new.Stepper.time_call", "modulename": "doctable.stepper.stepper_new", "qualname": "Stepper.time_call", "kind": "function", "doc": "<p>Time function call with 0.05 ms latency per call.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">num_calls</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">as_str</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.stepper.timer", "modulename": "doctable.stepper.timer", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.stepper.timer.Timer", "modulename": "doctable.stepper.timer", "qualname": "Timer", "kind": "class", "doc": "<p>For backwards compatibility purposes ONLY.</p>\n", "bases": "doctable.stepper.stepper.Stepper"}, {"fullname": "doctable.stepper.timer.Timer.__init__", "modulename": "doctable.stepper.timer", "qualname": "Timer.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "doctable.textmodels", "modulename": "doctable.textmodels", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.basedoc", "modulename": "doctable.textmodels.basedoc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.basedoc.BaseDoc", "modulename": "doctable.textmodels.basedoc", "qualname": "BaseDoc", "kind": "class", "doc": "<p>Built-in mutable sequence.</p>\n\n<p>If no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.</p>\n", "bases": "builtins.list"}, {"fullname": "doctable.textmodels.bowdoc", "modulename": "doctable.textmodels.bowdoc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.bowdoc.TokenDoc", "modulename": "doctable.textmodels.bowdoc", "qualname": "TokenDoc", "kind": "class", "doc": "<p>Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"s1\">&#39;abcdeabcdabcaba&#39;</span><span class=\"p\">)</span>  <span class=\"c1\"># count elements from a string</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">most_common</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>                <span class=\"c1\"># three most common elements</span>\n<span class=\"go\">[(&#39;a&#39;, 5), (&#39;b&#39;, 4), (&#39;c&#39;, 3)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span>                       <span class=\"c1\"># list all unique elements</span>\n<span class=\"go\">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s1\">&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"p\">()))</span>   <span class=\"c1\"># list elements with repetitions</span>\n<span class=\"go\">&#39;aaaaabbbbcccdde&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())</span>                 <span class=\"c1\"># total of all counts</span>\n<span class=\"go\">15</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">]</span>                          <span class=\"c1\"># count of letter &#39;a&#39;</span>\n<span class=\"go\">5</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">elem</span> <span class=\"ow\">in</span> <span class=\"s1\">&#39;shazam&#39;</span><span class=\"p\">:</span>           <span class=\"c1\"># update counts from an iterable</span>\n<span class=\"gp\">... </span>    <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"n\">elem</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>                <span class=\"c1\"># by adding 1 to each element&#39;s count</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">]</span>                          <span class=\"c1\"># now there are seven &#39;a&#39;</span>\n<span class=\"go\">7</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">del</span> <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;b&#39;</span><span class=\"p\">]</span>                      <span class=\"c1\"># remove all &#39;b&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;b&#39;</span><span class=\"p\">]</span>                          <span class=\"c1\"># now there are zero &#39;b&#39;</span>\n<span class=\"go\">0</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"s1\">&#39;simsalabim&#39;</span><span class=\"p\">)</span>       <span class=\"c1\"># make another counter</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">)</span>                     <span class=\"c1\"># add in the second counter</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">]</span>                          <span class=\"c1\"># now there are nine &#39;a&#39;</span>\n<span class=\"go\">9</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">clear</span><span class=\"p\">()</span>                       <span class=\"c1\"># empty the counter</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span>\n<span class=\"go\">Counter()</span>\n</code></pre>\n</div>\n\n<p>Note:  If a count is set to zero or reduced to zero, it will remain\nin the counter until the entry is deleted or the counter is cleared:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"s1\">&#39;aaabbc&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;b&#39;</span><span class=\"p\">]</span> <span class=\"o\">-=</span> <span class=\"mi\">2</span>                     <span class=\"c1\"># reduce the count of &#39;b&#39; by two</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">most_common</span><span class=\"p\">()</span>                 <span class=\"c1\"># &#39;b&#39; is still in, but its count is zero</span>\n<span class=\"go\">[(&#39;a&#39;, 3), (&#39;c&#39;, 1), (&#39;b&#39;, 0)]</span>\n</code></pre>\n</div>\n", "bases": "collections.Counter"}, {"fullname": "doctable.textmodels.bowdoc.TokenDoc.toks", "modulename": "doctable.textmodels.bowdoc", "qualname": "TokenDoc.toks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.exceptions", "modulename": "doctable.textmodels.exceptions", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.exceptions.DocTableExceptBase", "modulename": "doctable.textmodels.exceptions", "qualname": "DocTableExceptBase", "kind": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "builtins.Exception"}, {"fullname": "doctable.textmodels.exceptions.MissingSpacyPipelineComponent", "modulename": "doctable.textmodels.exceptions", "qualname": "MissingSpacyPipelineComponent", "kind": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "DocTableExceptBase"}, {"fullname": "doctable.textmodels.exceptions.MissingSpacyPipelineComponent.message", "modulename": "doctable.textmodels.exceptions", "qualname": "MissingSpacyPipelineComponent.message", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;Both the Spacy tagger and parser must be enabled to make a ParseTree.&#x27;"}, {"fullname": "doctable.textmodels.exceptions.TreeAlreadyAssigned", "modulename": "doctable.textmodels.exceptions", "qualname": "TreeAlreadyAssigned", "kind": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "DocTableExceptBase"}, {"fullname": "doctable.textmodels.exceptions.TreeAlreadyAssigned.message", "modulename": "doctable.textmodels.exceptions", "qualname": "TreeAlreadyAssigned.message", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;Current token already contains reference to a ParseTree.&#x27;"}, {"fullname": "doctable.textmodels.exceptions.PropertyNotAvailable", "modulename": "doctable.textmodels.exceptions", "qualname": "PropertyNotAvailable", "kind": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "builtins.Exception"}, {"fullname": "doctable.textmodels.exceptions.PropertyNotAvailable.__init__", "modulename": "doctable.textmodels.exceptions", "qualname": "PropertyNotAvailable.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">prop</span>, </span><span class=\"param\"><span class=\"n\">parsefeatname</span></span>)</span>"}, {"fullname": "doctable.textmodels.exceptions.PropertyNotAvailable.template", "modulename": "doctable.textmodels.exceptions", "qualname": "PropertyNotAvailable.template", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;{prop} is not available in Token because {parsefeatname} was not enabled while processing with Spacy.&#x27;"}, {"fullname": "doctable.textmodels.parsetree", "modulename": "doctable.textmodels.parsetree", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.parsetree.ParseTree", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree", "kind": "class", "doc": "<p>Represents a single parsetree.</p>\n\n<h6 id=\"properties\">Properties:</h6>\n\n<blockquote>\n  <p>root (Token): reference to root of parsetree\n  tokens list[Token]: ordered list of tokens</p>\n</blockquote>\n"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.__init__", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.__init__", "kind": "function", "doc": "<p>Create from dict parsetree or spacy sentence root.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>root_token (doctable.Token):</strong>  root token of parsetree.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">root_token</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">textmodels</span><span class=\"o\">.</span><span class=\"n\">token</span><span class=\"o\">.</span><span class=\"n\">Token</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite_tree</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.root", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.root", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.tokens", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.tokens", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.propogate_tree_ref", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.propogate_tree_ref", "kind": "function", "doc": "<p>Recursively adds reference to current tree.</p>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>TreeAlreadyAssigned:</strong>  if the given token already \nmaintains a reference to another tree. A token\ncan be assigned to only a single ParseTree.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tok</span>, </span><span class=\"param\"><span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.get_token_list", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.get_token_list", "kind": "function", "doc": "<p>Return ordered list of tokens.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.from_spacy", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.from_spacy", "kind": "function", "doc": "<p>Create new parsetree from spacy doc.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spacy_sent:</strong>  Spacy sent object.</li>\n<li><strong>args:</strong>  passed to Token.from_spacy()</li>\n<li><strong>kwargs:</strong>  passed to Token.from_spacy()</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">spacy_sent</span><span class=\"p\">:</span> <span class=\"n\">Any</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.from_dict", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.from_dict", "kind": "function", "doc": "<p>Create new ParseTree from a dictionary tree created by as_dict().</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>root_tok_data:</strong>  dict tree created from .as_dict()</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">root_tok_data</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.from_pickle", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.from_pickle", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">pickle_data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.as_dict", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.as_dict", "kind": "function", "doc": "<p>Convert to a dictionary tree.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.as_pickle", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.as_pickle", "kind": "function", "doc": "<p>Return a pickled dictionary tree.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.token_texts", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.token_texts", "kind": "function", "doc": "<p>List of token strings.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.display", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.display", "kind": "function", "doc": "<p>TODO Print out an ascii tree.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pad</span><span class=\"o\">=</span><span class=\"mi\">15</span>, </span><span class=\"param\"><span class=\"n\">base</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.print_tree_recursive", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.print_tree_recursive", "kind": "function", "doc": "<p>TODO Printing tree for visualization.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">tok</span>,</span><span class=\"param\">\t<span class=\"n\">pad</span>,</span><span class=\"param\">\t<span class=\"n\">base</span>,</span><span class=\"param\">\t<span class=\"n\">level</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">root_str</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">{text}</span><span class=\"s1\">&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dep_str</span><span class=\"o\">=</span><span class=\"s1\">&#39; -</span><span class=\"si\">{dep}</span><span class=\"s1\">&gt; </span><span class=\"si\">{text}</span><span class=\"s1\">&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetreedoc", "modulename": "doctable.textmodels.parsetreedoc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.parsetreedoc.ParseTreeDoc", "modulename": "doctable.textmodels.parsetreedoc", "qualname": "ParseTreeDoc", "kind": "class", "doc": "<p>Represents a document composed of sequence of parsetrees.</p>\n", "bases": "builtins.list"}, {"fullname": "doctable.textmodels.parsetreedoc.ParseTreeDoc.tokens", "modulename": "doctable.textmodels.parsetreedoc", "qualname": "ParseTreeDoc.tokens", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.parsetreedoc.ParseTreeDoc.as_dict", "modulename": "doctable.textmodels.parsetreedoc", "qualname": "ParseTreeDoc.as_dict", "kind": "function", "doc": "<p>Convert document into a list of dict-formatted parsetrees.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetreedoc.ParseTreeDoc.from_dict", "modulename": "doctable.textmodels.parsetreedoc", "qualname": "ParseTreeDoc.from_dict", "kind": "function", "doc": "<p>Create new ParseTreeDoc from a dictionary tree created by as_dict().</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tree_data:</strong>  list of dict trees created from cls.as_dict()</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">tree_data</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetreedoc.ParseTreeDoc.from_spacy", "modulename": "doctable.textmodels.parsetreedoc", "qualname": "ParseTreeDoc.from_spacy", "kind": "function", "doc": "<p>Create a new ParseTreeDoc from a spacy Doc object.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">doc</span><span class=\"p\">:</span> <span class=\"n\">Any</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.senttokendoc", "modulename": "doctable.textmodels.senttokendoc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.senttokendoc.SentTokenDoc", "modulename": "doctable.textmodels.senttokendoc", "qualname": "SentTokenDoc", "kind": "class", "doc": "<p>Built-in mutable sequence.</p>\n\n<p>If no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.</p>\n", "bases": "builtins.list"}, {"fullname": "doctable.textmodels.senttokendoc.SentTokenDoc.toks", "modulename": "doctable.textmodels.senttokendoc", "qualname": "SentTokenDoc.toks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token", "modulename": "doctable.textmodels.token", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token.Token", "modulename": "doctable.textmodels.token", "qualname": "Token", "kind": "class", "doc": "<p>Object representing a single token.</p>\n\n<h6 id=\"attrs\">Attrs:</h6>\n\n<blockquote>\n  <p>i: index of token in original sentence\n  text: text representation of token\n  dep: dependency relation estimated in spacy\n  tag: dependency tag estimated by spacy\n  childs: list of children Tokens\n  tree: reference to associated parsetree\n  otherdata: containes 'pos' and 'ent' data from spacy\n  userdata: data provided by user (usually generated \n      from userdata_map in from_spacy()).\n  parent: reference to parent Token (populated in \n      __post_init__).</p>\n</blockquote>\n"}, {"fullname": "doctable.textmodels.token.Token.__init__", "modulename": "doctable.textmodels.token", "qualname": "Token.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">dep</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">tag</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">childs</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">otherdata</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">userdata</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">tree</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">parent</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "doctable.textmodels.token.Token.i", "modulename": "doctable.textmodels.token", "qualname": "Token.i", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "doctable.textmodels.token.Token.text", "modulename": "doctable.textmodels.token", "qualname": "Token.text", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.textmodels.token.Token.dep", "modulename": "doctable.textmodels.token", "qualname": "Token.dep", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.textmodels.token.Token.tag", "modulename": "doctable.textmodels.token", "qualname": "Token.tag", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.textmodels.token.Token.childs", "modulename": "doctable.textmodels.token", "qualname": "Token.childs", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list"}, {"fullname": "doctable.textmodels.token.Token.otherdata", "modulename": "doctable.textmodels.token", "qualname": "Token.otherdata", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict"}, {"fullname": "doctable.textmodels.token.Token.userdata", "modulename": "doctable.textmodels.token", "qualname": "Token.userdata", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict"}, {"fullname": "doctable.textmodels.token.Token.tree", "modulename": "doctable.textmodels.token", "qualname": "Token.tree", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Any", "default_value": "None"}, {"fullname": "doctable.textmodels.token.Token.parent", "modulename": "doctable.textmodels.token", "qualname": "Token.parent", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Any", "default_value": "None"}, {"fullname": "doctable.textmodels.token.Token.from_spacy", "modulename": "doctable.textmodels.token", "qualname": "Token.from_spacy", "kind": "function", "doc": "<p>Return tokens recursively from spacy_tok object.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spacy_tok:</strong>  token to extract userdata from</li>\n<li><strong>text_parse_func:</strong>  mapping to store text data</li>\n<li><strong>userdata_map:</strong>  used to create custom user data</li>\n<li><strong>tree (doctable.parse.ParseTree):</strong>  reference to associated ParseTree</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">spacy_tok</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">text_parse_func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">Token</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">userdata_map</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">parent</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">textmodels</span><span class=\"o\">.</span><span class=\"n\">token</span><span class=\"o\">.</span><span class=\"n\">Token</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tree</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">textmodels</span><span class=\"o\">.</span><span class=\"n\">token</span><span class=\"o\">.</span><span class=\"n\">Token</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.from_dict", "modulename": "doctable.textmodels.token", "qualname": "Token.from_dict", "kind": "function", "doc": "<p>Create new token recursively using a dictionary tree structure.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tok_data:</strong>  dictionary containing current token information</li>\n<li><strong>tree (ParseTree):</strong>  reference to associated parsetree</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">tok_data</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">tree</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.set_tree", "modulename": "doctable.textmodels.token", "qualname": "Token.set_tree", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tree</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.as_dict", "modulename": "doctable.textmodels.token", "qualname": "Token.as_dict", "kind": "function", "doc": "<p>Convert self to a dict tree - used when storing data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.is_root", "modulename": "doctable.textmodels.token", "qualname": "Token.is_root", "kind": "variable", "doc": "<p>Check if token is root or not.</p>\n"}, {"fullname": "doctable.textmodels.token.Token.pos", "modulename": "doctable.textmodels.token", "qualname": "Token.pos", "kind": "variable", "doc": "<p>Access pos data.</p>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>PropertyNotAvailable:</strong>  pos was not included in original spacy object.</li>\n</ul>\n"}, {"fullname": "doctable.textmodels.token.Token.ent", "modulename": "doctable.textmodels.token", "qualname": "Token.ent", "kind": "variable", "doc": "<p>Access ent data.</p>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>PropertyNotAvailable:</strong>  ent was not included in original spacy object.</li>\n</ul>\n"}, {"fullname": "doctable.textmodels.token.Token.get_childs", "modulename": "doctable.textmodels.token", "qualname": "Token.get_childs", "kind": "function", "doc": "<p>Get children with the specified relations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dep (sequence or string):</strong>  dependency relations to match on.</li>\n<li><strong>pos (sequence or string):</strong>  pos to match on.</li>\n<li><strong>matchfunc (function or None):</strong>  additional custom matching function.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dep</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">pos</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">matchfunc</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.get_child", "modulename": "doctable.textmodels.token", "qualname": "Token.get_child", "kind": "function", "doc": "<p>Get first child with the given dependency relation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>*args:</strong>  passed to get_childs</li>\n<li><strong>allow_multiple:</strong>  don't allow </li>\n<li><strong>**kwargs:</strong>  passed to get_childs</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li>ValueError when the token has more than one dependency with the \ngiven relation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">allow_multiple</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.get_preps", "modulename": "doctable.textmodels.token", "qualname": "Token.get_preps", "kind": "function", "doc": "<p>Gets chained prepositional phrases starting at the current token.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple of prep, pobj.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">as_str</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.bubble_accum", "modulename": "doctable.textmodels.token", "qualname": "Token.bubble_accum", "kind": "function", "doc": "<p>Bubble up results into a list.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>func:</strong>  function that accepts a Token and returns a list\nof results that will be concatenated at each level\nof the tree.</li>\n</ul>\n\n<h6 id=\"example\">Example:</h6>\n\n<blockquote>\n  <p><code>self.bubble_accum(lambda n: [n])</code> would return a list\n      of (unordered) tokens in the tree below the given \n      node.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.textmodels.tokendoc", "modulename": "doctable.textmodels.tokendoc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.tokendoc.TokenDoc", "modulename": "doctable.textmodels.tokendoc", "qualname": "TokenDoc", "kind": "class", "doc": "<p>Built-in mutable sequence.</p>\n\n<p>If no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.</p>\n", "bases": "builtins.list"}, {"fullname": "doctable.textmodels.tokendoc.TokenDoc.toks", "modulename": "doctable.textmodels.tokendoc", "qualname": "TokenDoc.toks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util", "modulename": "doctable.util", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.parse_static_arg", "modulename": "doctable.util", "qualname": "parse_static_arg", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span>,</span><span class=\"param\">\t<span class=\"n\">arg_value</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">arg_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">static_arg_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">default</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"mi\">1321566541214</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.asserts", "modulename": "doctable.util.asserts", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.asserts.assert_set_len_eq", "modulename": "doctable.util.asserts", "qualname": "assert_set_len_eq", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.asserts.assert_set_eq", "modulename": "doctable.util.asserts", "qualname": "assert_set_eq", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.asserts.assert_eq", "modulename": "doctable.util.asserts", "qualname": "assert_eq", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.asserts.assert_neq", "modulename": "doctable.util.asserts", "qualname": "assert_neq", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.asserts.assert_ge", "modulename": "doctable.util.asserts", "qualname": "assert_ge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.asserts.assert_gt", "modulename": "doctable.util.asserts", "qualname": "assert_gt", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.asserts.assert_eq_transform", "modulename": "doctable.util.asserts", "qualname": "assert_eq_transform", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">f</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">],</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.benchmark", "modulename": "doctable.util.benchmark", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.benchmark.BenchResult", "modulename": "doctable.util.benchmark", "qualname": "BenchResult", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.util.benchmark.BenchResult.__init__", "modulename": "doctable.util.benchmark", "qualname": "BenchResult.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">results</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">util</span><span class=\"o\">.</span><span class=\"n\">benchmark</span><span class=\"o\">.</span><span class=\"n\">BenchResultRun</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "doctable.util.benchmark.BenchResult.results", "modulename": "doctable.util.benchmark", "qualname": "BenchResult.results", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[doctable.util.benchmark.BenchResultRun]"}, {"fullname": "doctable.util.benchmark.BenchResult.add_step_context", "modulename": "doctable.util.benchmark", "qualname": "BenchResult.add_step_context", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">step_ctx</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">stepcontext</span><span class=\"o\">.</span><span class=\"n\">StepContext</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.benchmark.BenchResult.elapsed_summary", "modulename": "doctable.util.benchmark", "qualname": "BenchResult.elapsed_summary", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">stat</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">mean</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.benchmark.BenchResult.av_memory", "modulename": "doctable.util.benchmark", "qualname": "BenchResult.av_memory", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.benchmark.BenchResultRun", "modulename": "doctable.util.benchmark", "qualname": "BenchResultRun", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.util.benchmark.BenchResultRun.__init__", "modulename": "doctable.util.benchmark", "qualname": "BenchResultRun.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">elapsed</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span>,</span><span class=\"param\">\t<span class=\"n\">elapsed_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">memory_change</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">memory_change_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "doctable.util.benchmark.BenchResultRun.elapsed", "modulename": "doctable.util.benchmark", "qualname": "BenchResultRun.elapsed", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.timedelta"}, {"fullname": "doctable.util.benchmark.BenchResultRun.elapsed_str", "modulename": "doctable.util.benchmark", "qualname": "BenchResultRun.elapsed_str", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.util.benchmark.BenchResultRun.memory_change", "modulename": "doctable.util.benchmark", "qualname": "BenchResultRun.memory_change", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "doctable.util.benchmark.BenchResultRun.memory_change_str", "modulename": "doctable.util.benchmark", "qualname": "BenchResultRun.memory_change_str", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.util.benchmark.BenchResultRun.from_step_context", "modulename": "doctable.util.benchmark", "qualname": "BenchResultRun.from_step_context", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">step_ctx</span><span class=\"p\">:</span> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">stepper</span><span class=\"o\">.</span><span class=\"n\">stepcontext</span><span class=\"o\">.</span><span class=\"n\">StepContext</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">util</span><span class=\"o\">.</span><span class=\"n\">benchmark</span><span class=\"o\">.</span><span class=\"n\">BenchResult</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.benchmark.Benchmark", "modulename": "doctable.util.benchmark", "qualname": "Benchmark", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.util.benchmark.Benchmark.time_func_call", "modulename": "doctable.util.benchmark", "qualname": "Benchmark.time_func_call", "kind": "function", "doc": "<p>Time function call with 0.05 ms latency per call.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span> <span class=\"o\">=</span> <span class=\"p\">()</span>,</span><span class=\"param\">\t<span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">num_calls</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">as_str</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">show_tqdm</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.chunking", "modulename": "doctable.util.chunking", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.chunking.chunk", "modulename": "doctable.util.chunking", "qualname": "chunk", "kind": "function", "doc": "<p>Break elements into chunks determined by chunk_kwargs sent to .chunk_slice().</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">elements</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span>,</span><span class=\"param\">\t<span class=\"o\">/</span>,</span><span class=\"param\">\t<span class=\"n\">chunk_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">num_chunks</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.chunking.chunk_slice", "modulename": "doctable.util.chunking", "qualname": "chunk_slice", "kind": "function", "doc": "<p>Create slices for chunks of an array of size n.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"o\">/</span>, </span><span class=\"param\"><span class=\"n\">chunk_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">num_chunks</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">slice</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.distribute", "modulename": "doctable.util.distribute", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.distribute.Distribute", "modulename": "doctable.util.distribute", "qualname": "Distribute", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.util.distribute.Distribute.__init__", "modulename": "doctable.util.distribute", "qualname": "Distribute.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">workers</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">override_maxcores</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "doctable.util.distribute.Distribute.pool", "modulename": "doctable.util.distribute", "qualname": "Distribute.pool", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.distribute.Distribute.finished", "modulename": "doctable.util.distribute", "qualname": "Distribute.finished", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.distribute.Distribute.map_chunk", "modulename": "doctable.util.distribute", "qualname": "Distribute.map_chunk", "kind": "function", "doc": "<p>Applies chunk_thread to chunks of elements.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">chunk_thread</span>, </span><span class=\"param\"><span class=\"n\">elements</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">thread_args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.distribute.Distribute.map", "modulename": "doctable.util.distribute", "qualname": "Distribute.map", "kind": "function", "doc": "<p>Map each element to be inserted in a doctable.\nDescription: Used primairly to maintain one doctable instance\n    per thread, but can have no other setup.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>thread_func (func):</strong>  applied to each element</li>\n<li><strong>elements (list&lt;&gt;):</strong>  list of elements</li>\n<li><strong>thread_args:</strong>  Additional args to be sent to each element</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">thread_func</span>, </span><span class=\"param\"><span class=\"n\">elements</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">thread_args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.distributeload", "modulename": "doctable.util.distributeload", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.distributeload.DistributeLoad", "modulename": "doctable.util.distributeload", "qualname": "DistributeLoad", "kind": "class", "doc": "<p>Creates processing pool and gets results alongside everything else.</p>\n"}, {"fullname": "doctable.util.distributeload.DistributeLoad.__init__", "modulename": "doctable.util.distributeload", "qualname": "DistributeLoad.__init__", "kind": "function", "doc": "<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>workers:</strong>  number of workers in process pool.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">workers</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">override_maxcores</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span>)</span>"}, {"fullname": "doctable.util.distributeload.DistributeLoad.pool", "modulename": "doctable.util.distributeload", "qualname": "DistributeLoad.pool", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.distributeload.DistributeLoad.finished", "modulename": "doctable.util.distributeload", "qualname": "DistributeLoad.finished", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.distributeload.WorkerThread", "modulename": "doctable.util.distributeload", "qualname": "WorkerThread", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.util.distributeload.WorkerThread.__init__", "modulename": "doctable.util.distributeload", "qualname": "WorkerThread.__init__", "kind": "function", "doc": "<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>wid:</strong>  workerid of this thread.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">wid</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "doctable.util.distributeload.WorkerThread.wid", "modulename": "doctable.util.distributeload", "qualname": "WorkerThread.wid", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "doctable.util.distributeload.WorkerThread.pid", "modulename": "doctable.util.distributeload", "qualname": "WorkerThread.pid", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "doctable.util.fsstore", "modulename": "doctable.util.fsstore", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.fsstore.FSStore", "modulename": "doctable.util.fsstore", "qualname": "FSStore", "kind": "class", "doc": "<p>Class for storing and retriving records as pickle files.\nUseful in multi-threading applications where a direct database\n    insertion for each process would cause too much blocking.</p>\n"}, {"fullname": "doctable.util.fsstore.FSStore.__init__", "modulename": "doctable.util.fsstore", "qualname": "FSStore.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">folder</span>,</span><span class=\"param\">\t<span class=\"n\">records</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">save_every</span><span class=\"o\">=</span><span class=\"mi\">10000</span>,</span><span class=\"param\">\t<span class=\"n\">seed_range</span><span class=\"o\">=</span><span class=\"mi\">100000000</span>,</span><span class=\"param\">\t<span class=\"n\">check_collision</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">settings_fname</span><span class=\"o\">=</span><span class=\"s1\">&#39;.settings_FSStore.json&#39;</span></span>)</span>"}, {"fullname": "doctable.util.fsstore.FSStore.default_settings", "modulename": "doctable.util.fsstore", "qualname": "FSStore.default_settings", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;readonly&#x27;: False}"}, {"fullname": "doctable.util.fsstore.FSStore.save_every", "modulename": "doctable.util.fsstore", "qualname": "FSStore.save_every", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.fsstore.FSStore.folder", "modulename": "doctable.util.fsstore", "qualname": "FSStore.folder", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.fsstore.FSStore.check_collision", "modulename": "doctable.util.fsstore", "qualname": "FSStore.check_collision", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.fsstore.FSStore.seed_range", "modulename": "doctable.util.fsstore", "qualname": "FSStore.seed_range", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.fsstore.FSStore.settings_fname", "modulename": "doctable.util.fsstore", "qualname": "FSStore.settings_fname", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.fsstore.FSStore.ct", "modulename": "doctable.util.fsstore", "qualname": "FSStore.ct", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.fsstore.FSStore.init_folder", "modulename": "doctable.util.fsstore", "qualname": "FSStore.init_folder", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.set_seed", "modulename": "doctable.util.fsstore", "qualname": "FSStore.set_seed", "kind": "function", "doc": "<p>Set random seeds for filename purposes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.check_readonly", "modulename": "doctable.util.fsstore", "qualname": "FSStore.check_readonly", "kind": "function", "doc": "<p>Raise exception if system set to readonly.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.read_setting", "modulename": "doctable.util.fsstore", "qualname": "FSStore.read_setting", "kind": "function", "doc": "<p>Read file and return value of a particular setting.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.read_settings", "modulename": "doctable.util.fsstore", "qualname": "FSStore.read_settings", "kind": "function", "doc": "<p>Read settings file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.write_settings", "modulename": "doctable.util.fsstore", "qualname": "FSStore.write_settings", "kind": "function", "doc": "<p>Read settings file and update any missing values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">newsettings</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.clear_settings", "modulename": "doctable.util.fsstore", "qualname": "FSStore.clear_settings", "kind": "function", "doc": "<p>Replace settings to defaults.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.insert", "modulename": "doctable.util.fsstore", "qualname": "FSStore.insert", "kind": "function", "doc": "<p>Add a single record.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">record</span>, </span><span class=\"param\"><span class=\"n\">check_readonly</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.dump_file", "modulename": "doctable.util.fsstore", "qualname": "FSStore.dump_file", "kind": "function", "doc": "<p>Save records to file and empty container.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">check_readonly</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.get_fname", "modulename": "doctable.util.fsstore", "qualname": "FSStore.get_fname", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.get_exist_fnames", "modulename": "doctable.util.fsstore", "qualname": "FSStore.get_exist_fnames", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.select_chunks", "modulename": "doctable.util.fsstore", "qualname": "FSStore.select_chunks", "kind": "function", "doc": "<p>Yield records in file-sized chunks.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">loadbar</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.yield_records", "modulename": "doctable.util.fsstore", "qualname": "FSStore.yield_records", "kind": "function", "doc": "<p>Reads pickle records and yields them one at a time.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.select_records", "modulename": "doctable.util.fsstore", "qualname": "FSStore.select_records", "kind": "function", "doc": "<p>Creates list of records from .yield_records()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.delete_records", "modulename": "doctable.util.fsstore", "qualname": "FSStore.delete_records", "kind": "function", "doc": "<p>Delete records (NOT settings or folder).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">force</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.delete_all_completely", "modulename": "doctable.util.fsstore", "qualname": "FSStore.delete_all_completely", "kind": "function", "doc": "<p>Will delete all records and the containing directory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">force</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.io", "modulename": "doctable.util.io", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.io.read_pickle", "modulename": "doctable.util.io", "qualname": "read_pickle", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.io.write_pickle", "modulename": "doctable.util.io", "qualname": "write_pickle", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span>, </span><span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.io.read_json", "modulename": "doctable.util.io", "qualname": "read_json", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.io.write_json", "modulename": "doctable.util.io", "qualname": "write_json", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span>, </span><span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.iterfuncs", "modulename": "doctable.util.iterfuncs", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.iterfuncs.GroupedData", "modulename": "doctable.util.iterfuncs", "qualname": "GroupedData", "kind": "class", "doc": "<p></p>\n", "bases": "typing.Dict[typing.Hashable, typing.Union[typing.List, typing.Dict]]"}, {"fullname": "doctable.util.iterfuncs.GroupedData.group_elements", "modulename": "doctable.util.iterfuncs", "qualname": "GroupedData.group_elements", "kind": "function", "doc": "<p>Groups elements of the list into nested dictionaries according to group funcs.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">elements</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">keys</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">],</span> <span class=\"n\">Hashable</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">util</span><span class=\"o\">.</span><span class=\"n\">iterfuncs</span><span class=\"o\">.</span><span class=\"n\">GroupedData</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.iterfuncs.GroupedData.ungroup", "modulename": "doctable.util.iterfuncs", "qualname": "GroupedData.ungroup", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Hashable</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.iterfuncs.GroupedData.flatten", "modulename": "doctable.util.iterfuncs", "qualname": "GroupedData.flatten", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">util</span><span class=\"o\">.</span><span class=\"n\">iterfuncs</span><span class=\"o\">.</span><span class=\"n\">GroupedData</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.iterfuncs.GroupedData.ungroup_old", "modulename": "doctable.util.iterfuncs", "qualname": "GroupedData.ungroup_old", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Hashable</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.iterfuncs.GroupedData.ungroup_recursive", "modulename": "doctable.util.iterfuncs", "qualname": "GroupedData.ungroup_recursive", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Hashable</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.iterfuncs.groupby", "modulename": "doctable.util.iterfuncs", "qualname": "groupby", "kind": "function", "doc": "<p>Groups elements of the list into nested dictionaries according to group funcs.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">elements</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">keys</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">],</span> <span class=\"n\">Hashable</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">util</span><span class=\"o\">.</span><span class=\"n\">iterfuncs</span><span class=\"o\">.</span><span class=\"n\">GroupedData</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.logstep", "modulename": "doctable.util.logstep", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStepDiff", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff", "kind": "class", "doc": "<p></p>\n", "bases": "LogStepDiff"}, {"fullname": "doctable.util.logstep.LogStepDiff.__init__", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ind_diff</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">ts_diff</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span>,</span><span class=\"param\">\t<span class=\"n\">mem_diff</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">msg1</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">msg2</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">meta1</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">meta2</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span>)</span>"}, {"fullname": "doctable.util.logstep.LogStepDiff.ind_diff", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.ind_diff", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "doctable.util.logstep.LogStepDiff.ts_diff", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.ts_diff", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.timedelta"}, {"fullname": "doctable.util.logstep.LogStepDiff.mem_diff", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.mem_diff", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "doctable.util.logstep.LogStepDiff.msg1", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.msg1", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.util.logstep.LogStepDiff.msg2", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.msg2", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.util.logstep.LogStepDiff.meta1", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.meta1", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Any"}, {"fullname": "doctable.util.logstep.LogStepDiff.meta2", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.meta2", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Any"}, {"fullname": "doctable.util.logstep.LogStep", "modulename": "doctable.util.logstep", "qualname": "LogStep", "kind": "class", "doc": "<p></p>\n", "bases": "LogStep"}, {"fullname": "doctable.util.logstep.LogStep.__init__", "modulename": "doctable.util.logstep", "qualname": "LogStep.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ind</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">msg</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ts</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">mem</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">meta</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "doctable.util.logstep.LogStep.ind", "modulename": "doctable.util.logstep", "qualname": "LogStep.ind", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "doctable.util.logstep.LogStep.msg", "modulename": "doctable.util.logstep", "qualname": "LogStep.msg", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "doctable.util.logstep.LogStep.ts", "modulename": "doctable.util.logstep", "qualname": "LogStep.ts", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.datetime"}, {"fullname": "doctable.util.logstep.LogStep.mem", "modulename": "doctable.util.logstep", "qualname": "LogStep.mem", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "doctable.util.logstep.LogStep.meta", "modulename": "doctable.util.logstep", "qualname": "LogStep.meta", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Any"}, {"fullname": "doctable.util.logstep.LogStep.diff", "modulename": "doctable.util.logstep", "qualname": "LogStep.diff", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">LogStepType</span></span><span class=\"return-annotation\">) -> <span class=\"n\">doctable</span><span class=\"o\">.</span><span class=\"n\">util</span><span class=\"o\">.</span><span class=\"n\">logstep</span><span class=\"o\">.</span><span class=\"n\">LogStepDiff</span>:</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.queueinserter", "modulename": "doctable.util.queueinserter", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.queueinserter.QueueInserter", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter", "kind": "class", "doc": "<p>Used to manage queued bulk insertion program logic.</p>\n"}, {"fullname": "doctable.util.queueinserter.QueueInserter.__init__", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">db</span>, </span><span class=\"param\"><span class=\"n\">chunk_size</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">insert_kwargs</span></span>)</span>"}, {"fullname": "doctable.util.queueinserter.QueueInserter.db", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.db", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.queueinserter.QueueInserter.chunk_size", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.chunk_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.queueinserter.QueueInserter.verbose", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.verbose", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.queueinserter.QueueInserter.insert_kwargs", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.insert_kwargs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.queueinserter.QueueInserter.queue", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.queue", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.queueinserter.QueueInserter.insert", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.insert", "kind": "function", "doc": "<p>Add a single record to the queue.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">record</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.queueinserter.QueueInserter.insert_multi", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.insert_multi", "kind": "function", "doc": "<p>Insert multiple records into the queue.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">records</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.queueinserter.QueueInserter.dump_check", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.dump_check", "kind": "function", "doc": "<p>Dump queue into database if meets threshold.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.queueinserter.QueueInserter.dump", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.dump", "kind": "function", "doc": "<p>Insert queue data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.showstopper", "modulename": "doctable.util.showstopper", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.showstopper.showstopper", "modulename": "doctable.util.showstopper", "qualname": "showstopper", "kind": "function", "doc": "<p>Totally fills a machine's resources until you can kill it.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n_cores</span><span class=\"o\">=</span><span class=\"mi\">12</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">100000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.showstopper.malloc_thread", "modulename": "doctable.util.showstopper", "qualname": "malloc_thread", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">10000000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.slots", "modulename": "doctable.util.slots", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.slots.SlotsRequiredError", "modulename": "doctable.util.slots", "qualname": "SlotsRequiredError", "kind": "class", "doc": "<p>Inappropriate argument value (of correct type).</p>\n", "bases": "builtins.ValueError"}, {"fullname": "doctable.util.slots.SlotsRequiredError.__init__", "modulename": "doctable.util.slots", "qualname": "SlotsRequiredError.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "doctable.util.slots.SlotsRequiredError.message", "modulename": "doctable.util.slots", "qualname": "SlotsRequiredError.message", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;Slots must be enabled by including &quot;__slots__ = []&quot;, Otherwise a slots class cannot be created.&#x27;"}, {"fullname": "doctable.util.slots.slots_dataclass", "modulename": "doctable.util.slots", "qualname": "slots_dataclass", "kind": "function", "doc": "<p>Automattically add slots to the given dataclass.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">_Cls</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">/</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">dataclass_kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.staticargparse", "modulename": "doctable.util.staticargparse", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.typechecks", "modulename": "doctable.util.typechecks", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.typechecks.is_sequence", "modulename": "doctable.util.typechecks", "qualname": "is_sequence", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.unit_format", "modulename": "doctable.util.unit_format", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.unit_format.format_time", "modulename": "doctable.util.unit_format", "qualname": "format_time", "kind": "function", "doc": "<p>Get string representing time quantity with correct units.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">num_seconds</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "doctable.util.unit_format.format_memory", "modulename": "doctable.util.unit_format", "qualname": "format_memory", "kind": "function", "doc": "<p>Get string representing memory quantity with correct units.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">num_bytes</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();