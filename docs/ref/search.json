[{"fullname": "doctable", "modulename": "doctable", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.api", "modulename": "doctable.api", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.connectengine", "modulename": "doctable.connectengine", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.connectengine.ConnectEngine", "modulename": "doctable.connectengine", "qualname": "ConnectEngine", "type": "class", "doc": "<p>Class to maintain sqlalchemy engine and metadata information for doctables.</p>\n"}, {"fullname": "doctable.connectengine.ConnectEngine.__init__", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.__init__", "type": "function", "doc": "<p>Initializes sqlalchemy engine  and metadata objects.\nArgs:\n    target: choose target database for connection.\n    echo: sets the echo status used in sqlalchemy.create_engine().\n        This will output every sql query upon execution.\n    connect_args: passed to sqlalchemy.create_engine() as the connect_args param.\n        See more options in the official docs:\n        https://docs.sqlalchemy.org/en/13/core/engines.html#sqlalchemy.create_engine</p>\n", "parameters": ["self", "target", "dialect", "new_db", "foreign_keys", "echo", "orm", "engine_kwargs", "connect_args"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.execute", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.execute", "type": "function", "doc": "<p>Open temporary connection and execute query.</p>\n", "parameters": ["self", "query", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.dialect", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.dialect", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.connectengine.ConnectEngine.target", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.target", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.connectengine.ConnectEngine.list_tables", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.list_tables", "type": "function", "doc": "<p>List table names in database connection.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.tables", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.tables", "type": "variable", "doc": "<p>Get table objects stored in metadata.</p>\n"}, {"fullname": "doctable.connectengine.ConnectEngine.get_session", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.get_session", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.connect", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.connect", "type": "function", "doc": "<p>Open new connection in engine connection pool.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.reopen", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.reopen", "type": "function", "doc": "<p>Deletes all connections and clears metadata.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.dispose", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.dispose", "type": "function", "doc": "<p>Closes all existing connections attached to engine.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.clear_metadata", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.clear_metadata", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.create_all", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.create_all", "type": "function", "doc": "<p>Create tables from metadata object.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.schema", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.schema", "type": "function", "doc": "<p>Read schema information for single table.\nReturns:\n    dictionary</p>\n", "parameters": ["self", "tabname"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.schema_df", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.schema_df", "type": "function", "doc": "<p>Read schema information for table as pandas dataframe.\nReturns:\n    pandas dataframe</p>\n", "parameters": ["self", "tabname"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.remove_table", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.remove_table", "type": "function", "doc": "<p>Remove the given Table object from MetaData object. Does not drop.</p>\n", "parameters": ["self", "table"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.add_table", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.add_table", "type": "function", "doc": "<p>Adds a table to the metadata. If columns not provided, creates by autoload.\nArgs:\n    tabname (str): name of new table.\n    columns (list/tuple): column objects passed to sqlalchemy.Table\n    table_kwargs: passed to sqlalchemy.Table constructor.</p>\n", "parameters": ["self", "tabname", "columns", "new_table", "table_kwargs"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.add_existing_tables", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.add_existing_tables", "type": "function", "doc": "<p>Will register all existing tables in metadata.</p>\n", "parameters": ["self", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.connectengine.ConnectEngine.drop_table", "modulename": "doctable.connectengine", "qualname": "ConnectEngine.drop_table", "type": "function", "doc": "<p>Drops table, either sqlalchemy object or by executing DROP TABLE.\nArgs:\n    table (sqlalchemy.Table/str): table object or name to drop.\n    if_exists (bool): if true, won't throw exception if table doesn't exist.</p>\n", "parameters": ["self", "table", "if_exists", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.dbutils", "modulename": "doctable.dbutils", "qualname": "", "type": "module", "doc": "<p>This file contains functions for migrating database tables.\nThis means adding or removing columns, etc.</p>\n"}, {"fullname": "doctable.dbutils.list_tables", "modulename": "doctable.dbutils", "qualname": "list_tables", "type": "function", "doc": "<p>List tables in an sqlite database.\nArgs:\n    target (str): sql file or endpoint to connect to\n    dialect (str): sql dialect to use for conenction\n    engine_args (kwargs): passed to sqlalchemy ConnectEngine</p>\n", "parameters": ["target", "dialect", "engine_args"], "funcdef": "def"}, {"fullname": "doctable.dbutils.migrate_db", "modulename": "doctable.dbutils", "qualname": "migrate_db", "type": "function", "doc": "<p>Moves old database to db with new schema.\nArgs:\n    oldfname (str): filename of old database.\n    newfname (str): filename of new database.\n    newschema (list<list>): shema that would be \n        used in the constructor to a doctable\n        instance.\n    newcolmap (dict<colname->func>): Allows for \n        population of new columns if they are a function \n        of the associated row.</p>\n", "parameters": ["oldfname", "newfname", "newschema", "newcolmap", "delcols"], "funcdef": "def"}, {"fullname": "doctable.doctable", "modulename": "doctable.doctable", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.doctable.DocTable", "modulename": "doctable.doctable", "qualname": "DocTable", "type": "class", "doc": "<p>Class for managing a single database table.\nDescription: This class manages schema and connection information to provide\n    an object-based interface to perform queries on a single table \n    in a database (although multi-table designs are possible with \n    multiple DocTables). It is designed to maintain informabout about the \n    underlying database structure of the table, making it possible to \n    execute queries without using the SQL language.</p>\n\n<p>Settable static attributes (overridden if related constructor argument passed):\n    _target_ (str): target database to connect to - used when a doctable\n        will always connect to the same target (i.e., a server etc).\n    _tabname_ (str): name of table to connect to (and create).\n    _schema_ (list or class): schema definition for this doctable, to be used\n        when creating a new table and to manage table information.\n    _indices_ (dict): indices to apply to the table\n    _constraints_ (list): constraints to apply to the table\n    _doctable_args_ (dict): any other constructor arguments that should always\n        be used when instantiating. Overridden by providing arguments\n        to the constructor.</p>\n"}, {"fullname": "doctable.doctable.DocTable.__init__", "modulename": "doctable.doctable", "qualname": "DocTable.__init__", "type": "function", "doc": "<p>Create new database.\nArgs:\n    target (str): filename for database to connect to. \":memory:\" is a \n        special value indicating to the python sqlite engine that the db\n        should be created in memory. Will create new empty database file\n        if it does not exist and new_db==True, and add a new table using\n        specified schema if new_table==True.\n    schema (list<list>): schema from which to create db. Includes a\n        list of column names and types (including contraints and indexes) as tuples\n        defined according to information needed to construct the sqlalchemy\n        objects.\n    tabname (str): table name for this specific doctable.\n    dialect (str): database engine through which to construct db.\n        For more info, see sqlalchemy dialect info:\n        https://docs.sqlalchemy.org/en/13/dialects/\n    persistent_conn (bool): whether or not to create a persistent conn \n        to database. Otherwise will create temporary connection for each\n        query.\n    readonly (bool): Prevents user from calling insert(), delete(), or \n        update(). Will not block other sql possible commands.\n    new_db (bool): Indicate if new db file should be created given \n        that a schema is provided and the db file doesn't exist.\n    new_table (bool): Allow doctable to create a new table if one \n        doesn't exist already.\n    connect_args (**kwargs): Pass directly to the sqlalchemy\n        .create_engine() as connect_args. Args typically vary by dialect.\n        Example: connect_args={'timeout': 15} for sqlite\n        or connect_args={'connect_timeout': 15} for PostgreSQL.\n    verbose (bool): Print every sql command before executing.\n    echo (bool): Print sqlalchemy engine log for each query.</p>\n", "parameters": ["self", "target", "tabname", "schema", "indices", "constraints", "dialect", "engine", "readonly", "new_db", "new_table", "persistent_conn", "verbose", "engine_kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.close_conn", "modulename": "doctable.doctable", "qualname": "DocTable.close_conn", "type": "function", "doc": "<p>Closes connection to db (if one exists).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.open_conn", "modulename": "doctable.doctable", "qualname": "DocTable.open_conn", "type": "function", "doc": "<p>Opens connection to db (if one does not exist).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.reopen_engine", "modulename": "doctable.doctable", "qualname": "DocTable.reopen_engine", "type": "function", "doc": "<p>Opens connection engine. \nArgs:\n    open_conn (bool): create a new db connection.</p>\n", "parameters": ["self", "open_conn"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.col", "modulename": "doctable.doctable", "qualname": "DocTable.col", "type": "function", "doc": "<p>Accesses a column object.\nArgs:\n    Name of column to access. Applied as subscript to \n        sqlalchemy columns object.</p>\n", "parameters": ["self", "name"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.table", "modulename": "doctable.doctable", "qualname": "DocTable.table", "type": "variable", "doc": "<p>Returns underlying sqlalchemy table object for manual manipulation.</p>\n"}, {"fullname": "doctable.doctable.DocTable.tabname", "modulename": "doctable.doctable", "qualname": "DocTable.tabname", "type": "variable", "doc": "<p>Gets name of table for this connection.</p>\n"}, {"fullname": "doctable.doctable.DocTable.columns", "modulename": "doctable.doctable", "qualname": "DocTable.columns", "type": "variable", "doc": "<p>Exposes SQLAlchemy core table columns object.\nNotes:\n    some info here: \n    https://docs.sqlalchemy.org/en/13/core/metadata.html</p>\n\n<pre><code>c = db.columns['id']\nc.type, c.name, c.\n</code></pre>\n\n<p>Returns:\n    sqlalchemy columns: access to underlying columns\n        object.</p>\n"}, {"fullname": "doctable.doctable.DocTable.engine", "modulename": "doctable.doctable", "qualname": "DocTable.engine", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.doctable.DocTable.list_tables", "modulename": "doctable.doctable", "qualname": "DocTable.list_tables", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.colnames", "modulename": "doctable.doctable", "qualname": "DocTable.colnames", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.primary_keys", "modulename": "doctable.doctable", "qualname": "DocTable.primary_keys", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.schema_info", "modulename": "doctable.doctable", "qualname": "DocTable.schema_info", "type": "function", "doc": "<p>Get info about each column as a dictionary.\nReturns:\n    dict<dict>: info about each column.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.schema_table", "modulename": "doctable.doctable", "qualname": "DocTable.schema_table", "type": "function", "doc": "<p>Get info about each column as a dictionary.\nReturns:\n    DataFrame: info about each column.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.insert", "modulename": "doctable.doctable", "qualname": "DocTable.insert", "type": "function", "doc": "<p>Insert a row or rows into the database.\nArgs:\n    rowdat (list<dict> or dict): row data to insert.\n    ifnotunique (str): way to handle inserted data if it breaks\n        a table constraint. Choose from FAIL, IGNORE, REPLACE.\nReturns:\n    sqlalchemy query result object.</p>\n", "parameters": ["self", "rowdat", "ifnotunique", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.count", "modulename": "doctable.doctable", "qualname": "DocTable.count", "type": "function", "doc": "<p>Count number of rows which match where condition.\nNotes:\n    Calls select_first under the hood.\nArgs:\n    where (sqlalchemy condition): filter rows before counting.\n    wherestr (str): filter rows before counting.\nReturns:\n    int: number of rows that match \"where\" and \"wherestr\" criteria.</p>\n", "parameters": ["self", "where", "wherestr", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.head", "modulename": "doctable.doctable", "qualname": "DocTable.head", "type": "function", "doc": "<p>Return first n rows as dataframe for quick viewing.\nArgs:\n    n (int): number of rows to return in dataframe.\nReturns:\n    Dataframe of the first n rows of the table.</p>\n", "parameters": ["self", "n"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.select", "modulename": "doctable.doctable", "qualname": "DocTable.select", "type": "function", "doc": "<p>Perform select query, yield result for each row.</p>\n\n<p>Description: Because output must be iterable, returns special column results \n    by performing one query per row. Can be inefficient for many smaller \n    special data information.</p>\n\n<p>Args:\n    cols: list of sqlalchemy datatypes created from calling .col() method.\n    where (sqlachemy BinaryExpression): sqlalchemy \"where\" object to parse\n    orderby: sqlalchemy orderby directive\n    groupby: sqlalchemy gropuby directive\n    limit (int): number of entries to return before stopping\n    wherestr (str): raw sql \"where\" conditionals to add to where input\n    from_obj (sqlalchemy join): table from which to perform query (for joined tables)\n    as_dataclass (bool): if schema was provided in dataclass format, should return as \n        dataclass object?\n    result_container (class): container for result rows. constructor takes single arg\n        may be useful to provide a class that extends list\n    **kwargs: passed to self.execute()\nYields:\n    sqlalchemy result object: row data</p>\n", "parameters": ["self", "cols", "where", "orderby", "groupby", "limit", "wherestr", "offset", "from_obj", "as_dataclass", "result_container", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.select_first", "modulename": "doctable.doctable", "qualname": "DocTable.select_first", "type": "function", "doc": "<p>Perform regular select query returning only the first result.\nArgs:\n    <em>args: args to regular .select() method.\n    *</em>kwargs: args to regular .select() method.\nReturns:\n    sqlalchemy results obect: First result from select query.\nRaises:\n    LookupError: where no items are returned with the select \n        statement. Couldn't return None or other object because\n        those could be valid objects in a single-row select query.\n        In cases where uncertain if row match exists, use regular \n        .select() and count num results, or use try/catch.</p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.select_df", "modulename": "doctable.doctable", "qualname": "DocTable.select_df", "type": "function", "doc": "<p>Select returning dataframe.\nArgs:\n    cols: sequence of columns to query. Must be sequence,\n        passed directly to .select() method.\n    <em>args: args to regular .select() method.\n    *</em>kwargs: args to regular .select() method.\nReturns:\n    pandas dataframe: Each row is a database row,\n        and output is not indexed according to primary \n        key or otherwise. Call .set_index('id') on the\n        dataframe to envoke this behavior.</p>\n", "parameters": ["self", "cols", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.select_series", "modulename": "doctable.doctable", "qualname": "DocTable.select_series", "type": "function", "doc": "<p>Select returning pandas Series.\nArgs:\n    col: column to query. Passed directly to .select() \n        method.\n    <em>args: args to regular .select() method.\n    *</em>kwargs: args to regular .select() method.\nReturns:\n    pandas series: enters rows as values.</p>\n", "parameters": ["self", "col", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.join", "modulename": "doctable.doctable", "qualname": "DocTable.join", "type": "function", "doc": "<p>Wrapper over table.join(), can pass to from_obj parameter for .select()\nArgs:\n    other (DocTable): other doctable to join\n    <em>args, *</em>kwargs: passed to table.join() method</p>\n", "parameters": ["self", "other", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.select_chunks", "modulename": "doctable.doctable", "qualname": "DocTable.select_chunks", "type": "function", "doc": "<p>Performs select while querying only a subset of the results at a time.\nArgs:\n    cols (col name(s) or sqlalchemy object(s)): columns to query\n    chunksize (int): size of individual queries to be made. Will\n        load this number of rows into memory before yielding.\n    limit (int): maximum number of rows to retrieve. Because \n        the limit argument is being used internally to limit data\n        to smaller chunks, use this argument instead. Internally,\n        this function will load a maximum of limit + chunksize \n        - 1 rows into memory, but yields only limit.\nYields:\n    sqlalchemy result: row data - same as .select() method.</p>\n", "parameters": ["self", "cols", "chunksize", "limit", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.select_iter", "modulename": "doctable.doctable", "qualname": "DocTable.select_iter", "type": "function", "doc": "<p>Same as .select except results retrieved from db in chunks.\nArgs:\n    cols (col name(s) or sqlalchemy object(s)): columns to query\n    chunksize (int): size of individual queries to be made. Will\n        load this number of rows into memory before yielding.\n    limit (int): maximum number of rows to retrieve. Because \n        the limit argument is being used internally to limit data\n        to smaller chunks, use this argument instead. Internally,\n        this function will load a maximum of limit + chunksize \n        - 1 rows into memory, but yields only limit.\nYields:\n    sqlalchemy result: row data - same as .select() method.</p>\n", "parameters": ["self", "cols", "chunksize", "limit", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.get_queueinserter", "modulename": "doctable.doctable", "qualname": "DocTable.get_queueinserter", "type": "function", "doc": "<p>Get an object that will queue rows for insertion.</p>\n", "parameters": ["self", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.update", "modulename": "doctable.doctable", "qualname": "DocTable.update", "type": "function", "doc": "<p>Update row(s) assigning the provided values.\nArgs:\n    values (dict<colname->value> or list<dict> or list&lt;(col,value)&gt;)): \n        values to populate rows with. If dict, will insert those values\n        into all rows that match conditions. If list of dicts, assigns\n        expression in value (i.e. id['year']+1) to column. If list of \n        (col,value) 2-tuples, will assign value to col in the order \n        provided. For example given row values x=1 and y=2, the input\n        [(x,y+10),(y,20)], new values will be x=12, y=20. If opposite\n        order [(y,20),(x,y+10)] is provided new values would be y=20,\n        x=30. In cases where list<dict> is provided, this behavior is \n        undefined.\n    where (sqlalchemy condition): used to match rows where\n        update will be applied.\n    wherestr (sql string condition): matches same as where arg.\nReturns:\n    SQLAlchemy result proxy object</p>\n", "parameters": ["self", "values", "where", "wherestr", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.update_dataclass", "modulename": "doctable.doctable", "qualname": "DocTable.update_dataclass", "type": "function", "doc": "<p>Updates database with single modified object based on the provided key.</p>\n", "parameters": ["self", "obj", "key_name", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.delete", "modulename": "doctable.doctable", "qualname": "DocTable.delete", "type": "function", "doc": "<p>Delete rows from the table that meet the where criteria.\nArgs:\n    where (sqlalchemy condition): criteria for deletion.\n    wherestr (sql string): addtnl criteria for deletion.\n    vacuum (bool): will execute vacuum sql command to reduce\n        storage space needed by SQL table. Use when deleting\n        significant ammounts of data.\nReturns:\n    SQLAlchemy result proxy object.</p>\n", "parameters": ["self", "where", "wherestr", "vacuum", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.execute", "modulename": "doctable.doctable", "qualname": "DocTable.execute", "type": "function", "doc": "<p>Execute an sql command. Called by most higher-level functions.\nArgs:\n    query (sqlalchemy condition or str): query to execute;\n        can be provided as sqlalchemy condition object or\n        plain sql text.\n    verbose (bool or None): Print SQL command issued before\n        execution.</p>\n", "parameters": ["self", "query", "verbose", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.bootstrap", "modulename": "doctable.doctable", "qualname": "DocTable.bootstrap", "type": "function", "doc": "<p>Generates a DocBootstrapper object to sample from.\nNotes:\n    The DocBootstrap object keeps all selected docs in\n        memory, and yields samples with .sample().\nArgs:\n    <em>args: passed to .select()\n    n (int): number of samples to bs. If left unset, can\n        specify when drawing sample from DocBootstrap obj.\n    *</em>kwargs: passed to .select()\nReturns:\n    DocBootstrap object for bootstrapping.</p>\n", "parameters": ["self", "args", "n", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.doctable.DocTable.clean_col_files", "modulename": "doctable.doctable", "qualname": "DocTable.clean_col_files", "type": "function", "doc": "<p>Make sure there is a 1-1 mapping between files listed in db and files in folder.\nArgs:\n    col (str or Column object): column to clean picklefiles for.\n    ignore_missing (bool): if False, throw an error when a db file doesn't exist.</p>\n", "parameters": ["self", "col", "check_missing", "delete_extraneous"], "funcdef": "def"}, {"fullname": "doctable.doctable.is_sequence", "modulename": "doctable.doctable", "qualname": "is_sequence", "type": "function", "doc": "<p></p>\n", "parameters": ["obj"], "funcdef": "def"}, {"fullname": "doctable.doctable.is_ord_sequence", "modulename": "doctable.doctable", "qualname": "is_ord_sequence", "type": "function", "doc": "<p></p>\n", "parameters": ["obj"], "funcdef": "def"}, {"fullname": "doctable.doctablemongo", "modulename": "doctable.doctablemongo", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.doctablemongo.DocTableMongo", "modulename": "doctable.doctablemongo", "qualname": "DocTableMongo", "type": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.doctablemongo.DocTableMongo.__init__", "modulename": "doctable.doctablemongo", "qualname": "DocTableMongo.__init__", "type": "function", "doc": "<p>Interface for single MongoDB collection.</p>\n", "parameters": ["self", "db", "collection", "port"], "funcdef": "def"}, {"fullname": "doctable.doctablemongo.DocTableMongo.insert", "modulename": "doctable.doctablemongo", "qualname": "DocTableMongo.insert", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.exceptions", "modulename": "doctable.exceptions", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.exceptions.base", "modulename": "doctable.exceptions.base", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.exceptions.base.BaseException", "modulename": "doctable.exceptions.base", "qualname": "BaseException", "type": "class", "doc": "<p>Exception template for doctable.</p>\n"}, {"fullname": "doctable.exceptions.base.BaseException.__init__", "modulename": "doctable.exceptions.base", "qualname": "BaseException.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.exceptions.base.BaseException.message", "modulename": "doctable.exceptions.base", "qualname": "BaseException.message", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.exceptions.distributeexceptions", "modulename": "doctable.exceptions.distributeexceptions", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy", "modulename": "doctable.legacy", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.docparser", "modulename": "doctable.legacy.docparser", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.docparser.DocParser", "modulename": "doctable.legacy.docparser", "qualname": "DocParser", "type": "class", "doc": "<p>Class that maintains convenient functions for parsing Spacy doc objects.</p>\n"}, {"fullname": "doctable.legacy.docparser.DocParser.__init__", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.re_url", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.re_url", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.docparser.DocParser.re_xml_tag", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.re_xml_tag", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.docparser.DocParser.re_digits", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.re_digits", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.docparser.DocParser.preprocess", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.preprocess", "type": "function", "doc": "<p>Apply preprocessing step, modifies and returns text.\nArgs:\n    text (str): document as a text string\n    replace_url (str or None): if not None, replace url with string\n    replace_xml (str or None): if not None, replace xml tags with string\n    replace_digits (str or None): if not None, replace digits with string</p>\n", "parameters": ["cls", "text", "replace_url", "replace_xml", "replace_digits"], "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.get_parsetrees", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.get_parsetrees", "type": "function", "doc": "<p>Extracts parsetree from spacy doc objects.\nArgs:\n    doc (spacy.Doc object): doc to generate parsetree from.\n    parse_tok_func (func): function used to convert token to \n        a string representation. Usually a lambda function \n        wrapping some variant of self.parse_tok().\n    userdata_map (dict<str->func>): attribute to function \n        mapping. Functions take a token and output a property\n        that will be stored in each parsetree node.\n    merge_ents (bool): merge multi-word entities.\n    spacy_ngram_matcher (Spacy Matcher): used to create ngrams\n        with Spacy. Powerful wildcards etc.\n    merge_noun_chunks (bool): merge noun chunks or not.</p>\n", "parameters": ["cls", "doc", "parse_tok_func", "userdata_map", "merge_ents", "spacy_ngram_matcher", "merge_noun_chunks"], "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.tokenize_doc", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.tokenize_doc", "type": "function", "doc": "<p>Parse spacy doc object.\nArgs:\n    split_sents (bool): parse into list of sentence tokens using doc.sents.\n    merge_ents (bool): merge multi_word entities into same token.\n    ngrams (iter<iter<str>&gt;): iterable of token tuples to merge after parsing.\n    spacy_ngram_matcher (spacy Matcher): matcher object to use on the spacy doc.\n        Normally will create using spacy.Matcher(nlp.vocab), see more details\n        at https://spacy.io/usage/rule-based-matching And also note that the \n        nlp object must be the one used for parsing.\n    use_tok_func (func): func used to decide to keep func or not. Default is\n        cls.use_tok().\n    parse_tok_func (func): func used to parse tokens. By default uses \n        cls.parse_tok().</p>\n", "parameters": ["cls", "doc", "split_sents", "merge_ents", "merge_noun_chunks", "ngrams", "spacy_ngram_matcher", "ngram_sep", "use_tok_func", "parse_tok_func"], "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.parse_tok", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.parse_tok", "type": "function", "doc": "<p>Convert spacy token object to string.\nArgs:\n    tok (spacy token or span): token object to convert to string.\n    replace_num (str/None): Replace number following tok.like_num (includes \"five\", \n        or 5) with a special token (i.e. __NUM__). None means no replacement.\n    replace_digit (str/None): Replace digit meeting tok.is_digit with special token. \n        Only used when replace_num is None.\n    lemmatize (bool): return lemma instead of full word.\n    normal_convert (func): custom conversion function to happen as last step\n        for non-entities. This way can keep all other functionality.\n    format_ents (bool): Replace whitespace with space and capitalize first \n        letter of ents.\n    ent_convert (func): custom conversion function to happen as last step\n        for entities. This way can keep all other functionality.</p>\n", "parameters": ["tok", "num_replacement", "digit_replacement", "lemmatize", "normal_convert", "format_ents", "ent_convert"], "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.use_tok", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.use_tok", "type": "function", "doc": "<p>Decide to use token or not (can be overridden).\nArgs:\n    no_whitespace (bool): exclude whitespace.\n    no_punct (bool): exclude punctuation.\n    no_num (bool): exclude numbers using tok.is_num.\n    no_digit (bool): exclude digits using tok.is_digit.\n    no_stop (bool): exclude stopwords.</p>\n", "parameters": ["tok", "filter_whitespace", "filter_punct", "filter_stop", "filter_digit", "filter_num", "filter_all_ents", "filter_ent_types"], "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.apply_doc_transform", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.apply_doc_transform", "type": "function", "doc": "<p>Apply merges to doc object including entities, normal ngrams, and noun chunks.</p>\n", "parameters": ["doc", "merge_ents", "spacy_ngram_matcher", "merge_noun_chunks"], "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.merge_ngrams", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.merge_ngrams", "type": "function", "doc": "<p>Merges manually specified consecutive tokens into single tokens.</p>\n", "parameters": ["toks", "ngrams", "ngram_sep"], "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.parse_text_chunks", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.parse_text_chunks", "type": "function", "doc": "<p>Parse text in paragraph by sentences.\nArgs:\n    text (str): (preprocessed) text document to parse\n    nlp (spaCy parser): with .pipe() method to parse documents\n    parse_funcs (list<func>): convert doc to \n    chunk_sents (int): number of sentences used in each chunk to \n        be parsed. Max size for single spacy doc is 1 million \n        chars. If av num chars per sent is 75-100, a size of\n        3000 means each chunk will have approx 300k characters.\n        Hopefully, on average small enough. Larger value means\n        more memory but faster processing.</p>\n", "parameters": ["cls", "text", "nlp", "parse_funcs", "doc_transform", "chunk_sents", "split_re"], "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.distribute_parse", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.distribute_parse", "type": "function", "doc": "<p>Distributes text parsing across multiple processes in chunks.\nArgs:\n    texts (list): list of raw texts to process\n    spacynlp (spacy nlp object): for applying .pipe() to doc chunks\n    parsefunc (func): convert spacy doc object to storage represenation\n        By defaut uses DocParser.tokenize_doc().\n    preprocessfunc (func): process text before parsing. Uses \n        DocParser.preprocess() by default.\n    dt_inst (doctable instance): if included, will pass to parsefunc as\n        second argument. Usually to do this, you'll create a function\n        which calls some overloaded version of .tokenize_doc() and then\n        calls dt_inst.insert() to place in database.\n    paragraph_sep (str or None): if defined, will distribute parsing across\n        paragraphs and leave paragraph structure of docs in nested lists.\n    workers (int): number of processes to create.\nReturns:\n    output of parsing</p>\n", "parameters": ["cls", "texts", "spacynlp", "parsefunc", "preprocessfunc", "dt_inst", "paragraph_sep", "workers"], "funcdef": "def"}, {"fullname": "doctable.legacy.docparser.DocParser.spacy_parse_chunks", "modulename": "doctable.legacy.docparser", "qualname": "DocParser.spacy_parse_chunks", "type": "function", "doc": "<p>Parses document in sentence chunks to reduce memory use.</p>\n", "parameters": ["text", "nlp", "parsefuncs", "chunk_size"], "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy", "modulename": "doctable.legacy.doctablelegacy", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy", "type": "class", "doc": "<p>This is a base class for working with text documents. \nIt is to be inhereted by a class actually defining the table schema for documents.</p>\n"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.__init__", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.__init__", "type": "function", "doc": "<p>Args:\n    fname (str): filename of database\n    tabname (str): name of sqlite table to manipulate.\n    colschema (tuple of 2-tuples): list of colname, coltype columns\n    constraints (tuple of str): constraints to put on columns\n    verbose (bool): print querys before executing\n    persistent_conn (bool): keep a persistent sqlite3 connection to \n        the db.\n    new_db (bool): create a new database file if one does not already \n        exist. Prevents creation of new db if filename is mis-specified.</p>\n", "parameters": ["self", "colschema", "fname", "tabname", "constraints", "verbose", "persistent_conn", "make_new_db", "check_schema"], "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.commit", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.commit", "type": "function", "doc": "<p>Commits database changes to file.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.query", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.query", "type": "function", "doc": "<p>Executes raw query using database connection.</p>\n\n<p>Output: sqlite query conn.execute() output.</p>\n", "parameters": ["self", "qstr", "payload", "many", "verbose"], "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.add", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.add", "type": "function", "doc": "<p>Adds a single entry where each column is identified by a key-value pair. \n    Will automatically convert python types to sqlite storage blobs using pickle.</p>\n\n<p>Inputs:\n    datadict: dictionary of column name -> value mappings\n    ifnotunique: choose what happens when an existing entry matches\n        any UNIQUE criteria specified in the schema.\n        Choose from ('REPLACE', 'IGNORE').\nOutput:\n    query response</p>\n", "parameters": ["self", "datadict", "ifnotunique", "queryargs"], "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.addmany", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.addmany", "type": "function", "doc": "<p>Adds multiple entries to the database, where column names are specified by \"keys\".\n    If \"keys\" is not specified, will use all columns (including autoincrement columns).\n    Will automatically convert python types to sqlite storage blobs using pickle.</p>\n\n<p>Inputs:\n    data: lists of tuples representing data for each row\n    keys: column names corresponding to each tuple entry\n    ifnotunique: choose what happens when an existing entry matches\n        any UNIQUE criteria specified in the schema.\n        Choose from ('REPLACE', 'IGNORE').\nOutput:\n    sqlite executemany query response</p>\n", "parameters": ["self", "data", "keys", "ifnotunique", "queryargs"], "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.delete", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.delete", "type": "function", "doc": "<p>Deletes all rows matching the where criteria.</p>\n\n<p>Inputs:\n    where: if \"*\" is specified, will drop all rows. Otherwise\n        is fed directly into the query statement.</p>\n\n<p>Output:\n    query response</p>\n", "parameters": ["self", "where", "queryargs"], "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.update", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.update", "type": "function", "doc": "<p>Updates rows matching the \"where\" string with specified values.</p>\n\n<p>Inputs:\n    values: dictionary of field->values. all rows which meet the where criteria \n        will have these values assigned\n    where: literal SQLite \"where\" string corresponding to column criteria for \n        value replacement.\n        The value \"*\" will match all rows by omitting WHERE statement.\nOutput:\n    query response</p>\n", "parameters": ["self", "values", "where", "queryargs"], "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.get", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.get", "type": "function", "doc": "<p>Query rows from database as generator.</p>\n\n<p>Inputs:\n    sel: list of fields to retrieve with the query\n    where: literal SQLite \"where\" string corresponding to criteria for \n        value replacement.\n    orderby: literal sqlite order by command value. Can be \"column_1 ASC\",\n        or order by multiple columns using, for instance, \"column_1 ASC, column_2 DESC\"\n    limit: number of rows to retrieve before stopping query. Can be used for quick testing.\n    table: table name to retrieve for. Default is object table name, but can query from \n        others here.\n    verbose: True/False flag indicating whether or not output should appear.\n    asdict: True/False flag indicating whether rows should be returned as \n        lists (False) or as dicts with field names (True &amp; default).\n    kwargs: to be sent to self.query().</p>\n", "parameters": ["self", "sel", "where", "orderby", "limit", "table", "verbose", "asdict", "queryargs"], "funcdef": "def"}, {"fullname": "doctable.legacy.doctablelegacy.DocTableLegacy.getdf", "modulename": "doctable.legacy.doctablelegacy", "qualname": "DocTableLegacy.getdf", "type": "function", "doc": "<p>Query rows from database, return as Pandas DataFrame.</p>\n\n<p>Inputs:\n    See inputs for self.get().</p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.models", "modulename": "doctable.models", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.models.bootstrap", "modulename": "doctable.models.bootstrap", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.models.bootstrap.DocBootstrap", "modulename": "doctable.models.bootstrap", "qualname": "DocBootstrap", "type": "class", "doc": "<p>Class to handle bootstrapping of documents.</p>\n"}, {"fullname": "doctable.models.bootstrap.DocBootstrap.__init__", "modulename": "doctable.models.bootstrap", "qualname": "DocBootstrap.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "docs", "n"], "funcdef": "def"}, {"fullname": "doctable.models.bootstrap.DocBootstrap.set_new_sample", "modulename": "doctable.models.bootstrap", "qualname": "DocBootstrap.set_new_sample", "type": "function", "doc": "<p>Set internal sample state.\nArgs:\n    n (int): new number of samples to draw</p>\n", "parameters": ["self", "n"], "funcdef": "def"}, {"fullname": "doctable.models.bootstrap.DocBootstrap.new_sample", "modulename": "doctable.models.bootstrap", "qualname": "DocBootstrap.new_sample", "type": "function", "doc": "<p>Save and return new sample.\nArgs:\n    n (int): number of new samples to draw. If None, will draw \n        previously set number.\n    with_ids (bool): return (id,doc) tuples or just docs.</p>\n", "parameters": ["self", "n", "with_ids"], "funcdef": "def"}, {"fullname": "doctable.models.gmm", "modulename": "doctable.models.gmm", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.models.gmm.GMM", "modulename": "doctable.models.gmm", "qualname": "GMM", "type": "class", "doc": "<p>Gaussian mixture model.</p>\n"}, {"fullname": "doctable.models.gmm.GMM.set_new_sample", "modulename": "doctable.models.gmm", "qualname": "GMM.set_new_sample", "type": "function", "doc": "<p>Set a random sample of every centroid in the mixture.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.models.gmm.GMM.get_sample", "modulename": "doctable.models.gmm", "qualname": "GMM.get_sample", "type": "function", "doc": "<p>Create random samples from centroids.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.models.gmm.Centroid", "modulename": "doctable.models.gmm", "qualname": "Centroid", "type": "class", "doc": "<p>Represents a gaussian distribution and stores random samples.</p>\n"}, {"fullname": "doctable.models.gmm.Centroid.__init__", "modulename": "doctable.models.gmm", "qualname": "Centroid.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "size", "norm", "var", "nsamp", "normed", "meanvec", "samp"], "funcdef": "def"}, {"fullname": "doctable.models.gmm.Centroid.size", "modulename": "doctable.models.gmm", "qualname": "Centroid.size", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.models.gmm.Centroid.norm", "modulename": "doctable.models.gmm", "qualname": "Centroid.norm", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.models.gmm.Centroid.var", "modulename": "doctable.models.gmm", "qualname": "Centroid.var", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.models.gmm.Centroid.nsamp", "modulename": "doctable.models.gmm", "qualname": "Centroid.nsamp", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.models.gmm.Centroid.normed", "modulename": "doctable.models.gmm", "qualname": "Centroid.normed", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.models.gmm.Centroid.meanvec", "modulename": "doctable.models.gmm", "qualname": "Centroid.meanvec", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.models.gmm.Centroid.samp", "modulename": "doctable.models.gmm", "qualname": "Centroid.samp", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.models.gmm.Centroid.make_random_mean", "modulename": "doctable.models.gmm", "qualname": "Centroid.make_random_mean", "type": "function", "doc": "<p>Return random mean vector for this centroid.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.models.gmm.Centroid.draw_sample", "modulename": "doctable.models.gmm", "qualname": "Centroid.draw_sample", "type": "function", "doc": "<p>Return random samples from this centroid.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.models.gmm.Centroid.set_new_sample", "modulename": "doctable.models.gmm", "qualname": "Centroid.set_new_sample", "type": "function", "doc": "<p>Draw sample and assign it to this centroid.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.models.gmm.Centroid.av_sim", "modulename": "doctable.models.gmm", "qualname": "Centroid.av_sim", "type": "function", "doc": "<p>Average similarity between points.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel", "modulename": "doctable.parallel", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.exceptions", "modulename": "doctable.parallel.exceptions", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.exceptions.WorkerResourceBaseException", "modulename": "doctable.parallel.exceptions", "qualname": "WorkerResourceBaseException", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.parallel.exceptions.WorkerResourceBaseException.__init__", "modulename": "doctable.parallel.exceptions", "qualname": "WorkerResourceBaseException.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.parallel.exceptions.NoWorkersAvailable", "modulename": "doctable.parallel.exceptions", "qualname": "NoWorkersAvailable", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.parallel.exceptions.NoWorkersAvailable.message", "modulename": "doctable.parallel.exceptions", "qualname": "NoWorkersAvailable.message", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.exceptions.WorkerDiedError", "modulename": "doctable.parallel.exceptions", "qualname": "WorkerDiedError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.parallel.exceptions.WorkerDiedError.message", "modulename": "doctable.parallel.exceptions", "qualname": "WorkerDiedError.message", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.exceptions.WorkerIsDeadError", "modulename": "doctable.parallel.exceptions", "qualname": "WorkerIsDeadError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.parallel.exceptions.WorkerIsDeadError.message", "modulename": "doctable.parallel.exceptions", "qualname": "WorkerIsDeadError.message", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.exceptions.WorkerIsAliveError", "modulename": "doctable.parallel.exceptions", "qualname": "WorkerIsAliveError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.parallel.exceptions.WorkerIsAliveError.message", "modulename": "doctable.parallel.exceptions", "qualname": "WorkerIsAliveError.message", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.exceptions.UnidentifiedMessageReceivedError", "modulename": "doctable.parallel.exceptions", "qualname": "UnidentifiedMessageReceivedError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.parallel.exceptions.UnidentifiedMessageReceivedError.message", "modulename": "doctable.parallel.exceptions", "qualname": "UnidentifiedMessageReceivedError.message", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.exceptions.WorkerResourceReceivedUnidentifiedMessage", "modulename": "doctable.parallel.exceptions", "qualname": "WorkerResourceReceivedUnidentifiedMessage", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.parallel.exceptions.WorkerResourceReceivedUnidentifiedMessage.message", "modulename": "doctable.parallel.exceptions", "qualname": "WorkerResourceReceivedUnidentifiedMessage.message", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.exceptions.WorkerHasNoUserFunctionError", "modulename": "doctable.parallel.exceptions", "qualname": "WorkerHasNoUserFunctionError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.parallel.exceptions.WorkerHasNoUserFunctionError.message", "modulename": "doctable.parallel.exceptions", "qualname": "WorkerHasNoUserFunctionError.message", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.exceptions.UserFuncRaisedException", "modulename": "doctable.parallel.exceptions", "qualname": "UserFuncRaisedException", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.parallel.exceptions.UserFuncRaisedException.__init__", "modulename": "doctable.parallel.exceptions", "qualname": "UserFuncRaisedException.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "userfunc_exception", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging", "modulename": "doctable.parallel.messaging", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.BaseMessage", "modulename": "doctable.parallel.messaging", "qualname": "BaseMessage", "type": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.BaseMessage.__init__", "modulename": "doctable.parallel.messaging", "qualname": "BaseMessage.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging.DataPayload", "modulename": "doctable.parallel.messaging", "qualname": "DataPayload", "type": "class", "doc": "<p>For passing data to/from Workers.</p>\n"}, {"fullname": "doctable.parallel.messaging.DataPayload.__init__", "modulename": "doctable.parallel.messaging", "qualname": "DataPayload.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data", "ind", "pid"], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging.DataPayload.data", "modulename": "doctable.parallel.messaging", "qualname": "DataPayload.data", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.DataPayload.ind", "modulename": "doctable.parallel.messaging", "qualname": "DataPayload.ind", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.DataPayload.pid", "modulename": "doctable.parallel.messaging", "qualname": "DataPayload.pid", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.StatusRequest", "modulename": "doctable.parallel.messaging", "qualname": "StatusRequest", "type": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.StatusRequest.__init__", "modulename": "doctable.parallel.messaging", "qualname": "StatusRequest.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging.WorkerStatus", "modulename": "doctable.parallel.messaging", "qualname": "WorkerStatus", "type": "class", "doc": "<p>WorkerStatus(pid: int = 596074, start_ts: int = <factory>, time_waiting: int = 0, time_working: int = 0, jobs_finished: int = 0, uptime: int = None)</p>\n"}, {"fullname": "doctable.parallel.messaging.WorkerStatus.__init__", "modulename": "doctable.parallel.messaging", "qualname": "WorkerStatus.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pid", "start_ts", "time_waiting", "time_working", "jobs_finished", "uptime"], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging.WorkerStatus.pid", "modulename": "doctable.parallel.messaging", "qualname": "WorkerStatus.pid", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.WorkerStatus.start_ts", "modulename": "doctable.parallel.messaging", "qualname": "WorkerStatus.start_ts", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.WorkerStatus.time_waiting", "modulename": "doctable.parallel.messaging", "qualname": "WorkerStatus.time_waiting", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.WorkerStatus.time_working", "modulename": "doctable.parallel.messaging", "qualname": "WorkerStatus.time_working", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.WorkerStatus.jobs_finished", "modulename": "doctable.parallel.messaging", "qualname": "WorkerStatus.jobs_finished", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.WorkerStatus.uptime", "modulename": "doctable.parallel.messaging", "qualname": "WorkerStatus.uptime", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.WorkerStatus.update_uptime", "modulename": "doctable.parallel.messaging", "qualname": "WorkerStatus.update_uptime", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging.WorkerStatus.efficiency", "modulename": "doctable.parallel.messaging", "qualname": "WorkerStatus.efficiency", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging.WorkerStatus.total_efficiency", "modulename": "doctable.parallel.messaging", "qualname": "WorkerStatus.total_efficiency", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging.WorkerStatus.sec_per_job", "modulename": "doctable.parallel.messaging", "qualname": "WorkerStatus.sec_per_job", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging.UserFunc", "modulename": "doctable.parallel.messaging", "qualname": "UserFunc", "type": "class", "doc": "<p>Contains a user function and data to be passed to it when calling.\nSent to a process upon init and when function should be changed.</p>\n"}, {"fullname": "doctable.parallel.messaging.UserFunc.__init__", "modulename": "doctable.parallel.messaging", "qualname": "UserFunc.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "func", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging.UserFunc.func", "modulename": "doctable.parallel.messaging", "qualname": "UserFunc.func", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.UserFunc.args", "modulename": "doctable.parallel.messaging", "qualname": "UserFunc.args", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.UserFunc.kwargs", "modulename": "doctable.parallel.messaging", "qualname": "UserFunc.kwargs", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.messaging.UserFunc.execute", "modulename": "doctable.parallel.messaging", "qualname": "UserFunc.execute", "type": "function", "doc": "<p>Call function passing <em>args and *</em>kwargs.</p>\n", "parameters": ["self", "data"], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging.SigClose", "modulename": "doctable.parallel.messaging", "qualname": "SigClose", "type": "class", "doc": "<p>WorkerResource telling Worker to close.</p>\n"}, {"fullname": "doctable.parallel.messaging.SigClose.__init__", "modulename": "doctable.parallel.messaging", "qualname": "SigClose.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging.WorkerError", "modulename": "doctable.parallel.messaging", "qualname": "WorkerError", "type": "class", "doc": "<p>Sent from Worker to WorkerResource when any worker exception is passed \n(not userfunc).</p>\n"}, {"fullname": "doctable.parallel.messaging.WorkerError.__init__", "modulename": "doctable.parallel.messaging", "qualname": "WorkerError.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "exception"], "funcdef": "def"}, {"fullname": "doctable.parallel.messaging.UserFuncException", "modulename": "doctable.parallel.messaging", "qualname": "UserFuncException", "type": "class", "doc": "<p>Passes exception from user function to main thread (and lets it know \nthere was an error with the user function).</p>\n"}, {"fullname": "doctable.parallel.messaging.UserFuncException.__init__", "modulename": "doctable.parallel.messaging", "qualname": "UserFuncException.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "exception"], "funcdef": "def"}, {"fullname": "doctable.parallel.worker", "modulename": "doctable.parallel.worker", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.worker.Worker", "modulename": "doctable.parallel.worker", "qualname": "Worker", "type": "class", "doc": "<p>Basic worker meant to be run in a process.</p>\n"}, {"fullname": "doctable.parallel.worker.Worker.__init__", "modulename": "doctable.parallel.worker", "qualname": "Worker.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "pipe", "userfunc", "gcollect", "verbose", "logging", "status"], "funcdef": "def"}, {"fullname": "doctable.parallel.worker.Worker.pipe", "modulename": "doctable.parallel.worker", "qualname": "Worker.pipe", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.worker.Worker.userfunc", "modulename": "doctable.parallel.worker", "qualname": "Worker.userfunc", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.worker.Worker.gcollect", "modulename": "doctable.parallel.worker", "qualname": "Worker.gcollect", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.worker.Worker.verbose", "modulename": "doctable.parallel.worker", "qualname": "Worker.verbose", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.worker.Worker.logging", "modulename": "doctable.parallel.worker", "qualname": "Worker.logging", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.worker.Worker.status", "modulename": "doctable.parallel.worker", "qualname": "Worker.status", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.worker.Worker.pid", "modulename": "doctable.parallel.worker", "qualname": "Worker.pid", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.worker.Worker.execute_and_send", "modulename": "doctable.parallel.worker", "qualname": "Worker.execute_and_send", "type": "function", "doc": "<p>Execute the provide function on the payload (modifies in-place), and return it.</p>\n", "parameters": ["self", "payload"], "funcdef": "def"}, {"fullname": "doctable.parallel.worker.Worker.recv", "modulename": "doctable.parallel.worker", "qualname": "Worker.recv", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.worker.Worker.send", "modulename": "doctable.parallel.worker", "qualname": "Worker.send", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "data"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerpool", "modulename": "doctable.parallel.workerpool", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.workerpool.WorkerPool", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool", "type": "class", "doc": "<p>WorkerPool(num_workers: int, logging: bool = True, verbose: bool = False, method: str = 'forkserver', workers: List[doctable.parallel.workerresource.WorkerResource] = <factory>)</p>\n"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.__init__", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "num_workers", "logging", "verbose", "method", "workers"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.num_workers", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.num_workers", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.logging", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.logging", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.verbose", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.verbose", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.method", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.method", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.workers", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.workers", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.any_alive", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.any_alive", "type": "function", "doc": "<p>Check if any processes are alive.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.start", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.start", "type": "function", "doc": "<p>Start workers.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.update_userfunc", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.update_userfunc", "type": "function", "doc": "<p>Update userfunction of all workers.</p>\n", "parameters": ["self", "func", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.get_statuses", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.get_statuses", "type": "function", "doc": "<p>Get statuses of each process (includes uptime, efficiency, etc).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.av_efficiency", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.av_efficiency", "type": "function", "doc": "<p>Get average time spent working on jobs vs time spent waiting for new data.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.av_total_efficiency", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.av_total_efficiency", "type": "function", "doc": "<p>Average time working on jobs vs lifetime of process.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.av_sec_per_job", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.av_sec_per_job", "type": "function", "doc": "<p>Average number of seconds to complete each job.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.map", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.map", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "func", "elements", "worker_args", "worker_kwargs"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.join", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.join", "type": "function", "doc": "<p>Attempt to join each worker, delete workers.</p>\n", "parameters": ["self", "check"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.terminate", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.terminate", "type": "function", "doc": "<p>Attempt to terminate each worker, delete workers.</p>\n", "parameters": ["self", "check"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerpool.WorkerPool.apply", "modulename": "doctable.parallel.workerpool", "qualname": "WorkerPool.apply", "type": "function", "doc": "<p>Apply a function to each worker if it is alive.</p>\n", "parameters": ["self", "func", "check"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource", "modulename": "doctable.parallel.workerresource", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.workerresource.WorkerResource", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource", "type": "class", "doc": "<p>Manages a worker process and pipe to it.</p>\n"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.__init__", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.__init__", "type": "function", "doc": "<p>Open Process and pipe to it.</p>\n", "parameters": ["self", "target", "start", "args", "kwargs", "logging", "verbose", "method"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.verbose", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.verbose", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.proc", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.proc", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.poll", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.poll", "type": "function", "doc": "<p>Check if worker sent anything.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.execute", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.execute", "type": "function", "doc": "<p>Send data to worker and blocking return result upon reception.</p>\n", "parameters": ["self", "data"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.recv_data", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.recv_data", "type": "function", "doc": "<p>Receive raw data from user function.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.send_data", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.send_data", "type": "function", "doc": "<p>Send any data to worker process to be handled by user function.</p>\n", "parameters": ["self", "data", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.update_userfunc", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.update_userfunc", "type": "function", "doc": "<p>Send a new UserFunc to worker process.</p>\n", "parameters": ["self", "func", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.get_status", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.get_status", "type": "function", "doc": "<p>Blocking request status update from worker.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.send_payload", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.send_payload", "type": "function", "doc": "<p>Send a Message (DataPayload or otherwise) to worker process.</p>\n", "parameters": ["self", "payload"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.recv", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.recv", "type": "function", "doc": "<p>Return received DataPayload or raise exception.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.pid", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.pid", "type": "variable", "doc": "<p>Get process id from worker.</p>\n"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.is_alive", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.is_alive", "type": "function", "doc": "<p>Get status of process.</p>\n", "parameters": ["self", "arsg", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.start", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.start", "type": "function", "doc": "<p>Start the process, throws WorkerIsAliveError if already alive.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.join", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.join", "type": "function", "doc": "<p>Send SigClose() to Worker and then wait for it to die.</p>\n", "parameters": ["self", "check_alive"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.terminate", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.terminate", "type": "function", "doc": "<p>Send terminate signal to worker.</p>\n", "parameters": ["self", "check_alive"], "funcdef": "def"}, {"fullname": "doctable.parallel.workerresource.WorkerResource.pipe", "modulename": "doctable.parallel.workerresource", "qualname": "WorkerResource.pipe", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.parse", "modulename": "doctable.parse", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.parse.parsefuncs", "modulename": "doctable.parse.parsefuncs", "qualname": "", "type": "module", "doc": "<p>These functions are used as wrappers around SpaCy parsers, and can be used\neither standalone or as part of a doctable.ParsePipeline.</p>\n\n<p>The two primary parse functions here are <code>tokenize</code> and <code>get_parsetrees</code>.\nUse <code>tokenize</code> when you want to extract lists of tokens (split by sentence\nor not) and <code>get_parsetrees</code> when you'd like to extract condensed versions\nof SpaCy parsetrees.</p>\n\n<p>The <code>tokenize</code> function accepts two parameters, <code>keep_tok_func</code> and \n<code>parse_tok_func</code>, which can be custom or optionally filled by \n<code>keep_tok</code> and <code>parse_tok</code>. These methods are also registered as \ncomponents in <code>doctable.ParsePipeline</code>, so can be accessed using \n<code>doctable.Comp()</code> as shown below.</p>\n\n<pre><code># add pipeline components\nparser = doctable.ParsePipeline([\n    spacy.load('en'), # first run spacy parser\n    doctable.Comp('tokenize', **{\n        'split_sents': False,\n        'keep_tok_func': doctable.Comp('keep_tok'),\n        'parse_tok_func': doctable.Comp('parse_tok'),\n    })\n])\n</code></pre>\n\n<p>A more complete <code>ParsePipeline</code> example might look like the code below.\nThis example uses the <code>merge_tok_spans</code> function to merge named entities as\nsingle tokens in SpaCy then uses the <code>tokenize</code> function in conjunction \nwith <code>keep_tok</code> (which drops whitespace tokens but keeps punctuation and \nstopwords) and <code>parse_tok</code> (which capitalizes named entities, replaces \nnumbers with \"NUM\", and does not lemmatize tokens).</p>\n\n<pre><code>parser = doctable.ParsePipeline([\n    spacy.load('en'), # spacy nlp parser object\n\n    # merge spacy multi-word named entities (doctable.parse.merge_tok_spans)\n    Comp('merge_tok_spans', merge_ents=True, merge_noun_chunks=False),\n\n    # tokenize document\n    Comp('tokenize', **{\n        'split_sents': False,\n\n        # choose tokens to keep (doctable.parse.keep_tok)\n        'keep_tok_func': Comp('keep_tok', **{\n            'keep_whitespace': False, # don't keep whitespace\n            'keep_punct': True, # keep punctuation and stopwords\n            'keep_stop': True,\n        }),\n\n        # choose how to convert Spacy token t text (doctable.parse.parse_tok)\n        'parse_tok_func': Comp('parse_tok', **{\n            'format_ents': True,\n            'lemmatize': False,\n            'num_replacement': 'NUM',\n            'ent_convert': lambda e: e.text.upper(), # function to capitalize named entities\n        })\n    })\n])\n</code></pre>\n"}, {"fullname": "doctable.parse.parsefuncs.preprocess", "modulename": "doctable.parse.parsefuncs", "qualname": "preprocess", "type": "function", "doc": "<p>A few useful preprocessing functions for raw text.\nArgs:\n    text (str): document as a text string\n    replace_url (str or None): if not None, replace url with string\n    replace_xml (str or None): if not None, replace xml tags with string\n    replace_digits (str or None): if not None, replace digits with string</p>\n", "parameters": ["text", "replace_url", "replace_xml", "replace_digits"], "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.identity", "modulename": "doctable.parse.parsefuncs", "qualname": "identity", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.tokenize", "modulename": "doctable.parse.parsefuncs", "qualname": "tokenize", "type": "function", "doc": "<p>Convert spacy doc into a series of tokens (as sentences or not).\nArgs:\n    split_sents (bool): parse into list of sentence tokens using doc.sents.\n    merge_ents (bool): merge multi_word entities into same token.\n    ngrams (iter<iter<str>&gt;): iterable of token tuples to merge after parsing.\n    spacy_ngram_matcher (spacy Matcher): matcher object to use on the spacy doc.\n        Normally will create using spacy.Matcher(nlp.vocab), see more details\n        at https://spacy.io/usage/rule-based-matching And also note that the \n        nlp object must be the one used for parsing.\n    keep_tok_func (func): func used to decide to keep func or not. Default is\n        identity function\n    parse_tok_func (func): func used to parse tokens. By default uses \n        identify function.</p>\n", "parameters": ["doc", "split_sents", "keep_tok_func", "parse_tok_func"], "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.parse_tok", "modulename": "doctable.parse.parsefuncs", "qualname": "parse_tok", "type": "function", "doc": "<p>Convert spacy token object to string.\nArgs:\n    tok (spacy token or span): token object to convert to string.\n    replace_num (str/None): Replace number following tok.like_num (includes \"five\", \n        or 5) with a special token (i.e. __NUM__). None means no replacement.\n    replace_digit (str/None): Replace digit meeting tok.is_digit with special token. \n        Only used when replace_num is None.\n    lemmatize (bool): return lemma instead of full word.\n    normal_convert (func): custom conversion function to happen as last step\n        for non-entities. This way can keep all other functionality.\n    format_ents (bool): Replace whitespace with space and capitalize first \n        letter of ents.\n    ent_convert (func): custom conversion function to happen as last step\n        for entities. This way can keep all other functionality.</p>\n", "parameters": ["tok", "num_replacement", "digit_replacement", "lemmatize", "normal_tok_parse", "format_ents", "ent_convert"], "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.keep_tok", "modulename": "doctable.parse.parsefuncs", "qualname": "keep_tok", "type": "function", "doc": "<p>Decide to use token or not (can be overridden).\nArgs:\n    keep_whitespace (bool): keep all-whitespace tokens.\n    keep_punct (bool): keep punctuation.\n    keep_stop (bool): keep stopwords.\n    keep_num (bool): keep numbers using tok.is_num.\n    keep_digit (bool): keep digits using tok.is_digit.\n    keep_ents (bool): keep named entities\n    keep_ent_types (list<str>): keep only these entity types\n    rm_ent_types (list<str>): remove these entity types\n    keep_pos (list<str>): keep only toks with these POS\n    rm_pos (list<str>): remove toks with these POS\n    addtnl_func (func): additional custom criteria to meet\nReturns:\n    True if token should be kept.</p>\n", "parameters": ["tok", "keep_whitespace", "keep_punct", "keep_stop", "keep_digit", "keep_num", "keep_ents", "keep_ent_types", "rm_ent_types", "keep_pos", "rm_pos", "addtnl_func"], "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.merge_tok_spans", "modulename": "doctable.parse.parsefuncs", "qualname": "merge_tok_spans", "type": "function", "doc": "<p>Apply merges to doc object including entities, normal ngrams, and noun chunks.\nArgs:\n    doc (Spacy Doc object): doc to merge spans in\n    merge_ents (bool): combine multi-word entities using spacy doc.retokenize()\n    spacy_ngram_matcher (spacy Matcher object): rule-based matching object for \n        ngrams in Spacy. See https://spacy.io/usage/rule-based-matching\n    merge_noun_chunks (bool): automatically merge noun chunks</p>\n", "parameters": ["doc", "merge_ents", "spacy_ngram_matcher", "merge_noun_chunks"], "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.merge_tok_ngrams", "modulename": "doctable.parse.parsefuncs", "qualname": "merge_tok_ngrams", "type": "function", "doc": "<p>Merges manually specified consecutive tokens into single tokens.\nArgs:\n    toks (list<str>): token list through which to search for ngrams.\n    ngrams (list<list<str>&gt;): list of ngrams (as sequence of str) to \n        combine into single tokens.\n    ngram_sep (str): string to join ngram parts with.</p>\n", "parameters": ["toks", "ngrams", "ngram_sep"], "funcdef": "def"}, {"fullname": "doctable.parse.parsefuncs.get_parsetrees", "modulename": "doctable.parse.parsefuncs", "qualname": "get_parsetrees", "type": "function", "doc": "<p>Extracts parsetree from spacy doc objects.\nArgs:\n    doc (spacy.Doc object): doc to generate parsetree from.\n    parse_tok_func (func<spacy.Token, str>): function used to convert token to \n        a string representation. Usually a lambda function \n        wrapping some variant of self.parse_tok().\n    userdata_map (dict<str->func>): attribute to function \n        mapping. Functions take a token and output a property\n        that will be stored in each parsetree node.</p>\n", "parameters": ["doc", "text_parse_func", "userdata_map"], "funcdef": "def"}, {"fullname": "doctable.parse.pipeline", "modulename": "doctable.parse.pipeline", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.parse.pipeline.Comp", "modulename": "doctable.parse.pipeline", "qualname": "Comp", "type": "function", "doc": "<p>Returns a pipeline component as a function with one positional arg.\n    See components in this file to see available mappings.\nArgs:\n    <em>args: passed directly to component function\n    *</em>kwargs: passed directly to component function</p>\n", "parameters": ["func", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.parse.pipeline.MultiComp", "modulename": "doctable.parse.pipeline", "qualname": "MultiComp", "type": "function", "doc": "<p>Add a component that returns a dictionary, each with separate parsers.\nArgs:\n    funcs (dict<str:func>): mapping from string to dictionary</p>\n", "parameters": ["funcs"], "funcdef": "def"}, {"fullname": "doctable.parse.pipeline.funcwrap", "modulename": "doctable.parse.pipeline", "qualname": "funcwrap", "type": "function", "doc": "<p>Used in MultiComp.</p>\n", "parameters": ["x", "funcs"], "funcdef": "def"}, {"fullname": "doctable.parse.pipeline.ParsePipeline", "modulename": "doctable.parse.pipeline", "qualname": "ParsePipeline", "type": "class", "doc": "<p>Class for creating pipelines for parsing text documents (or other elements).\nPrimarily</p>\n"}, {"fullname": "doctable.parse.pipeline.ParsePipeline.__init__", "modulename": "doctable.parse.pipeline", "qualname": "ParsePipeline.__init__", "type": "function", "doc": "<p>Args:\n    components (list<func>): list of components/functions to apply to the \n        input sequentially. See the component function in this script to \n        generate components.</p>\n", "parameters": ["self", "components"], "funcdef": "def"}, {"fullname": "doctable.parse.pipeline.ParsePipeline.parse", "modulename": "doctable.parse.pipeline", "qualname": "ParsePipeline.parse", "type": "function", "doc": "<p>Parses document by applying each component function to doctext in turn.\nArgs:\n    doctext (str): text to be parsed. This can actually be anything to put into\n        a pipeline.\nReturns:\n    single parsed document object, output of last pipeline function</p>\n", "parameters": ["self", "doctext"], "funcdef": "def"}, {"fullname": "doctable.parse.pipeline.ParsePipeline.parsemany", "modulename": "doctable.parse.pipeline", "qualname": "ParsePipeline.parsemany", "type": "function", "doc": "<p>Parse multiple documents distributed across workers.\nArgs:\n    doctexts (list<str>): elements to be parsed\n    workers (int): number of processes to use\n    override_maxcores (bool): in cases where processes may have\n        low CPU utilization, you may want to create more processes\n        than your computer has cores.\nReturns:\n    list of parsed elements</p>\n", "parameters": ["self", "doctexts", "workers", "override_maxcores"], "funcdef": "def"}, {"fullname": "doctable.parse.pipeline.ParsePipeline.parsemany_thread", "modulename": "doctable.parse.pipeline", "qualname": "ParsePipeline.parsemany_thread", "type": "function", "doc": "<p>Helper for .parsemany().</p>\n", "parameters": ["doctexts", "parser"], "funcdef": "def"}, {"fullname": "doctable.schemas", "modulename": "doctable.schemas", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.coltype_map", "modulename": "doctable.schemas.coltype_map", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.constraints", "modulename": "doctable.schemas.constraints", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.constraints.ConstraintNotFoundError", "modulename": "doctable.schemas.constraints", "qualname": "ConstraintNotFoundError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.schemas.constraints.Constraint", "modulename": "doctable.schemas.constraints", "qualname": "Constraint", "type": "function", "doc": "<p>Return an sqlalchemy constraint.\nArgs:\n    constraint_type: from doctable.constraint_lookup.keys()</p>\n", "parameters": ["constraint_type", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes", "modulename": "doctable.schemas.custom_coltypes", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeControl", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeControl", "type": "class", "doc": "<p>All instances of FileTypeBase will have a reference to this object.</p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeControl.__init__", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeControl.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "folder"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeControl.select_raw_fname", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeControl.select_raw_fname", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeControl.full_path", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeControl.full_path", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "fname"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeBase", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeBase", "type": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n:class:<code>.TypeEngine</code> class.  Alternatively, the :meth:<code>load_dialect_impl</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the :meth:<code>TypeDecorator.coerce_compared_value</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n:meth:<code>~TypeDecorator.coerce_compared_value</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<p>.. warning::</p>\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\n   by default from that of the base type</strong>.\n   If the :class:<code>.TypeDecorator</code> is augmenting a\n   type that requires special logic for certain types of operators,\n   this method <strong>must</strong> be overridden.  A key example is when decorating\n   the :class:<code>_postgresql.JSON</code> and :class:<code>_postgresql.JSONB</code> types;\n   the default rules of :meth:<code>.TypeEngine.coerce_compared_value</code> should\n   be used in order to deal with operators like index operations::</p>\n\n<pre><code>    class MyJsonType(TypeDecorator):\n        impl = postgresql.JSON\n\n        def coerce_compared_value(self, op, value):\n            return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\n   will cause the index value <code>'foo'</code> to be JSON encoded.</p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeBase.__init__", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeBase.__init__", "type": "function", "doc": "<p>Construct a :class:<code>.TypeDecorator</code>.</p>\n\n<p>Arguments sent here are passed to the constructor\nof the class assigned to the <code>impl</code> class level attribute,\nassuming the <code>impl</code> is a callable, and the resulting\nobject is assigned to the <code>self.impl</code> instance attribute\n(thus overriding the class attribute of the same name).</p>\n\n<p>If the class level <code>impl</code> is not a callable (the unusual case),\nit will be assigned to the same instance attribute 'as-is',\nignoring those arguments passed to the constructor.</p>\n\n<p>Subclasses can override this to customize the generation\nof <code>self.impl</code> entirely.</p>\n", "parameters": ["self", "arg", "folder", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeBase.impl", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeBase.impl", "type": "class", "doc": "<p>The base for all string and character types.</p>\n\n<p>In SQL, corresponds to VARCHAR.  Can also take Python unicode objects\nand encode to the database's encoding in bind params (and the reverse for\nresult sets.)</p>\n\n<p>The <code>length</code> field is usually required when the <code>String</code> type is\nused within a CREATE TABLE statement, as VARCHAR requires a length\non most databases.</p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeBase.file_ext", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeBase.file_ext", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeBase.fname_num_size", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeBase.fname_num_size", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeBase.path", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeBase.path", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeBase.dump_data", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeBase.dump_data", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "f", "value", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeBase.load_data", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeBase.load_data", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "f", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeBase.process_bind_param", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeBase.process_bind_param", "type": "function", "doc": "<p>Receive a bound parameter value to be converted.</p>\n\n<p>Subclasses override this method to return the\nvalue that should be passed along to the underlying\n:class:<code>.TypeEngine</code> object, and from there to the\nDBAPI <code>execute()</code> method.</p>\n\n<p>The operation could be anything desired to perform custom\nbehavior, such as transforming or serializing data.\nThis could also be used as a hook for validating logic.</p>\n\n<p>This operation should be designed with the reverse operation\nin mind, which would be the process_result_value method of\nthis class.</p>\n\n<p>:param value: Data to operate upon, of any type expected by\n this method in the subclass.  Can be <code>None</code>.\n:param dialect: the :class:<code>.Dialect</code> in use.</p>\n", "parameters": ["self", "value", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.FileTypeBase.process_result_value", "modulename": "doctable.schemas.custom_coltypes", "qualname": "FileTypeBase.process_result_value", "type": "function", "doc": "<p>Receive a result-row column value to be converted.</p>\n\n<p>Subclasses should implement this method to operate on data\nfetched from the database.</p>\n\n<p>Subclasses override this method to return the\nvalue that should be passed back to the application,\ngiven a value that is already processed by\nthe underlying :class:<code>.TypeEngine</code> object, originally\nfrom the DBAPI cursor method <code>fetchone()</code> or similar.</p>\n\n<p>The operation could be anything desired to perform custom\nbehavior, such as transforming or serializing data.\nThis could also be used as a hook for validating logic.</p>\n\n<p>:param value: Data to operate upon, of any type expected by\n this method in the subclass.  Can be <code>None</code>.\n:param dialect: the :class:<code>.Dialect</code> in use.</p>\n\n<p>This operation should be designed to be reversible by\nthe \"process_bind_param\" method of this class.</p>\n", "parameters": ["self", "fname", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.PickleFileType", "modulename": "doctable.schemas.custom_coltypes", "qualname": "PickleFileType", "type": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n:class:<code>.TypeEngine</code> class.  Alternatively, the :meth:<code>load_dialect_impl</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the :meth:<code>TypeDecorator.coerce_compared_value</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n:meth:<code>~TypeDecorator.coerce_compared_value</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<p>.. warning::</p>\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\n   by default from that of the base type</strong>.\n   If the :class:<code>.TypeDecorator</code> is augmenting a\n   type that requires special logic for certain types of operators,\n   this method <strong>must</strong> be overridden.  A key example is when decorating\n   the :class:<code>_postgresql.JSON</code> and :class:<code>_postgresql.JSONB</code> types;\n   the default rules of :meth:<code>.TypeEngine.coerce_compared_value</code> should\n   be used in order to deal with operators like index operations::</p>\n\n<pre><code>    class MyJsonType(TypeDecorator):\n        impl = postgresql.JSON\n\n        def coerce_compared_value(self, op, value):\n            return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\n   will cause the index value <code>'foo'</code> to be JSON encoded.</p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.PickleFileType.file_ext", "modulename": "doctable.schemas.custom_coltypes", "qualname": "PickleFileType.file_ext", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.PickleFileType.dump_data", "modulename": "doctable.schemas.custom_coltypes", "qualname": "PickleFileType.dump_data", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "f", "value", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.PickleFileType.load_data", "modulename": "doctable.schemas.custom_coltypes", "qualname": "PickleFileType.load_data", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "f", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.ParseTreeDocFileType", "modulename": "doctable.schemas.custom_coltypes", "qualname": "ParseTreeDocFileType", "type": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n:class:<code>.TypeEngine</code> class.  Alternatively, the :meth:<code>load_dialect_impl</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the :meth:<code>TypeDecorator.coerce_compared_value</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n:meth:<code>~TypeDecorator.coerce_compared_value</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<p>.. warning::</p>\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\n   by default from that of the base type</strong>.\n   If the :class:<code>.TypeDecorator</code> is augmenting a\n   type that requires special logic for certain types of operators,\n   this method <strong>must</strong> be overridden.  A key example is when decorating\n   the :class:<code>_postgresql.JSON</code> and :class:<code>_postgresql.JSONB</code> types;\n   the default rules of :meth:<code>.TypeEngine.coerce_compared_value</code> should\n   be used in order to deal with operators like index operations::</p>\n\n<pre><code>    class MyJsonType(TypeDecorator):\n        impl = postgresql.JSON\n\n        def coerce_compared_value(self, op, value):\n            return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\n   will cause the index value <code>'foo'</code> to be JSON encoded.</p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.ParseTreeDocFileType.file_ext", "modulename": "doctable.schemas.custom_coltypes", "qualname": "ParseTreeDocFileType.file_ext", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.ParseTreeDocFileType.dump_data", "modulename": "doctable.schemas.custom_coltypes", "qualname": "ParseTreeDocFileType.dump_data", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "f", "value", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.ParseTreeDocFileType.load_data", "modulename": "doctable.schemas.custom_coltypes", "qualname": "ParseTreeDocFileType.load_data", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "f", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.TextFileType", "modulename": "doctable.schemas.custom_coltypes", "qualname": "TextFileType", "type": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n:class:<code>.TypeEngine</code> class.  Alternatively, the :meth:<code>load_dialect_impl</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the :meth:<code>TypeDecorator.coerce_compared_value</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n:meth:<code>~TypeDecorator.coerce_compared_value</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<p>.. warning::</p>\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\n   by default from that of the base type</strong>.\n   If the :class:<code>.TypeDecorator</code> is augmenting a\n   type that requires special logic for certain types of operators,\n   this method <strong>must</strong> be overridden.  A key example is when decorating\n   the :class:<code>_postgresql.JSON</code> and :class:<code>_postgresql.JSONB</code> types;\n   the default rules of :meth:<code>.TypeEngine.coerce_compared_value</code> should\n   be used in order to deal with operators like index operations::</p>\n\n<pre><code>    class MyJsonType(TypeDecorator):\n        impl = postgresql.JSON\n\n        def coerce_compared_value(self, op, value):\n            return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\n   will cause the index value <code>'foo'</code> to be JSON encoded.</p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.TextFileType.file_ext", "modulename": "doctable.schemas.custom_coltypes", "qualname": "TextFileType.file_ext", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.TextFileType.dump_data", "modulename": "doctable.schemas.custom_coltypes", "qualname": "TextFileType.dump_data", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "f", "text", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.TextFileType.load_data", "modulename": "doctable.schemas.custom_coltypes", "qualname": "TextFileType.load_data", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "f", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.JSONFileType", "modulename": "doctable.schemas.custom_coltypes", "qualname": "JSONFileType", "type": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n:class:<code>.TypeEngine</code> class.  Alternatively, the :meth:<code>load_dialect_impl</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the :meth:<code>TypeDecorator.coerce_compared_value</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n:meth:<code>~TypeDecorator.coerce_compared_value</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<p>.. warning::</p>\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\n   by default from that of the base type</strong>.\n   If the :class:<code>.TypeDecorator</code> is augmenting a\n   type that requires special logic for certain types of operators,\n   this method <strong>must</strong> be overridden.  A key example is when decorating\n   the :class:<code>_postgresql.JSON</code> and :class:<code>_postgresql.JSONB</code> types;\n   the default rules of :meth:<code>.TypeEngine.coerce_compared_value</code> should\n   be used in order to deal with operators like index operations::</p>\n\n<pre><code>    class MyJsonType(TypeDecorator):\n        impl = postgresql.JSON\n\n        def coerce_compared_value(self, op, value):\n            return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\n   will cause the index value <code>'foo'</code> to be JSON encoded.</p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.JSONFileType.file_ext", "modulename": "doctable.schemas.custom_coltypes", "qualname": "JSONFileType.file_ext", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.JSONFileType.dump_data", "modulename": "doctable.schemas.custom_coltypes", "qualname": "JSONFileType.dump_data", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "f", "value", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.JSONFileType.load_data", "modulename": "doctable.schemas.custom_coltypes", "qualname": "JSONFileType.load_data", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "f", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.CpickleType", "modulename": "doctable.schemas.custom_coltypes", "qualname": "CpickleType", "type": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n:class:<code>.TypeEngine</code> class.  Alternatively, the :meth:<code>load_dialect_impl</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the :meth:<code>TypeDecorator.coerce_compared_value</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n:meth:<code>~TypeDecorator.coerce_compared_value</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<p>.. warning::</p>\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\n   by default from that of the base type</strong>.\n   If the :class:<code>.TypeDecorator</code> is augmenting a\n   type that requires special logic for certain types of operators,\n   this method <strong>must</strong> be overridden.  A key example is when decorating\n   the :class:<code>_postgresql.JSON</code> and :class:<code>_postgresql.JSONB</code> types;\n   the default rules of :meth:<code>.TypeEngine.coerce_compared_value</code> should\n   be used in order to deal with operators like index operations::</p>\n\n<pre><code>    class MyJsonType(TypeDecorator):\n        impl = postgresql.JSON\n\n        def coerce_compared_value(self, op, value):\n            return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\n   will cause the index value <code>'foo'</code> to be JSON encoded.</p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.CpickleType.impl", "modulename": "doctable.schemas.custom_coltypes", "qualname": "CpickleType.impl", "type": "class", "doc": "<p>A type for large binary byte data.</p>\n\n<p>The :class:<code>.LargeBinary</code> type corresponds to a large and/or unlengthed\nbinary type for the target platform, such as BLOB on MySQL and BYTEA for\nPostgreSQL.  It also handles the necessary conversions for the DBAPI.</p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.CpickleType.process_bind_param", "modulename": "doctable.schemas.custom_coltypes", "qualname": "CpickleType.process_bind_param", "type": "function", "doc": "<p>Receive a bound parameter value to be converted.</p>\n\n<p>Subclasses override this method to return the\nvalue that should be passed along to the underlying\n:class:<code>.TypeEngine</code> object, and from there to the\nDBAPI <code>execute()</code> method.</p>\n\n<p>The operation could be anything desired to perform custom\nbehavior, such as transforming or serializing data.\nThis could also be used as a hook for validating logic.</p>\n\n<p>This operation should be designed with the reverse operation\nin mind, which would be the process_result_value method of\nthis class.</p>\n\n<p>:param value: Data to operate upon, of any type expected by\n this method in the subclass.  Can be <code>None</code>.\n:param dialect: the :class:<code>.Dialect</code> in use.</p>\n", "parameters": ["self", "value", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.CpickleType.process_result_value", "modulename": "doctable.schemas.custom_coltypes", "qualname": "CpickleType.process_result_value", "type": "function", "doc": "<p>Receive a result-row column value to be converted.</p>\n\n<p>Subclasses should implement this method to operate on data\nfetched from the database.</p>\n\n<p>Subclasses override this method to return the\nvalue that should be passed back to the application,\ngiven a value that is already processed by\nthe underlying :class:<code>.TypeEngine</code> object, originally\nfrom the DBAPI cursor method <code>fetchone()</code> or similar.</p>\n\n<p>The operation could be anything desired to perform custom\nbehavior, such as transforming or serializing data.\nThis could also be used as a hook for validating logic.</p>\n\n<p>:param value: Data to operate upon, of any type expected by\n this method in the subclass.  Can be <code>None</code>.\n:param dialect: the :class:<code>.Dialect</code> in use.</p>\n\n<p>This operation should be designed to be reversible by\nthe \"process_bind_param\" method of this class.</p>\n", "parameters": ["self", "value", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.JSONType", "modulename": "doctable.schemas.custom_coltypes", "qualname": "JSONType", "type": "class", "doc": "<p>Allows the creation of types which add additional functionality\nto an existing type.</p>\n\n<p>This method is preferred to direct subclassing of SQLAlchemy's\nbuilt-in types as it ensures that all required functionality of\nthe underlying type is kept in place.</p>\n\n<p>Typical usage::</p>\n\n<p>import sqlalchemy.types as types</p>\n\n<p>class MyType(types.TypeDecorator):\n      '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n      strips it off on the way out.\n      '''</p>\n\n<pre><code>  impl = types.Unicode\n\n  def process_bind_param(self, value, dialect):\n      return \"PREFIX:\" + value\n\n  def process_result_value(self, value, dialect):\n      return value[7:]\n\n  def copy(self, **kw):\n      return MyType(self.impl.length)\n</code></pre>\n\n<p>The class-level <code>impl</code> attribute is required, and can reference any\n:class:<code>.TypeEngine</code> class.  Alternatively, the :meth:<code>load_dialect_impl</code>\nmethod can be used to provide different type classes based on the dialect\ngiven; in this case, the <code>impl</code> variable can reference\n<code>TypeEngine</code> as a placeholder.</p>\n\n<p>Types that receive a Python type that isn't similar to the ultimate type\nused may want to define the :meth:<code>TypeDecorator.coerce_compared_value</code>\nmethod. This is used to give the expression system a hint when coercing\nPython objects into bind parameters within expressions. Consider this\nexpression::</p>\n\n<pre><code>mytable.c.somecol + datetime.date(2009, 5, 15)\n</code></pre>\n\n<p>Above, if \"somecol\" is an <code>Integer</code> variant, it makes sense that\nwe're doing date arithmetic, where above is usually interpreted\nby databases as adding a number of days to the given date.\nThe expression system does the right thing by not attempting to\ncoerce the \"date()\" value into an integer-oriented bind parameter.</p>\n\n<p>However, in the case of <code>TypeDecorator</code>, we are usually changing an\nincoming Python type to something new - <code>TypeDecorator</code> by default will\n\"coerce\" the non-typed side to be the same type as itself. Such as below,\nwe define an \"epoch\" type that stores a date value as an integer::</p>\n\n<pre><code>class MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n</code></pre>\n\n<p>Our expression of <code>somecol + date</code> with the above type will coerce the\n\"date\" on the right side to also be treated as <code>MyEpochType</code>.</p>\n\n<p>This behavior can be overridden via the\n:meth:<code>~TypeDecorator.coerce_compared_value</code> method, which returns a type\nthat should be used for the value of the expression. Below we set it such\nthat an integer value will be treated as an <code>Integer</code>, and any other\nvalue is assumed to be a date and will be treated as a <code>MyEpochType</code>::</p>\n\n<pre><code>def coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n</code></pre>\n\n<p>.. warning::</p>\n\n<p>Note that the <strong>behavior of coerce_compared_value is not inherited\n   by default from that of the base type</strong>.\n   If the :class:<code>.TypeDecorator</code> is augmenting a\n   type that requires special logic for certain types of operators,\n   this method <strong>must</strong> be overridden.  A key example is when decorating\n   the :class:<code>_postgresql.JSON</code> and :class:<code>_postgresql.JSONB</code> types;\n   the default rules of :meth:<code>.TypeEngine.coerce_compared_value</code> should\n   be used in order to deal with operators like index operations::</p>\n\n<pre><code>    class MyJsonType(TypeDecorator):\n        impl = postgresql.JSON\n\n        def coerce_compared_value(self, op, value):\n            return self.impl.coerce_compared_value(op, value)\n</code></pre>\n\n<p>Without the above step, index operations such as <code>mycol['foo']</code>\n   will cause the index value <code>'foo'</code> to be JSON encoded.</p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.JSONType.impl", "modulename": "doctable.schemas.custom_coltypes", "qualname": "JSONType.impl", "type": "class", "doc": "<p>The base for all string and character types.</p>\n\n<p>In SQL, corresponds to VARCHAR.  Can also take Python unicode objects\nand encode to the database's encoding in bind params (and the reverse for\nresult sets.)</p>\n\n<p>The <code>length</code> field is usually required when the <code>String</code> type is\nused within a CREATE TABLE statement, as VARCHAR requires a length\non most databases.</p>\n"}, {"fullname": "doctable.schemas.custom_coltypes.JSONType.process_bind_param", "modulename": "doctable.schemas.custom_coltypes", "qualname": "JSONType.process_bind_param", "type": "function", "doc": "<p>Receive a bound parameter value to be converted.</p>\n\n<p>Subclasses override this method to return the\nvalue that should be passed along to the underlying\n:class:<code>.TypeEngine</code> object, and from there to the\nDBAPI <code>execute()</code> method.</p>\n\n<p>The operation could be anything desired to perform custom\nbehavior, such as transforming or serializing data.\nThis could also be used as a hook for validating logic.</p>\n\n<p>This operation should be designed with the reverse operation\nin mind, which would be the process_result_value method of\nthis class.</p>\n\n<p>:param value: Data to operate upon, of any type expected by\n this method in the subclass.  Can be <code>None</code>.\n:param dialect: the :class:<code>.Dialect</code> in use.</p>\n", "parameters": ["self", "value", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.JSONType.process_result_value", "modulename": "doctable.schemas.custom_coltypes", "qualname": "JSONType.process_result_value", "type": "function", "doc": "<p>Receive a result-row column value to be converted.</p>\n\n<p>Subclasses should implement this method to operate on data\nfetched from the database.</p>\n\n<p>Subclasses override this method to return the\nvalue that should be passed back to the application,\ngiven a value that is already processed by\nthe underlying :class:<code>.TypeEngine</code> object, originally\nfrom the DBAPI cursor method <code>fetchone()</code> or similar.</p>\n\n<p>The operation could be anything desired to perform custom\nbehavior, such as transforming or serializing data.\nThis could also be used as a hook for validating logic.</p>\n\n<p>:param value: Data to operate upon, of any type expected by\n this method in the subclass.  Can be <code>None</code>.\n:param dialect: the :class:<code>.Dialect</code> in use.</p>\n\n<p>This operation should be designed to be reversible by\nthe \"process_bind_param\" method of this class.</p>\n", "parameters": ["self", "value", "dialect"], "funcdef": "def"}, {"fullname": "doctable.schemas.custom_coltypes.is_iter", "modulename": "doctable.schemas.custom_coltypes", "qualname": "is_iter", "type": "function", "doc": "<p></p>\n", "parameters": ["o"], "funcdef": "def"}, {"fullname": "doctable.schemas.doctableschema", "modulename": "doctable.schemas.doctableschema", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.doctableschema.DocTableSchema", "modulename": "doctable.schemas.doctableschema", "qualname": "DocTableSchema", "type": "class", "doc": "<p>Base class for column objects.</p>\n"}, {"fullname": "doctable.schemas.doctableschema.DocTableSchema.__init__", "modulename": "doctable.schemas.doctableschema", "qualname": "DocTableSchema.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "doctable.schemas.doctableschema.DocTableSchema.get", "modulename": "doctable.schemas.doctableschema", "qualname": "DocTableSchema.get", "type": "function", "doc": "<p>Access data without throwing an error when accessing element.</p>\n", "parameters": ["self", "attr"], "funcdef": "def"}, {"fullname": "doctable.schemas.doctableschema.DocTableSchema.as_dict", "modulename": "doctable.schemas.doctableschema", "qualname": "DocTableSchema.as_dict", "type": "function", "doc": "<p>Public interface for _doctable_as_dict().</p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.schemas.emptyvalue", "modulename": "doctable.schemas.emptyvalue", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.emptyvalue.EmptyValue", "modulename": "doctable.schemas.emptyvalue", "qualname": "EmptyValue", "type": "class", "doc": "<p>Represents value that was not retrieved from select statement.</p>\n"}, {"fullname": "doctable.schemas.emptyvalue.EmptyValue.__init__", "modulename": "doctable.schemas.emptyvalue", "qualname": "EmptyValue.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.schemas.emptyvalue.EmptyValue.val", "modulename": "doctable.schemas.emptyvalue", "qualname": "EmptyValue.val", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.field_columns", "modulename": "doctable.schemas.field_columns", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.field_columns.Col", "modulename": "doctable.schemas.field_columns", "qualname": "Col", "type": "function", "doc": "<p>Returns dataclasses.field() after setting convienient params.\nArgs:\n    field_kwargs: passed directly to dataclasses.field.\n    **column_kwargs: passed to the sqlalchemy column object.</p>\n", "parameters": ["column_type", "field_kwargs", "type_kwargs", "column_kwargs"], "funcdef": "def"}, {"fullname": "doctable.schemas.field_columns.IDCol", "modulename": "doctable.schemas.field_columns", "qualname": "IDCol", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "doctable.schemas.field_columns.UpdatedCol", "modulename": "doctable.schemas.field_columns", "qualname": "UpdatedCol", "type": "function", "doc": "<p>Column that will automatically update the date/time when the row is modified.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "doctable.schemas.field_columns.AddedCol", "modulename": "doctable.schemas.field_columns", "qualname": "AddedCol", "type": "function", "doc": "<p>Column that will automatically update the date/time when the row is inserted.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "doctable.schemas.field_columns.PickleFileCol", "modulename": "doctable.schemas.field_columns", "qualname": "PickleFileCol", "type": "function", "doc": "<p>Column that will store arbitrary python data in the filesystem and keep only a reference.</p>\n", "parameters": ["folder", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.schemas.field_columns.TextFileCol", "modulename": "doctable.schemas.field_columns", "qualname": "TextFileCol", "type": "function", "doc": "<p>Column that will store text data in the filesystem and keep only a reference.</p>\n", "parameters": ["folder", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.schemas.field_columns.ParseTreeFileCol", "modulename": "doctable.schemas.field_columns", "qualname": "ParseTreeFileCol", "type": "function", "doc": "<p>Column that will store text data in the filesystem and keep only a reference.</p>\n", "parameters": ["folder", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.schemas.parse_schema_dataclass", "modulename": "doctable.schemas.parse_schema_dataclass", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.parse_schema_dataclass.parse_schema_dataclass", "modulename": "doctable.schemas.parse_schema_dataclass", "qualname": "parse_schema_dataclass", "type": "function", "doc": "<p>Convert a dataclass definition to a list of sqlalchemy columns.</p>\n", "parameters": ["Cls", "indices", "constraints"], "funcdef": "def"}, {"fullname": "doctable.schemas.parse_schema_dataclass.ColumnMetadata", "modulename": "doctable.schemas.parse_schema_dataclass", "qualname": "ColumnMetadata", "type": "class", "doc": "<p>ColumnMetadata(column_type: Union[str, type, sqlalchemy.sql.type_api.TypeEngine], type_kwargs: dict = None, column_kwargs: dict = None)</p>\n"}, {"fullname": "doctable.schemas.parse_schema_dataclass.ColumnMetadata.__init__", "modulename": "doctable.schemas.parse_schema_dataclass", "qualname": "ColumnMetadata.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "column_type", "type_kwargs", "column_kwargs"], "funcdef": "def"}, {"fullname": "doctable.schemas.parse_schema_dataclass.ColumnMetadata.column_type", "modulename": "doctable.schemas.parse_schema_dataclass", "qualname": "ColumnMetadata.column_type", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.parse_schema_dataclass.ColumnMetadata.type_kwargs", "modulename": "doctable.schemas.parse_schema_dataclass", "qualname": "ColumnMetadata.type_kwargs", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.parse_schema_dataclass.ColumnMetadata.column_kwargs", "modulename": "doctable.schemas.parse_schema_dataclass", "qualname": "ColumnMetadata.column_kwargs", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.parse_schema_dataclass.ColumnMetadata.has_type", "modulename": "doctable.schemas.parse_schema_dataclass", "qualname": "ColumnMetadata.has_type", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.parse_schema_dataclass.ColumnMetadata.get_sqlalchemy_type", "modulename": "doctable.schemas.parse_schema_dataclass", "qualname": "ColumnMetadata.get_sqlalchemy_type", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "type_hint"], "funcdef": "def"}, {"fullname": "doctable.schemas.parse_schema_dataclass.parse_columns", "modulename": "doctable.schemas.parse_schema_dataclass", "qualname": "parse_columns", "type": "function", "doc": "<p>Convert the dataclass member variables to sqlalchemy columns.</p>\n", "parameters": ["Cls"], "funcdef": "def"}, {"fullname": "doctable.schemas.parse_schema_dataclass.parse_indices", "modulename": "doctable.schemas.parse_schema_dataclass", "qualname": "parse_indices", "type": "function", "doc": "<p></p>\n", "parameters": ["indices"], "funcdef": "def"}, {"fullname": "doctable.schemas.parse_schema_dataclass.parse_constraints", "modulename": "doctable.schemas.parse_schema_dataclass", "qualname": "parse_constraints", "type": "function", "doc": "<p></p>\n", "parameters": ["constraints"], "funcdef": "def"}, {"fullname": "doctable.schemas.parse_schema_strings", "modulename": "doctable.schemas.parse_schema_strings", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.parse_schema_strings.is_ord_sequence", "modulename": "doctable.schemas.parse_schema_strings", "qualname": "is_ord_sequence", "type": "function", "doc": "<p></p>\n", "parameters": ["obj"], "funcdef": "def"}, {"fullname": "doctable.schemas.parse_schema_strings.parse_schema_strings", "modulename": "doctable.schemas.parse_schema_strings", "qualname": "parse_schema_strings", "type": "function", "doc": "<p></p>\n", "parameters": ["schema", "default_fpath"], "funcdef": "def"}, {"fullname": "doctable.schemas.schema_decorator", "modulename": "doctable.schemas.schema_decorator", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.schema_decorator.SlotsRequiredError", "modulename": "doctable.schemas.schema_decorator", "qualname": "SlotsRequiredError", "type": "class", "doc": "<p>Inappropriate argument value (of correct type).</p>\n"}, {"fullname": "doctable.schemas.schema_decorator.SlotsRequiredError.__init__", "modulename": "doctable.schemas.schema_decorator", "qualname": "SlotsRequiredError.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.schemas.schema_decorator.SlotsRequiredError.message", "modulename": "doctable.schemas.schema_decorator", "qualname": "SlotsRequiredError.message", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.schemas.schema_decorator.schema", "modulename": "doctable.schemas.schema_decorator", "qualname": "schema", "type": "function", "doc": "<p></p>\n", "parameters": ["_Cls", "require_slots", "dataclass_kwargs"], "funcdef": "def"}, {"fullname": "doctable.textmodels", "modulename": "doctable.textmodels", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.basedoc", "modulename": "doctable.textmodels.basedoc", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.basedoc.BaseDoc", "modulename": "doctable.textmodels.basedoc", "qualname": "BaseDoc", "type": "class", "doc": "<p>Built-in mutable sequence.</p>\n\n<p>If no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.</p>\n"}, {"fullname": "doctable.textmodels.bowdoc", "modulename": "doctable.textmodels.bowdoc", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.bowdoc.TokenDoc", "modulename": "doctable.textmodels.bowdoc", "qualname": "TokenDoc", "type": "class", "doc": "<p>Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.</p>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"s1\">&#39;abcdeabcdabcaba&#39;</span><span class=\"p\">)</span>  <span class=\"c1\"># count elements from a string</span>\n</code></pre></div>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">most_common</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>                <span class=\"c1\"># three most common elements</span>\n<span class=\"go\">[(&#39;a&#39;, 5), (&#39;b&#39;, 4), (&#39;c&#39;, 3)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span>                       <span class=\"c1\"># list all unique elements</span>\n<span class=\"go\">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s1\">&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"p\">()))</span>   <span class=\"c1\"># list elements with repetitions</span>\n<span class=\"go\">&#39;aaaaabbbbcccdde&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())</span>                 <span class=\"c1\"># total of all counts</span>\n<span class=\"go\">15</span>\n</code></pre></div>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">]</span>                          <span class=\"c1\"># count of letter &#39;a&#39;</span>\n<span class=\"go\">5</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">elem</span> <span class=\"ow\">in</span> <span class=\"s1\">&#39;shazam&#39;</span><span class=\"p\">:</span>           <span class=\"c1\"># update counts from an iterable</span>\n<span class=\"gp\">... </span>    <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"n\">elem</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>                <span class=\"c1\"># by adding 1 to each element&#39;s count</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">]</span>                          <span class=\"c1\"># now there are seven &#39;a&#39;</span>\n<span class=\"go\">7</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">del</span> <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;b&#39;</span><span class=\"p\">]</span>                      <span class=\"c1\"># remove all &#39;b&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;b&#39;</span><span class=\"p\">]</span>                          <span class=\"c1\"># now there are zero &#39;b&#39;</span>\n<span class=\"go\">0</span>\n</code></pre></div>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"s1\">&#39;simsalabim&#39;</span><span class=\"p\">)</span>       <span class=\"c1\"># make another counter</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">)</span>                     <span class=\"c1\"># add in the second counter</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">]</span>                          <span class=\"c1\"># now there are nine &#39;a&#39;</span>\n<span class=\"go\">9</span>\n</code></pre></div>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">clear</span><span class=\"p\">()</span>                       <span class=\"c1\"># empty the counter</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span>\n<span class=\"go\">Counter()</span>\n</code></pre></div>\n\n<p>Note:  If a count is set to zero or reduced to zero, it will remain\nin the counter until the entry is deleted or the counter is cleared:</p>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"s1\">&#39;aaabbc&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"s1\">&#39;b&#39;</span><span class=\"p\">]</span> <span class=\"o\">-=</span> <span class=\"mi\">2</span>                     <span class=\"c1\"># reduce the count of &#39;b&#39; by two</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">most_common</span><span class=\"p\">()</span>                 <span class=\"c1\"># &#39;b&#39; is still in, but its count is zero</span>\n<span class=\"go\">[(&#39;a&#39;, 3), (&#39;c&#39;, 1), (&#39;b&#39;, 0)]</span>\n</code></pre></div>\n"}, {"fullname": "doctable.textmodels.bowdoc.TokenDoc.toks", "modulename": "doctable.textmodels.bowdoc", "qualname": "TokenDoc.toks", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.exceptions", "modulename": "doctable.textmodels.exceptions", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.exceptions.DocTableExceptBase", "modulename": "doctable.textmodels.exceptions", "qualname": "DocTableExceptBase", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.textmodels.exceptions.DocTableExceptBase.__init__", "modulename": "doctable.textmodels.exceptions", "qualname": "DocTableExceptBase.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.textmodels.exceptions.MissingSpacyPipelineComponent", "modulename": "doctable.textmodels.exceptions", "qualname": "MissingSpacyPipelineComponent", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.textmodels.exceptions.MissingSpacyPipelineComponent.message", "modulename": "doctable.textmodels.exceptions", "qualname": "MissingSpacyPipelineComponent.message", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.exceptions.TreeAlreadyAssigned", "modulename": "doctable.textmodels.exceptions", "qualname": "TreeAlreadyAssigned", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.textmodels.exceptions.TreeAlreadyAssigned.message", "modulename": "doctable.textmodels.exceptions", "qualname": "TreeAlreadyAssigned.message", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.exceptions.PropertyNotAvailable", "modulename": "doctable.textmodels.exceptions", "qualname": "PropertyNotAvailable", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n"}, {"fullname": "doctable.textmodels.exceptions.PropertyNotAvailable.__init__", "modulename": "doctable.textmodels.exceptions", "qualname": "PropertyNotAvailable.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "prop", "parsefeatname"], "funcdef": "def"}, {"fullname": "doctable.textmodels.exceptions.PropertyNotAvailable.template", "modulename": "doctable.textmodels.exceptions", "qualname": "PropertyNotAvailable.template", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.parsetree", "modulename": "doctable.textmodels.parsetree", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.parsetree.ParseTree", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree", "type": "class", "doc": "<p>Represents a single parsetree.\nProperties:\n    root (Token): reference to root of parsetree\n    tokens list[Token]: ordered list of tokens</p>\n"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.__init__", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.__init__", "type": "function", "doc": "<p>Create from dict parsetree or spacy sentence root.\nArgs:\n    root_token (doctable.Token): root token of parsetree.</p>\n", "parameters": ["self", "root_token", "overwrite_tree"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.propogate_tree_ref", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.propogate_tree_ref", "type": "function", "doc": "<p>Recursively adds reference to current tree.\nRaises:\n    TreeAlreadyAssigned: if the given token already \n        maintains a reference to another tree. A token\n        can be assigned to only a single ParseTree.</p>\n", "parameters": ["self", "tok", "overwrite"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.get_token_list", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.get_token_list", "type": "function", "doc": "<p>Return ordered list of tokens.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.from_spacy", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.from_spacy", "type": "function", "doc": "<p>Create new parsetree from spacy doc.\nArgs:\n    spacy_sent: Spacy sent object.\n    args: passed to Token.from_spacy()\n    kwargs: passed to Token.from_spacy()</p>\n", "parameters": ["cls", "spacy_sent", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.from_dict", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.from_dict", "type": "function", "doc": "<p>Create new ParseTree from a dictionary tree created by as_dict().\nArgs:\n    root_tok_data: dict tree created from .as_dict()</p>\n", "parameters": ["cls", "root_tok_data", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.from_pickle", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.from_pickle", "type": "function", "doc": "<p></p>\n", "parameters": ["cls", "pickle_data"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.as_dict", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.as_dict", "type": "function", "doc": "<p>Convert to a dictionary tree.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.as_pickle", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.as_pickle", "type": "function", "doc": "<p>Return a pickled dictionary tree.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.token_texts", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.token_texts", "type": "function", "doc": "<p>List of token strings.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.display", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.display", "type": "function", "doc": "<p>TODO Print out an ascii tree.</p>\n", "parameters": ["self", "pad", "base", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetree.ParseTree.print_tree_recursive", "modulename": "doctable.textmodels.parsetree", "qualname": "ParseTree.print_tree_recursive", "type": "function", "doc": "<p>TODO Printing tree for visualization.</p>\n", "parameters": ["cls", "tok", "pad", "base", "level", "root_str", "dep_str"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetreedoc", "modulename": "doctable.textmodels.parsetreedoc", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.parsetreedoc.ParseTreeDoc", "modulename": "doctable.textmodels.parsetreedoc", "qualname": "ParseTreeDoc", "type": "class", "doc": "<p>Represents a document composed of sequence of parsetrees.</p>\n"}, {"fullname": "doctable.textmodels.parsetreedoc.ParseTreeDoc.tokens", "modulename": "doctable.textmodels.parsetreedoc", "qualname": "ParseTreeDoc.tokens", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.parsetreedoc.ParseTreeDoc.as_dict", "modulename": "doctable.textmodels.parsetreedoc", "qualname": "ParseTreeDoc.as_dict", "type": "function", "doc": "<p>Convert document into a list of dict-formatted parsetrees.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetreedoc.ParseTreeDoc.from_dict", "modulename": "doctable.textmodels.parsetreedoc", "qualname": "ParseTreeDoc.from_dict", "type": "function", "doc": "<p>Create new ParseTreeDoc from a dictionary tree created by as_dict().\nArgs:\n    tree_data: list of dict trees created from cls.as_dict()</p>\n", "parameters": ["cls", "tree_data", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.textmodels.parsetreedoc.ParseTreeDoc.from_spacy", "modulename": "doctable.textmodels.parsetreedoc", "qualname": "ParseTreeDoc.from_spacy", "type": "function", "doc": "<p>Create a new ParseTreeDoc from a spacy Doc object.</p>\n", "parameters": ["cls", "doc", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.textmodels.senttokendoc", "modulename": "doctable.textmodels.senttokendoc", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.senttokendoc.SentTokenDoc", "modulename": "doctable.textmodels.senttokendoc", "qualname": "SentTokenDoc", "type": "class", "doc": "<p>Built-in mutable sequence.</p>\n\n<p>If no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.</p>\n"}, {"fullname": "doctable.textmodels.senttokendoc.SentTokenDoc.toks", "modulename": "doctable.textmodels.senttokendoc", "qualname": "SentTokenDoc.toks", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token", "modulename": "doctable.textmodels.token", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token.Token", "modulename": "doctable.textmodels.token", "qualname": "Token", "type": "class", "doc": "<p>Object representing a single token.\nAttrs:\n    i: index of token in original sentence\n    text: text representation of token\n    dep: dependency relation estimated in spacy\n    tag: dependency tag estimated by spacy\n    childs: list of children Tokens\n    tree: reference to associated parsetree\n    otherdata: containes 'pos' and 'ent' data from spacy\n    userdata: data provided by user (usually generated \n        from userdata_map in from_spacy()).\n    parent: reference to parent Token (populated in \n        __post_init__).</p>\n"}, {"fullname": "doctable.textmodels.token.Token.__init__", "modulename": "doctable.textmodels.token", "qualname": "Token.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "i", "text", "dep", "tag", "childs", "otherdata", "userdata", "tree", "parent"], "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.i", "modulename": "doctable.textmodels.token", "qualname": "Token.i", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token.Token.text", "modulename": "doctable.textmodels.token", "qualname": "Token.text", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token.Token.dep", "modulename": "doctable.textmodels.token", "qualname": "Token.dep", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token.Token.tag", "modulename": "doctable.textmodels.token", "qualname": "Token.tag", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token.Token.childs", "modulename": "doctable.textmodels.token", "qualname": "Token.childs", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token.Token.otherdata", "modulename": "doctable.textmodels.token", "qualname": "Token.otherdata", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token.Token.userdata", "modulename": "doctable.textmodels.token", "qualname": "Token.userdata", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token.Token.tree", "modulename": "doctable.textmodels.token", "qualname": "Token.tree", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token.Token.parent", "modulename": "doctable.textmodels.token", "qualname": "Token.parent", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.token.Token.from_spacy", "modulename": "doctable.textmodels.token", "qualname": "Token.from_spacy", "type": "function", "doc": "<p>Return tokens recursively from spacy_tok object.\nArgs:\n    spacy_tok: token to extract userdata from\n    text_parse_func: mapping to store text data\n    userdata_map: used to create custom user data\n    tree (doctable.parse.ParseTree): reference to associated ParseTree</p>\n", "parameters": ["cls", "spacy_tok", "text_parse_func", "userdata_map", "parent", "tree"], "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.from_dict", "modulename": "doctable.textmodels.token", "qualname": "Token.from_dict", "type": "function", "doc": "<p>Create new token recursively using a dictionary tree structure.\nArgs:\n    tok_data: dictionary containing current token information\n    tree (ParseTree): reference to associated parsetree</p>\n", "parameters": ["cls", "tok_data", "tree"], "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.set_tree", "modulename": "doctable.textmodels.token", "qualname": "Token.set_tree", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "tree"], "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.as_dict", "modulename": "doctable.textmodels.token", "qualname": "Token.as_dict", "type": "function", "doc": "<p>Convert self to a dict tree - used when storing data.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.is_root", "modulename": "doctable.textmodels.token", "qualname": "Token.is_root", "type": "variable", "doc": "<p>Check if token is root or not.</p>\n"}, {"fullname": "doctable.textmodels.token.Token.pos", "modulename": "doctable.textmodels.token", "qualname": "Token.pos", "type": "variable", "doc": "<p>Access pos data.\nRaises:\n    PropertyNotAvailable: pos was not included in original spacy object.</p>\n"}, {"fullname": "doctable.textmodels.token.Token.ent", "modulename": "doctable.textmodels.token", "qualname": "Token.ent", "type": "variable", "doc": "<p>Access ent data.\nRaises:\n    PropertyNotAvailable: ent was not included in original spacy object.</p>\n"}, {"fullname": "doctable.textmodels.token.Token.get_childs", "modulename": "doctable.textmodels.token", "qualname": "Token.get_childs", "type": "function", "doc": "<p>Get children with the specified relations.\nArgs:\n    dep (sequence or string): dependency relations to match on.\n    pos (sequence or string): pos to match on.\n    matchfunc (function or None): additional custom matching function.</p>\n", "parameters": ["self", "dep", "pos", "matchfunc"], "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.get_child", "modulename": "doctable.textmodels.token", "qualname": "Token.get_child", "type": "function", "doc": "<p>Get first child with the given dependency relation.\nArgs:\n    <em>args: passed to get_childs\n    allow_multiple: don't allow \n    *</em>kwargs: passed to get_childs\nRaises:\n    ValueError when the token has more than one dependency with the \n        given relation.</p>\n", "parameters": ["self", "args", "allow_multiple", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.get_preps", "modulename": "doctable.textmodels.token", "qualname": "Token.get_preps", "type": "function", "doc": "<p>Gets chained prepositional phrases starting at the current token.\nReturns:\n    tuple of prep, pobj.</p>\n", "parameters": ["self", "as_str"], "funcdef": "def"}, {"fullname": "doctable.textmodels.token.Token.bubble_accum", "modulename": "doctable.textmodels.token", "qualname": "Token.bubble_accum", "type": "function", "doc": "<p>Bubble up results into a list.\nArgs:\n    func: function that accepts a Token and returns a list\n        of results that will be concatenated at each level\n        of the tree.\nExample:\n    <code>self.bubble_accum(lambda n: [n])</code> would return a list\n        of (unordered) tokens in the tree below the given \n        node.</p>\n", "parameters": ["self", "func"], "funcdef": "def"}, {"fullname": "doctable.textmodels.tokendoc", "modulename": "doctable.textmodels.tokendoc", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.textmodels.tokendoc.TokenDoc", "modulename": "doctable.textmodels.tokendoc", "qualname": "TokenDoc", "type": "class", "doc": "<p>Built-in mutable sequence.</p>\n\n<p>If no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.</p>\n"}, {"fullname": "doctable.textmodels.tokendoc.TokenDoc.toks", "modulename": "doctable.textmodels.tokendoc", "qualname": "TokenDoc.toks", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util", "modulename": "doctable.util", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.chunking", "modulename": "doctable.util.chunking", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.chunking.chunk", "modulename": "doctable.util.chunking", "qualname": "chunk", "type": "function", "doc": "<p>Break elements into chunks determined by chunk_kwargs sent to .chunk_slice().</p>\n", "parameters": ["elements", "chunk_kwargs"], "funcdef": "def"}, {"fullname": "doctable.util.chunking.chunk_slice", "modulename": "doctable.util.chunking", "qualname": "chunk_slice", "type": "function", "doc": "<p>Create slices for chunks of an array of size n.</p>\n", "parameters": ["n", "chunk_size", "num_chunks"], "funcdef": "def"}, {"fullname": "doctable.util.distribute", "modulename": "doctable.util.distribute", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.distribute.Distribute", "modulename": "doctable.util.distribute", "qualname": "Distribute", "type": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.util.distribute.Distribute.__init__", "modulename": "doctable.util.distribute", "qualname": "Distribute.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "workers", "override_maxcores"], "funcdef": "def"}, {"fullname": "doctable.util.distribute.Distribute.map_chunk", "modulename": "doctable.util.distribute", "qualname": "Distribute.map_chunk", "type": "function", "doc": "<p>Applies chunk_thread to chunks of elements.</p>\n", "parameters": ["self", "chunk_thread", "elements", "thread_args"], "funcdef": "def"}, {"fullname": "doctable.util.distribute.Distribute.map", "modulename": "doctable.util.distribute", "qualname": "Distribute.map", "type": "function", "doc": "<p>Map each element to be inserted in a doctable.\nDescription: Used primairly to maintain one doctable instance\n    per thread, but can have no other setup.\nArgs:\n    thread_func (func): applied to each element\n    elements (list&lt;&gt;): list of elements\n    thread_args: Additional args to be sent to each element</p>\n", "parameters": ["self", "thread_func", "elements", "thread_args"], "funcdef": "def"}, {"fullname": "doctable.util.distributeload", "modulename": "doctable.util.distributeload", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.distributeload.DistributeLoad", "modulename": "doctable.util.distributeload", "qualname": "DistributeLoad", "type": "class", "doc": "<p>Creates processing pool and gets results alongside everything else.</p>\n"}, {"fullname": "doctable.util.distributeload.DistributeLoad.__init__", "modulename": "doctable.util.distributeload", "qualname": "DistributeLoad.__init__", "type": "function", "doc": "<p>Args:\n    workers: number of workers in process pool.</p>\n", "parameters": ["self", "workers", "override_maxcores"], "funcdef": "def"}, {"fullname": "doctable.util.distributeload.WorkerThread", "modulename": "doctable.util.distributeload", "qualname": "WorkerThread", "type": "class", "doc": "<p>WorkerThread(wid: int)</p>\n"}, {"fullname": "doctable.util.distributeload.WorkerThread.__init__", "modulename": "doctable.util.distributeload", "qualname": "WorkerThread.__init__", "type": "function", "doc": "<p>Args:\n    wid: workerid of this thread.</p>\n", "parameters": ["self", "wid"], "funcdef": "def"}, {"fullname": "doctable.util.distributeload.WorkerThread.wid", "modulename": "doctable.util.distributeload", "qualname": "WorkerThread.wid", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.distributeload.WorkerThread.pid", "modulename": "doctable.util.distributeload", "qualname": "WorkerThread.pid", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.fsstore", "modulename": "doctable.util.fsstore", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.fsstore.FSStore", "modulename": "doctable.util.fsstore", "qualname": "FSStore", "type": "class", "doc": "<p>Class for storing and retriving records as pickle files.\nUseful in multi-threading applications where a direct database\n    insertion for each process would cause too much blocking.</p>\n"}, {"fullname": "doctable.util.fsstore.FSStore.__init__", "modulename": "doctable.util.fsstore", "qualname": "FSStore.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "folder", "records", "save_every", "seed_range", "check_collision", "settings_fname"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.default_settings", "modulename": "doctable.util.fsstore", "qualname": "FSStore.default_settings", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.fsstore.FSStore.init_folder", "modulename": "doctable.util.fsstore", "qualname": "FSStore.init_folder", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.set_seed", "modulename": "doctable.util.fsstore", "qualname": "FSStore.set_seed", "type": "function", "doc": "<p>Set random seeds for filename purposes.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.check_readonly", "modulename": "doctable.util.fsstore", "qualname": "FSStore.check_readonly", "type": "function", "doc": "<p>Raise exception if system set to readonly.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.read_setting", "modulename": "doctable.util.fsstore", "qualname": "FSStore.read_setting", "type": "function", "doc": "<p>Read file and return value of a particular setting.</p>\n", "parameters": ["self", "name"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.read_settings", "modulename": "doctable.util.fsstore", "qualname": "FSStore.read_settings", "type": "function", "doc": "<p>Read settings file.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.write_settings", "modulename": "doctable.util.fsstore", "qualname": "FSStore.write_settings", "type": "function", "doc": "<p>Read settings file and update any missing values.</p>\n", "parameters": ["self", "newsettings"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.clear_settings", "modulename": "doctable.util.fsstore", "qualname": "FSStore.clear_settings", "type": "function", "doc": "<p>Replace settings to defaults.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.insert", "modulename": "doctable.util.fsstore", "qualname": "FSStore.insert", "type": "function", "doc": "<p>Add a single record.</p>\n", "parameters": ["self", "record", "check_readonly"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.dump_file", "modulename": "doctable.util.fsstore", "qualname": "FSStore.dump_file", "type": "function", "doc": "<p>Save records to file and empty container.</p>\n", "parameters": ["self", "check_readonly"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.get_fname", "modulename": "doctable.util.fsstore", "qualname": "FSStore.get_fname", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.get_exist_fnames", "modulename": "doctable.util.fsstore", "qualname": "FSStore.get_exist_fnames", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.select_chunks", "modulename": "doctable.util.fsstore", "qualname": "FSStore.select_chunks", "type": "function", "doc": "<p>Yield records in file-sized chunks.</p>\n", "parameters": ["self", "loadbar"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.yield_records", "modulename": "doctable.util.fsstore", "qualname": "FSStore.yield_records", "type": "function", "doc": "<p>Reads pickle records and yields them one at a time.</p>\n", "parameters": ["self", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.select_records", "modulename": "doctable.util.fsstore", "qualname": "FSStore.select_records", "type": "function", "doc": "<p>Creates list of records from .yield_records()</p>\n", "parameters": ["self", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.delete_records", "modulename": "doctable.util.fsstore", "qualname": "FSStore.delete_records", "type": "function", "doc": "<p>Delete records (NOT settings or folder).</p>\n", "parameters": ["self", "force"], "funcdef": "def"}, {"fullname": "doctable.util.fsstore.FSStore.delete_all_completely", "modulename": "doctable.util.fsstore", "qualname": "FSStore.delete_all_completely", "type": "function", "doc": "<p>Will delete all records and the containing directory.</p>\n", "parameters": ["self", "force"], "funcdef": "def"}, {"fullname": "doctable.util.io", "modulename": "doctable.util.io", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.io.read_pickle", "modulename": "doctable.util.io", "qualname": "read_pickle", "type": "function", "doc": "<p></p>\n", "parameters": ["fname", "verbose"], "funcdef": "def"}, {"fullname": "doctable.util.io.write_pickle", "modulename": "doctable.util.io", "qualname": "write_pickle", "type": "function", "doc": "<p></p>\n", "parameters": ["obj", "fname", "verbose"], "funcdef": "def"}, {"fullname": "doctable.util.io.read_json", "modulename": "doctable.util.io", "qualname": "read_json", "type": "function", "doc": "<p></p>\n", "parameters": ["fname", "verbose"], "funcdef": "def"}, {"fullname": "doctable.util.io.write_json", "modulename": "doctable.util.io", "qualname": "write_json", "type": "function", "doc": "<p></p>\n", "parameters": ["obj", "fname", "verbose"], "funcdef": "def"}, {"fullname": "doctable.util.logstep", "modulename": "doctable.util.logstep", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStepDiff", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff", "type": "class", "doc": "<p>LogStepDiff(ind_diff: int, ts_diff: datetime.timedelta, mem_diff: int, msg1: str, msg2: str, meta1: Any, meta2: Any)</p>\n"}, {"fullname": "doctable.util.logstep.LogStepDiff.__init__", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ind_diff", "ts_diff", "mem_diff", "msg1", "msg2", "meta1", "meta2"], "funcdef": "def"}, {"fullname": "doctable.util.logstep.LogStepDiff.ind_diff", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.ind_diff", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStepDiff.ts_diff", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.ts_diff", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStepDiff.mem_diff", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.mem_diff", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStepDiff.msg1", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.msg1", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStepDiff.msg2", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.msg2", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStepDiff.meta1", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.meta1", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStepDiff.meta2", "modulename": "doctable.util.logstep", "qualname": "LogStepDiff.meta2", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStep", "modulename": "doctable.util.logstep", "qualname": "LogStep", "type": "class", "doc": "<p>LogStep(ind: int = None, msg: str = None, ts: datetime.datetime = <factory>, mem: int = <factory>, meta: Any = None)</p>\n"}, {"fullname": "doctable.util.logstep.LogStep.__init__", "modulename": "doctable.util.logstep", "qualname": "LogStep.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ind", "msg", "ts", "mem", "meta"], "funcdef": "def"}, {"fullname": "doctable.util.logstep.LogStep.ind", "modulename": "doctable.util.logstep", "qualname": "LogStep.ind", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStep.msg", "modulename": "doctable.util.logstep", "qualname": "LogStep.msg", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStep.ts", "modulename": "doctable.util.logstep", "qualname": "LogStep.ts", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStep.mem", "modulename": "doctable.util.logstep", "qualname": "LogStep.mem", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStep.meta", "modulename": "doctable.util.logstep", "qualname": "LogStep.meta", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.logstep.LogStep.diff", "modulename": "doctable.util.logstep", "qualname": "LogStep.diff", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "doctable.util.queueinserter", "modulename": "doctable.util.queueinserter", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.queueinserter.QueueInserter", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter", "type": "class", "doc": "<p>Used to manage queued bulk insertion program logic.</p>\n"}, {"fullname": "doctable.util.queueinserter.QueueInserter.__init__", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "db", "chunk_size", "verbose", "insert_kwargs"], "funcdef": "def"}, {"fullname": "doctable.util.queueinserter.QueueInserter.insert", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.insert", "type": "function", "doc": "<p>Add a single record to the queue.</p>\n", "parameters": ["self", "record"], "funcdef": "def"}, {"fullname": "doctable.util.queueinserter.QueueInserter.insert_many", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.insert_many", "type": "function", "doc": "<p>Insert multiple records into the queue.</p>\n", "parameters": ["self", "records"], "funcdef": "def"}, {"fullname": "doctable.util.queueinserter.QueueInserter.dump_check", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.dump_check", "type": "function", "doc": "<p>Dump queue into database if meets threshold.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.util.queueinserter.QueueInserter.dump", "modulename": "doctable.util.queueinserter", "qualname": "QueueInserter.dump", "type": "function", "doc": "<p>Insert queue data.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.util.showstopper", "modulename": "doctable.util.showstopper", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.showstopper.showstopper", "modulename": "doctable.util.showstopper", "qualname": "showstopper", "type": "function", "doc": "<p>Totally fills a machine's resources until you can kill it.</p>\n", "parameters": ["n_cores", "n"], "funcdef": "def"}, {"fullname": "doctable.util.showstopper.malloc_thread", "modulename": "doctable.util.showstopper", "qualname": "malloc_thread", "type": "function", "doc": "<p></p>\n", "parameters": ["i", "k"], "funcdef": "def"}, {"fullname": "doctable.util.slots", "modulename": "doctable.util.slots", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.slots.SlotsRequiredError", "modulename": "doctable.util.slots", "qualname": "SlotsRequiredError", "type": "class", "doc": "<p>Inappropriate argument value (of correct type).</p>\n"}, {"fullname": "doctable.util.slots.SlotsRequiredError.__init__", "modulename": "doctable.util.slots", "qualname": "SlotsRequiredError.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "args", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.util.slots.SlotsRequiredError.message", "modulename": "doctable.util.slots", "qualname": "SlotsRequiredError.message", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.slots.slots_dataclass", "modulename": "doctable.util.slots", "qualname": "slots_dataclass", "type": "function", "doc": "<p>Automattically add slots to the given dataclass.</p>\n", "parameters": ["_Cls", "dataclass_kwargs"], "funcdef": "def"}, {"fullname": "doctable.util.staticargparse", "modulename": "doctable.util.staticargparse", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.tempfolder", "modulename": "doctable.util.tempfolder", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.tempfolder.TempFolder", "modulename": "doctable.util.tempfolder", "qualname": "TempFolder", "type": "class", "doc": "<p></p>\n"}, {"fullname": "doctable.util.tempfolder.TempFolder.__init__", "modulename": "doctable.util.tempfolder", "qualname": "TempFolder.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "folder", "make_folder"], "funcdef": "def"}, {"fullname": "doctable.util.tempfolder.TempFolder.mkdir", "modulename": "doctable.util.tempfolder", "qualname": "TempFolder.mkdir", "type": "function", "doc": "<p>Make the directory if it does not exist.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.util.tempfolder.TempFolder.rmtree", "modulename": "doctable.util.tempfolder", "qualname": "TempFolder.rmtree", "type": "function", "doc": "<p>Remove all files recursively in the folder.</p>\n", "parameters": ["self", "ignore_errors", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.util.tempfolder.TempFolder.rglob", "modulename": "doctable.util.tempfolder", "qualname": "TempFolder.rglob", "type": "function", "doc": "<p>Get list of filenames in the directory.</p>\n", "parameters": ["self", "p", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.util.tempfolder.TempFolder.joinpath", "modulename": "doctable.util.tempfolder", "qualname": "TempFolder.joinpath", "type": "function", "doc": "<p>Join path with provided fname.</p>\n", "parameters": ["self", "fname"], "funcdef": "def"}, {"fullname": "doctable.util.timer", "modulename": "doctable.util.timer", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.timer.Timer", "modulename": "doctable.util.timer", "qualname": "Timer", "type": "class", "doc": "<p>Times a task.</p>\n"}, {"fullname": "doctable.util.timer.Timer.__init__", "modulename": "doctable.util.timer", "qualname": "Timer.__init__", "type": "function", "doc": "<p>Add single step for current datetime.</p>\n", "parameters": ["self", "message", "logfile", "new_log", "verbose", "show_ts", "show_delta", "show_mem"], "funcdef": "def"}, {"fullname": "doctable.util.timer.Timer.last", "modulename": "doctable.util.timer", "qualname": "Timer.last", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.timer.Timer.first", "modulename": "doctable.util.timer", "qualname": "Timer.first", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.timer.Timer.step", "modulename": "doctable.util.timer", "qualname": "Timer.step", "type": "function", "doc": "<p>Add a new step, print and log it if needed.</p>\n", "parameters": ["self", "message", "verbose", "format_args"], "funcdef": "def"}, {"fullname": "doctable.util.timer.Timer.print_step", "modulename": "doctable.util.timer", "qualname": "Timer.print_step", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "step", "verbose", "format_args"], "funcdef": "def"}, {"fullname": "doctable.util.timer.Timer.write_log", "modulename": "doctable.util.timer", "qualname": "Timer.write_log", "type": "function", "doc": "<p>Write text to log file.</p>\n", "parameters": ["self", "text"], "funcdef": "def"}, {"fullname": "doctable.util.timer.Timer.rm_log", "modulename": "doctable.util.timer", "qualname": "Timer.rm_log", "type": "function", "doc": "<p>Delete log file.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "doctable.util.timer.Timer.get_diff_stat", "modulename": "doctable.util.timer", "qualname": "Timer.get_diff_stat", "type": "function", "doc": "<p>Get stats on differences between time points.\nArgs:\n    stat: name of function in \"statistics\" module to call</p>\n", "parameters": ["self", "stat", "as_str"], "funcdef": "def"}, {"fullname": "doctable.util.timer.Timer.time_call", "modulename": "doctable.util.timer", "qualname": "Timer.time_call", "type": "function", "doc": "<p>Time function call with 0.05 ms latency per call.</p>\n", "parameters": ["cls", "func", "args", "num_calls", "as_str", "kwargs"], "funcdef": "def"}, {"fullname": "doctable.util.timer.Step", "modulename": "doctable.util.timer", "qualname": "Step", "type": "class", "doc": "<p>Step(_msg: str, i: int, ts: datetime.datetime = <factory>, mem: int = <factory>)</p>\n"}, {"fullname": "doctable.util.timer.Step.__init__", "modulename": "doctable.util.timer", "qualname": "Step.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "_msg", "i", "ts", "mem"], "funcdef": "def"}, {"fullname": "doctable.util.timer.Step.i", "modulename": "doctable.util.timer", "qualname": "Step.i", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.timer.Step.ts", "modulename": "doctable.util.timer", "qualname": "Step.ts", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.timer.Step.mem", "modulename": "doctable.util.timer", "qualname": "Step.mem", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.timer.Step.msg", "modulename": "doctable.util.timer", "qualname": "Step.msg", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "doctable.util.timer.Step.ts_diff", "modulename": "doctable.util.timer", "qualname": "Step.ts_diff", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "other"], "funcdef": "def"}, {"fullname": "doctable.util.timer.Step.format", "modulename": "doctable.util.timer", "qualname": "Step.format", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "prev_step", "show_ts", "show_delta", "show_mem"], "funcdef": "def"}, {"fullname": "doctable.util.unit_format", "modulename": "doctable.util.unit_format", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "doctable.util.unit_format.format_time", "modulename": "doctable.util.unit_format", "qualname": "format_time", "type": "function", "doc": "<p>Get string representing time quantity with correct units.</p>\n", "parameters": ["num_seconds"], "funcdef": "def"}, {"fullname": "doctable.util.unit_format.format_memory", "modulename": "doctable.util.unit_format", "qualname": "format_memory", "type": "function", "doc": "<p>Get string representing memory quantity with correct units.</p>\n", "parameters": ["num_bytes"], "funcdef": "def"}]