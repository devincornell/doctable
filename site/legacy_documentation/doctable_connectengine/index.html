<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Manage SQL Connections with DocTable - My Docs</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">My Docs</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../documentation/ex_basics/" class="dropdown-item">Basics of doctable</a>
</li>
                                    
<li>
    <a href="../../documentation/ex_insert_delete/" class="dropdown-item">Insert and Delete Queries with doctable</a>
</li>
                                    
<li>
    <a href="../../documentation/ex_schemas/" class="dropdown-item">Table Schemas</a>
</li>
                                    
<li>
    <a href="../../documentation/ex_select/" class="dropdown-item">Select Queries with doctable</a>
</li>
                                    
<li>
    <a href="../../documentation/iris_example/" class="dropdown-item">Iris example</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Legacy documentation <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../dataclass_example/" class="dropdown-item">Dataclass Schema Example</a>
</li>
                                    
<li>
    <a href="../dataclass_vignette_advanced/" class="dropdown-item">Advanced dataclass schema vignette</a>
</li>
                                    
<li>
    <a href="../depric_vignette_newsgroups/" class="dropdown-item">NewsGroups Dataset Vignette</a>
</li>
                                    
<li>
    <a href="../distributed_basics/" class="dropdown-item">Distribute Parallel Processing Basics</a>
</li>
                                    
<li>
    <a href="../doctable_basics/" class="dropdown-item">DocTable Overview</a>
</li>
                                    
<li>
    <a href="../doctable_bootstrap/" class="dropdown-item">Document Bootstrapping Examples</a>
</li>
                                    
<li>
    <a href="../doctable_concurrency/" class="dropdown-item">Concurrent Database Connections</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Manage SQL Connections with DocTable</a>
</li>
                                    
<li>
    <a href="../doctable_file_column_types/" class="dropdown-item">DocTable File Column Types</a>
</li>
                                    
<li>
    <a href="../doctable_insert_delete/" class="dropdown-item">DocTable Examples: Insert and Delete</a>
</li>
                                    
<li>
    <a href="../doctable_multitable/" class="dropdown-item">Example: Multiple Tables</a>
</li>
                                    
<li>
    <a href="../doctable_parsetreedoc_column/" class="dropdown-item">ParseTreeDoc Column Types</a>
</li>
                                    
<li>
    <a href="../doctable_picklefile/" class="dropdown-item">DocTable Example: Pickle and Text Files</a>
</li>
                                    
<li>
    <a href="../doctable_schema/" class="dropdown-item">DocTable Schemas</a>
</li>
                                    
<li>
    <a href="../doctable_schema_dataclass/" class="dropdown-item">DocTable Example: Schemas</a>
</li>
                                    
<li>
    <a href="../doctable_schema_legacy/" class="dropdown-item">DocTable Schemas</a>
</li>
                                    
<li>
    <a href="../doctable_select/" class="dropdown-item">DocTable Examples: Select</a>
</li>
                                    
<li>
    <a href="../doctable_update/" class="dropdown-item">DocTable Examples: Update</a>
</li>
                                    
<li>
    <a href="../example_nss_1_intro/" class="dropdown-item">Vignette 1: Storing Document Metadata</a>
</li>
                                    
<li>
    <a href="../example_nss_2_parsing/" class="dropdown-item">Vignette 2: Storing Document Text</a>
</li>
                                    
<li>
    <a href="../example_nss_3_parsetrees/" class="dropdown-item">Vignette 3: Storing Parsed Documents</a>
</li>
                                    
<li>
    <a href="../example_nss_intro_dataclass/" class="dropdown-item">Example 1: US National Security Strategy Document Corpus</a>
</li>
                                    
<li>
    <a href="../legacy_adv/" class="dropdown-item">DocTable (slightly more) Advanced Example</a>
</li>
                                    
<li>
    <a href="../legacy_simple/" class="dropdown-item">DocTable Simple Example</a>
</li>
                                    
<li>
    <a href="../parse_parsepipeline/" class="dropdown-item">ParsePipeline Basics</a>
</li>
                                    
<li>
    <a href="../parse_parsetrees/" class="dropdown-item">Working with doctable Parsetrees</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../doctable_concurrency/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../doctable_file_column_types/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#manage-sql-connections-with-doctable" class="nav-link">Manage SQL Connections with DocTable</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#connectengine-class" class="nav-link">ConnectEngine Class</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#managing-connections-with-connectengine" class="nav-link">Managing connections with ConnectEngine</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#doctable-and-connectengine" class="nav-link">DocTable and ConnectEngine</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="manage-sql-connections-with-doctable">Manage SQL Connections with DocTable</h1>
<p>This is meant to give a bit more depth describing how doctable works under-the-hood. I won't cover the details of DocTable methods or working with doctable objects, but I will try to give a clearer sense of how connections and tables are managed within a doctable instance.</p>
<p>The driving motivator behind doctable is to create an object-oriented interface for working with sql tables by linking schemas described in your code with the structure of the databases you work with. This model is less ideal for the kinds of application-based frameworks where you would define the database schema once and build code around it separately, but works well for data science applications where you will be creating new tables and playing with different schemas regularly as your approach and end-goals change.</p>
<p>When you instantiate a DocTable (or inheriting class), the object will convert your provided schema into a set of sqlalchemy objects which are then stored in-memory as part of the doctable instance. If the table does not already exist in the actual database, DocTable can create one that matches the provided schema, and then the schema will be used to work with the underlying database table. I will now discuss the lower-level objects that manage the metadata and connections to the database.</p>
<pre><code class="language-python">import sys
sys.path.append('..')
import doctable
</code></pre>
<h2 id="connectengine-class">ConnectEngine Class</h2>
<p>Each doctable maintains a <code>ConnectEngine</code> object to manage database connections and metadata that make all other database operations possible. I'll demonstrate how to instantiate this class manually to show how it works.</p>
<p>The constructor takes arguments for dialect (sqlite, mysql, etc) and database target (filename or database server) to create new sqlalchemy <a href="https://docs.sqlalchemy.org/en/13/core/engines_connections.html">engine</a> and <a href="https://docs.sqlalchemy.org/en/13/faq/metadata_schema.html">metadata</a> objects. The engine object stores information about the target and can generate database connections, the metadata object stores schemas for registered tables. To work with a table, the metadata object must have the table schema registered, although it can be constructed from the database object itself.</p>
<p>See here that the constructor requires a target (file or server where the database is located) and a dialect (flavor of database engine). This connection sits above individual table connections, and thus maintains no connections of it's own - only the engine that can create connections. We can, however list the tables in the database and perform other operations on the table.</p>
<pre><code class="language-python">engine = doctable.ConnectEngine(target=':memory:', dialect='sqlite')
engine
</code></pre>
<pre><code>sqlite:///:memory:
</code></pre>
<h3 id="working-with-tables">Working with tables</h3>
<p>You can also execute connectionless queries directly from this object, although normally you would create a connection object first and then execute queries from the connection. In this example I use a custom sql query to create a new table.</p>
<p>As the ConnectEngine sits above the level of tables, we can list and drop tables from here.</p>
<pre><code class="language-python"># see there are no tables here yet.
engine.list_tables()
</code></pre>
<pre><code>[]
</code></pre>
<pre><code class="language-python"># run this raw sql query just for example
# NOTE: Normally you would NOT create a table this way using doctable.
# This is just for example purposes.
query = 'CREATE TABLE temp (id INTEGER PRIMARY KEY, number INTEGER NOT NULL)'
engine.execute(query)
</code></pre>
<pre><code>&lt;sqlalchemy.engine.result.ResultProxy at 0x7f62a10e9370&gt;
</code></pre>
<pre><code class="language-python"># see that the table is now in the database
engine.list_tables()
</code></pre>
<pre><code>['temp']
</code></pre>
<pre><code class="language-python"># uses inspect to ask the database directly for the schema
engine.schema('temp')
</code></pre>
<pre><code>[{'name': 'id',
  'type': INTEGER(),
  'nullable': True,
  'default': None,
  'autoincrement': 'auto',
  'primary_key': 1},
 {'name': 'number',
  'type': INTEGER(),
  'nullable': False,
  'default': None,
  'autoincrement': 'auto',
  'primary_key': 0}]
</code></pre>
<pre><code class="language-python"># or as a dataframe
engine.schema_df('temp')
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>type</th>
      <th>nullable</th>
      <th>default</th>
      <th>autoincrement</th>
      <th>primary_key</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>id</td>
      <td>INTEGER</td>
      <td>True</td>
      <td>None</td>
      <td>auto</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>number</td>
      <td>INTEGER</td>
      <td>False</td>
      <td>None</td>
      <td>auto</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>

<p>All of these methods I've shown so far access the database tables directly, but currently our python objects do not have any idea of what the table schema looks like. You can view the sqlalchemy table objects actually registered with the engine by using the .tables property. See that it is currently empty! Our python code is not able to work with the table using objects because it does not have record of the schema. Now we'll show how to register tables with the engine.</p>
<h3 id="creating-and-accessing-tables">Creating and accessing tables</h3>
<p>To create a data structure internally representing the database structure, we can either ask sqlalchemy to read the database and create the schema, or we can provide lists of sqlalchemy column objects. Wee that we can access the registered tables using the .tables property.</p>
<pre><code class="language-python"># see that currently our engine does not have information about the table we created above.
engine.tables
</code></pre>
<pre><code>immutabledict({})
</code></pre>
<pre><code class="language-python"># now I ask doctable to read the database schema and register the table in metadata.
engine.add_table('temp')
</code></pre>
<pre><code>Table('temp', MetaData(bind=Engine(sqlite:///:memory:)), Column('id', INTEGER(), table=&lt;temp&gt;, primary_key=True, nullable=False), Column('number', INTEGER(), table=&lt;temp&gt;, nullable=False), schema=None)
</code></pre>
<pre><code class="language-python"># and we can see that the table is registered
engine.tables
</code></pre>
<pre><code>immutabledict({'temp': Table('temp', MetaData(bind=Engine(sqlite:///:memory:)), Column('id', INTEGER(), table=&lt;temp&gt;, primary_key=True, nullable=False), Column('number', INTEGER(), table=&lt;temp&gt;, nullable=False), schema=None)})
</code></pre>
<p>When add_table() is called, a new sqlalchemy.Table object is registered in the engine's metadata and returned. If add_table() is called again, it will return the table already registered in the metadata. Because we usually use doctable to manage tables, we'll just show a short example here.</p>
<pre><code class="language-python"># while we can use doctable to do most of this work 
#  usually, I'll just show how sqlalchemy core objects 
#  can be used to create a table in ConnectEngine.
from sqlalchemy import Column, Integer, String

# create a list of columns
columns = (
    Column('id', Integer, primary_key = True), 
    Column('name', String), 
)

# we similarly use the add_table() method to store the schema
#  in the metadata
engine.add_table('temp2', columns=columns)
</code></pre>
<pre><code>Table('temp2', MetaData(bind=Engine(sqlite:///:memory:)), Column('id', Integer(), table=&lt;temp2&gt;, primary_key=True, nullable=False), Column('name', String(), table=&lt;temp2&gt;), schema=None)
</code></pre>
<pre><code class="language-python"># see now that the engine has information about both tables
engine.tables
</code></pre>
<pre><code>immutabledict({'temp': Table('temp', MetaData(bind=Engine(sqlite:///:memory:)), Column('id', INTEGER(), table=&lt;temp&gt;, primary_key=True, nullable=False), Column('number', INTEGER(), table=&lt;temp&gt;, nullable=False), schema=None), 'temp2': Table('temp2', MetaData(bind=Engine(sqlite:///:memory:)), Column('id', Integer(), table=&lt;temp2&gt;, primary_key=True, nullable=False), Column('name', String(), table=&lt;temp2&gt;), schema=None)})
</code></pre>
<pre><code class="language-python"># and see that you can get individual table object references like this
engine.tables['temp']
</code></pre>
<pre><code>Table('temp', MetaData(bind=Engine(sqlite:///:memory:)), Column('id', INTEGER(), table=&lt;temp&gt;, primary_key=True, nullable=False), Column('number', INTEGER(), table=&lt;temp&gt;, nullable=False), schema=None)
</code></pre>
<h3 id="dropping-tables">Dropping tables</h3>
<p>Dropping tables is simple enough, but remember that the schema stored in the database and the objects in code mirror each other, so it is best to manipulate them at the same time. Use .drop_table instead of issuing CREATE TABLE query to make sure they stay in sync. The method can also be used on tables that are not in the metadata engine.</p>
<pre><code class="language-python"># by providing the argument as a string
engine.drop_table('temp')
</code></pre>
<pre><code class="language-python">engine.list_tables()
</code></pre>
<pre><code>['temp2']
</code></pre>
<p>In cases where an underlying table has been deleted but metadata is retained, the drop_table() method will still work but you may need to call clear_metadata() to flush all metadata and add_all_tables() to re-create the metadata from the actual data.</p>
<pre><code class="language-python"># see this works although the temp3 table is not registered in engine metadata
query = 'CREATE TABLE temp3 (id INTEGER PRIMARY KEY, number INTEGER NOT NULL)'
engine.execute(query)
engine.drop_table('temp3')
</code></pre>
<pre><code class="language-python"># this will delete the underlying table even though the metadata information still exists.
query = 'CREATE TABLE temp4 (id INTEGER PRIMARY KEY, number INTEGER NOT NULL)'
engine.execute(query)
engine.execute(f'DROP TABLE IF EXISTS temp4')
engine.list_tables()
</code></pre>
<pre><code>['temp2']
</code></pre>
<pre><code class="language-python"># see that the table is still registered in the metadata
engine.tables
</code></pre>
<pre><code>immutabledict({'temp': Table('temp', MetaData(bind=Engine(sqlite:///:memory:)), Column('id', INTEGER(), table=&lt;temp&gt;, primary_key=True, nullable=False), Column('number', INTEGER(), table=&lt;temp&gt;, nullable=False), schema=None), 'temp2': Table('temp2', MetaData(bind=Engine(sqlite:///:memory:)), Column('id', Integer(), table=&lt;temp2&gt;, primary_key=True, nullable=False), Column('name', String(), table=&lt;temp2&gt;), schema=None), 'temp3': Table('temp3', MetaData(bind=Engine(sqlite:///:memory:)), Column('id', INTEGER(), table=&lt;temp3&gt;, primary_key=True, nullable=False), Column('number', INTEGER(), table=&lt;temp3&gt;, nullable=False), schema=None)})
</code></pre>
<pre><code class="language-python"># in this case, it might be simplest just to clear all metadata
# and re-build according to exising tables
engine.clear_metadata()
engine.reflect()
engine.tables
</code></pre>
<pre><code>immutabledict({'temp2': Table('temp2', MetaData(bind=Engine(sqlite:///:memory:)), Column('id', INTEGER(), table=&lt;temp2&gt;, primary_key=True, nullable=False), Column('name', VARCHAR(), table=&lt;temp2&gt;), schema=None)})
</code></pre>
<h2 id="managing-connections-with-connectengine">Managing connections with ConnectEngine</h2>
<p>ConnectEngine objects are used to create database connections which are maintained by individual doctable objects. Use the get_connection() function to retreive a new connection object which you can use to execute queries. While garbage collecting the connection objects will close the individual connection, sometimes all connections need to be closed simultaneously. This is especially important because garbage-collecting the ConnectEngine object doesn't mean the connections will be garbage-collected if they have references elsewhere in your code. You can close all connections using the close_connections() method.</p>
<pre><code class="language-python"># make new connection
conn = engine.connect()
conn
</code></pre>
<pre><code>&lt;sqlalchemy.engine.base.Connection at 0x7f62a10301f0&gt;
</code></pre>
<pre><code class="language-python"># see here we just run a select query on the empty table, returning an empty list
list(conn.execute('SELECT * FROM temp2'))
</code></pre>
<pre><code>[]
</code></pre>
<p>An important use-case of this feature is when you have multiple processes accessing the same database. In general, each process should have separate connections to the database, but both the engine and metadata stored with the ConnectEngine can be copied. Here I'll show a basic multiprocessing case using the Distribute class (it works much like multiprocessing.Pool()).</p>
<p>In using the map function we open two processes, and in the thread function we call the close_connections() method to delete existing connections which don't exist in this new memory space.</p>
<pre><code class="language-python">def thread(nums, engine: doctable.ConnectEngine):
    # close connections that were opened in other thread
    #engine.close_connections()
    engine.dispose()

    # create a new connection for this thread
    thread_conn = engine.connect()

numbers = [1,2]
with doctable.Distribute(2) as d:
    d.map(thread, numbers, engine)
</code></pre>
<pre><code class="language-python">engine.list_tables()
</code></pre>
<pre><code>['temp2']
</code></pre>
<h2 id="doctable-and-connectengine">DocTable and ConnectEngine</h2>
<p>Every DocTable object maintains a ConnectEngine to store information about the table they represent, and can be accessed through the engine property. When a target and dialect are provided to doctable, it will automatically initialize a new ConnectEngine and store a new connection object.</p>
<pre><code class="language-python"># create a new doctable and view it's engine
schema = (('idcol', 'id'), ('string', 'name'))
db = doctable.DocTable(target=':memory:', schema=schema)
str(db.engine)
</code></pre>
<pre><code>'&lt;ConnectEngine::sqlite:///:memory:&gt;'
</code></pre>
<p>The DocTable constructor can also accept an engine in place of a target and dialect, and thus share ConnectEngines between multiple DocTable objects. In this case, the doctable constructor will use the provided schema to insert the table information into the engine metadata and create the table if doesn't already exist. It will also generate a new connection object from the ConnectEngine.</p>
<pre><code class="language-python"># a w
engine.clear_metadata()
print(engine.tables.keys())
print(engine.list_tables())
</code></pre>
<pre><code>dict_keys([])
['temp2']
</code></pre>
<pre><code class="language-python"># make a new doctable using the existing engine
schema = (('idcol', 'id'), ('string', 'name'))
db = doctable.DocTable(engine=engine, schema=schema, tabname='tmp5')
db
</code></pre>
<pre><code>&lt;doctable.doctable.DocTable at 0x7f62a1096b20&gt;
</code></pre>
<pre><code class="language-python"># make another doctable using existing engine
schema2 = (('idcol', 'id'), ('string', 'name'))
db2 = doctable.DocTable(engine=engine, schema=schema2, tabname='tmp6')
db2
</code></pre>
<pre><code>&lt;doctable.doctable.DocTable at 0x7f62a0fd4cd0&gt;
</code></pre>
<pre><code class="language-python"># we can see that both tables have been created in the database
engine.list_tables()
</code></pre>
<pre><code>['temp2', 'tmp5', 'tmp6']
</code></pre>
<pre><code class="language-python"># and that both are registered in the metadata
engine.tables.keys()
</code></pre>
<pre><code>dict_keys(['tmp5', 'tmp6'])
</code></pre>
<p>Some ConnectEngine methods are also accessable through the DocTable instances.</p>
<pre><code class="language-python">db.list_tables()
</code></pre>
<pre><code>['temp2', 'tmp5', 'tmp6']
</code></pre>
<pre><code class="language-python">db.schema_table()
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>type</th>
      <th>nullable</th>
      <th>default</th>
      <th>autoincrement</th>
      <th>primary_key</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>id</td>
      <td>INTEGER</td>
      <td>False</td>
      <td>None</td>
      <td>auto</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>name</td>
      <td>VARCHAR</td>
      <td>True</td>
      <td>None</td>
      <td>auto</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>

<pre><code class="language-python"># and this is equivalent to calling the engine method reopen(), which clears 
#  metadata and closes connection pool
db.reopen_engine()
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/jquery-3.6.0.min.js"></script>
        <script src="../../js/bootstrap.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
